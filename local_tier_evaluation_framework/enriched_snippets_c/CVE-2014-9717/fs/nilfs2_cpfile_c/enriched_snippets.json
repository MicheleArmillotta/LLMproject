[
  {
    "function_name": "nilfs_cpfile_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "939-981",
    "snippet": "int nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *cpfile;\n\tint err;\n\n\tif (cpsize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t} else if (cpsize < NILFS_MIN_CHECKPOINT_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t}\n\n\tcpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\n\tif (unlikely(!cpfile))\n\t\treturn -ENOMEM;\n\tif (!(cpfile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(cpfile, cpsize,\n\t\t\t\t sizeof(struct nilfs_cpfile_header));\n\n\terr = nilfs_read_inode_common(cpfile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(cpfile);\n out:\n\t*inodep = cpfile;\n\treturn 0;\n failed:\n\tiget_failed(cpfile);\n\treturn err;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "cpfile"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "cpfile"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_read_inode_common",
          "args": [
            "cpfile",
            "raw_inode"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "463-502",
          "snippet": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_set_entry_size",
          "args": [
            "cpfile",
            "cpsize",
            "sizeof(struct nilfs_cpfile_header)"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_set_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "440-448",
          "snippet": "void nilfs_mdt_set_entry_size(struct inode *inode, unsigned entry_size,\n\t\t\t      unsigned header_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_entry_size = entry_size;\n\tmi->mi_entries_per_block = (1 << inode->i_blkbits) / entry_size;\n\tmi->mi_first_entry_offset = DIV_ROUND_UP(header_size, entry_size);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_set_entry_size(struct inode *inode, unsigned entry_size,\n\t\t\t      unsigned header_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_entry_size = entry_size;\n\tmi->mi_entries_per_block = (1 << inode->i_blkbits) / entry_size;\n\tmi->mi_first_entry_offset = DIV_ROUND_UP(header_size, entry_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_init",
          "args": [
            "cpfile",
            "NILFS_MDT_GFP",
            "0"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "419-438",
          "snippet": "int nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};",
            "static const struct inode_operations def_mdt_iops;",
            "static const struct file_operations def_mdt_fops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};\nstatic const struct inode_operations def_mdt_iops;\nstatic const struct file_operations def_mdt_fops;\n\nint nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpfile"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget_locked",
          "args": [
            "sb",
            "NULL",
            "NILFS_CPFILE_INO"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "598-606",
          "snippet": "struct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"NILFS: too small checkpoint size: %zu bytes.\\n\"",
            "cpsize"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *cpfile;\n\tint err;\n\n\tif (cpsize > sb->s_blocksize) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too large checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t} else if (cpsize < NILFS_MIN_CHECKPOINT_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: too small checkpoint size: %zu bytes.\\n\",\n\t\t       cpsize);\n\t\treturn -EINVAL;\n\t}\n\n\tcpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\n\tif (unlikely(!cpfile))\n\t\treturn -ENOMEM;\n\tif (!(cpfile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(cpfile, cpsize,\n\t\t\t\t sizeof(struct nilfs_cpfile_header));\n\n\terr = nilfs_read_inode_common(cpfile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(cpfile);\n out:\n\t*inodep = cpfile;\n\treturn 0;\n failed:\n\tiget_failed(cpfile);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "907-930",
    "snippet": "int nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\tcpstat->cs_cno = nilfs_mdt_cno(cpfile);\n\tcpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\n\tcpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "header->ch_nsnapshots"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_cno",
          "args": [
            "cpfile"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "109-112",
          "snippet": "static inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "bh",
            "kaddr"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&bh"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\tcpstat->cs_cno = nilfs_mdt_cno(cpfile);\n\tcpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\n\tcpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_change_cpmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "868-890",
    "snippet": "int nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\tif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\n\t\t\t/*\n\t\t\t * Current implementation does not have to protect\n\t\t\t * plain read-only mounts since they are exclusive\n\t\t\t * with a read/write mount and are protected from the\n\t\t\t * cleaner.\n\t\t\t */\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = nilfs_cpfile_clear_snapshot(cpfile, cno);\n\t\treturn ret;\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_set_snapshot(cpfile, cno);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_set_snapshot",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_set_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "581-698",
          "snippet": "static int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 curr, prev;\n\tunsigned long curr_blkoff, prev_blkoff;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tlist = &header->ch_snapshot_list;\n\tcurr_bh = header_bh;\n\tget_bh(curr_bh);\n\tcurr = 0;\n\tcurr_blkoff = 0;\n\tprev = le64_to_cpu(list->ssl_prev);\n\twhile (prev > cno) {\n\t\tprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\n\t\tcurr = prev;\n\t\tif (curr_blkoff != prev_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(curr_bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\n\t\t\t\t\t\t\t\t0, &curr_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_header;\n\t\t\tkaddr = kmap_atomic(curr_bh->b_page);\n\t\t}\n\t\tcurr_blkoff = prev_blkoff;\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, curr, curr_bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t\tprev = le64_to_cpu(list->ssl_prev);\n\t}\n\tkunmap_atomic(kaddr);\n\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_curr;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(curr_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, curr, curr_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\n\tnilfs_checkpoint_set_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, 1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(curr_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_curr:\n\tbrelse(curr_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 curr, prev;\n\tunsigned long curr_blkoff, prev_blkoff;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tlist = &header->ch_snapshot_list;\n\tcurr_bh = header_bh;\n\tget_bh(curr_bh);\n\tcurr = 0;\n\tcurr_blkoff = 0;\n\tprev = le64_to_cpu(list->ssl_prev);\n\twhile (prev > cno) {\n\t\tprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\n\t\tcurr = prev;\n\t\tif (curr_blkoff != prev_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(curr_bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\n\t\t\t\t\t\t\t\t0, &curr_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_header;\n\t\t\tkaddr = kmap_atomic(curr_bh->b_page);\n\t\t}\n\t\tcurr_blkoff = prev_blkoff;\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, curr, curr_bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t\tprev = le64_to_cpu(list->ssl_prev);\n\t}\n\tkunmap_atomic(kaddr);\n\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_curr;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(curr_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, curr, curr_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\n\tnilfs_checkpoint_set_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, 1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(curr_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_curr:\n\tbrelse(curr_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_clear_snapshot",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_clear_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "700-801",
          "snippet": "static int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 next, prev;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (!nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\n\tlist = &cp->cp_snapshot_list;\n\tnext = le64_to_cpu(list->ssl_next);\n\tprev = le64_to_cpu(list->ssl_prev);\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tif (next != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\n\t\t\t\t\t\t\t&next_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t} else {\n\t\tnext_bh = header_bh;\n\t\tget_bh(next_bh);\n\t}\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_next;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(next_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, next, next_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(prev);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(next);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\n\tnilfs_checkpoint_clear_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, -1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(next_bh);\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_next:\n\tbrelse(next_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 next, prev;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (!nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\n\tlist = &cp->cp_snapshot_list;\n\tnext = le64_to_cpu(list->ssl_next);\n\tprev = le64_to_cpu(list->ssl_prev);\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tif (next != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\n\t\t\t\t\t\t\t&next_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t} else {\n\t\tnext_bh = header_bh;\n\t\tget_bh(next_bh);\n\t}\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_next;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(next_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, next, next_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(prev);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(next);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\n\tnilfs_checkpoint_clear_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, -1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(next_bh);\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_next:\n\tbrelse(next_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_is_mounted",
          "args": [
            "cpfile->i_sb",
            "cno"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_checkpoint_is_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1015-1044",
          "snippet": "int nilfs_checkpoint_is_mounted(struct super_block *sb, __u64 cno)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tif (cno < 0 || cno > nilfs->ns_cno)\n\t\treturn false;\n\n\tif (cno >= nilfs_last_cno(nilfs))\n\t\treturn true;\t/* protect recent checkpoints */\n\n\tret = false;\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root) {\n\t\tinode = nilfs_ilookup(sb, root, NILFS_ROOT_INO);\n\t\tif (inode) {\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (dentry) {\n\t\t\t\tret = nilfs_tree_is_busy(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t}\n\t\tnilfs_put_root(root);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_checkpoint_is_mounted(struct super_block *sb, __u64 cno)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tif (cno < 0 || cno > nilfs->ns_cno)\n\t\treturn false;\n\n\tif (cno >= nilfs_last_cno(nilfs))\n\t\treturn true;\t/* protect recent checkpoints */\n\n\tret = false;\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root) {\n\t\tinode = nilfs_ilookup(sb, root, NILFS_ROOT_INO);\n\t\tif (inode) {\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (dentry) {\n\t\t\t\tret = nilfs_tree_is_busy(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t}\n\t\tnilfs_put_root(root);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\tif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\n\t\t\t/*\n\t\t\t * Current implementation does not have to protect\n\t\t\t * plain read-only mounts since they are exclusive\n\t\t\t * with a read/write mount and are protected from the\n\t\t\t * cleaner.\n\t\t\t */\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = nilfs_cpfile_clear_snapshot(cpfile, cno);\n\t\treturn ret;\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_set_snapshot(cpfile, cno);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "nilfs_cpfile_is_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "820-848",
    "snippet": "int nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\t/* CP number is invalid if it's zero or larger than the\n\tlargest\texist one.*/\n\tif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\n\t\treturn -ENOENT;\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out;\n\tkaddr = kmap_atomic(bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp))\n\t\tret = -ENOENT;\n\telse\n\t\tret = nilfs_checkpoint_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_snapshot",
          "args": [
            "cp"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "bh",
            "kaddr"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "cno",
            "0",
            "&bh"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_cno",
          "args": [
            "cpfile"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "109-112",
          "snippet": "static inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\t/* CP number is invalid if it's zero or larger than the\n\tlargest\texist one.*/\n\tif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\n\t\treturn -ENOENT;\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out;\n\tkaddr = kmap_atomic(bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp))\n\t\tret = -ENOENT;\n\telse\n\t\tret = nilfs_checkpoint_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_clear_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "700-801",
    "snippet": "static int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 next, prev;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (!nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\n\tlist = &cp->cp_snapshot_list;\n\tnext = le64_to_cpu(list->ssl_next);\n\tprev = le64_to_cpu(list->ssl_prev);\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tif (next != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\n\t\t\t\t\t\t\t&next_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t} else {\n\t\tnext_bh = header_bh;\n\t\tget_bh(next_bh);\n\t}\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_next;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(next_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, next, next_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(prev);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(next);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\n\tnilfs_checkpoint_clear_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, -1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(next_bh);\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_next:\n\tbrelse(next_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "cp_bh"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "cpfile"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "header_bh"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&header->ch_nsnapshots",
            "-1"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "header_bh",
            "kaddr"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "header_bh->b_page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_clear_snapshot",
          "args": [
            "cp"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "cp_bh",
            "kaddr"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "next"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_snapshot_list",
          "args": [
            "cpfile",
            "prev",
            "prev_bh",
            "kaddr"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_snapshot_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "561-579",
          "snippet": "static struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "prev_bh->b_page"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "prev"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "next_bh->b_page"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "prev_bh"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "prev",
            "0",
            "&prev_bh"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "next_bh"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&header_bh"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "list->ssl_prev"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_snapshot",
          "args": [
            "cp"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 next, prev;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (!nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\n\tlist = &cp->cp_snapshot_list;\n\tnext = le64_to_cpu(list->ssl_next);\n\tprev = le64_to_cpu(list->ssl_prev);\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tif (next != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\n\t\t\t\t\t\t\t&next_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t} else {\n\t\tnext_bh = header_bh;\n\t\tget_bh(next_bh);\n\t}\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_next;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(next_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, next, next_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(prev);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(next);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\n\tnilfs_checkpoint_clear_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, -1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(next_bh);\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_next:\n\tbrelse(next_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_set_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "581-698",
    "snippet": "static int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 curr, prev;\n\tunsigned long curr_blkoff, prev_blkoff;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tlist = &header->ch_snapshot_list;\n\tcurr_bh = header_bh;\n\tget_bh(curr_bh);\n\tcurr = 0;\n\tcurr_blkoff = 0;\n\tprev = le64_to_cpu(list->ssl_prev);\n\twhile (prev > cno) {\n\t\tprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\n\t\tcurr = prev;\n\t\tif (curr_blkoff != prev_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(curr_bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\n\t\t\t\t\t\t\t\t0, &curr_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_header;\n\t\t\tkaddr = kmap_atomic(curr_bh->b_page);\n\t\t}\n\t\tcurr_blkoff = prev_blkoff;\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, curr, curr_bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t\tprev = le64_to_cpu(list->ssl_prev);\n\t}\n\tkunmap_atomic(kaddr);\n\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_curr;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(curr_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, curr, curr_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\n\tnilfs_checkpoint_set_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, 1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(curr_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_curr:\n\tbrelse(curr_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "cp_bh"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "cpfile"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "header_bh"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&header->ch_nsnapshots",
            "1"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "header_bh",
            "kaddr"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "header_bh->b_page"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cno"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_snapshot_list",
          "args": [
            "cpfile",
            "prev",
            "prev_bh",
            "kaddr"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_snapshot_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "561-579",
          "snippet": "static struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "prev_bh->b_page"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_set_snapshot",
          "args": [
            "cp"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "prev"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "curr"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "cp_bh",
            "kaddr"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cno"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "curr_bh->b_page"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "prev_bh"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "prev",
            "0",
            "&prev_bh"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "list->ssl_prev"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "curr_bh->b_page"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_blkoff",
          "args": [
            "cpfile",
            "prev"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "40-46",
          "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "curr_bh"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "header_bh->b_page"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&header_bh"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_snapshot",
          "args": [
            "cp"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 curr, prev;\n\tunsigned long curr_blkoff, prev_blkoff;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tlist = &header->ch_snapshot_list;\n\tcurr_bh = header_bh;\n\tget_bh(curr_bh);\n\tcurr = 0;\n\tcurr_blkoff = 0;\n\tprev = le64_to_cpu(list->ssl_prev);\n\twhile (prev > cno) {\n\t\tprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\n\t\tcurr = prev;\n\t\tif (curr_blkoff != prev_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(curr_bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\n\t\t\t\t\t\t\t\t0, &curr_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_header;\n\t\t\tkaddr = kmap_atomic(curr_bh->b_page);\n\t\t}\n\t\tcurr_blkoff = prev_blkoff;\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, curr, curr_bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t\tprev = le64_to_cpu(list->ssl_prev);\n\t}\n\tkunmap_atomic(kaddr);\n\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_curr;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(curr_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, curr, curr_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\n\tnilfs_checkpoint_set_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, 1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(curr_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_curr:\n\tbrelse(curr_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_get_snapshot_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "561-579",
    "snippet": "static struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "bh",
            "kaddr"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "bh",
            "kaddr"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}"
  },
  {
    "function_name": "nilfs_cpfile_delete_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "544-559",
    "snippet": "int nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\n{\n\tstruct nilfs_cpinfo ci;\n\t__u64 tcno = cno;\n\tssize_t nci;\n\n\tnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\n\tif (nci < 0)\n\t\treturn nci;\n\telse if (nci == 0 || ci.ci_cno != cno)\n\t\treturn -ENOENT;\n\telse if (nilfs_cpinfo_snapshot(&ci))\n\t\treturn -EBUSY;\n\n\treturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_delete_checkpoints",
          "args": [
            "cpfile",
            "cno",
            "cno + 1"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_delete_checkpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "278-375",
          "snippet": "int nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpinfo_snapshot",
          "args": [
            "&ci"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_do_get_cpinfo",
          "args": [
            "cpfile",
            "&tcno",
            "&ci",
            "sizeof(ci)",
            "1"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_do_get_cpinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "390-438",
          "snippet": "static ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\n{\n\tstruct nilfs_cpinfo ci;\n\t__u64 tcno = cno;\n\tssize_t nci;\n\n\tnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\n\tif (nci < 0)\n\t\treturn nci;\n\telse if (nci == 0 || ci.ci_cno != cno)\n\t\treturn -ENOENT;\n\telse if (nilfs_cpinfo_snapshot(&ci))\n\t\treturn -EBUSY;\n\n\treturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_cpinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "526-537",
    "snippet": "ssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\n\t\t\t\tvoid *buf, unsigned cisz, size_t nci)\n{\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\treturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_do_get_ssinfo",
          "args": [
            "cpfile",
            "cnop",
            "buf",
            "cisz",
            "nci"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_do_get_ssinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "440-516",
          "snippet": "static ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\t__u64 curr = *cnop, next;\n\tunsigned long curr_blkoff, next_blkoff;\n\tvoid *kaddr;\n\tint n = 0, ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tif (curr == 0) {\n\t\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tcurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t\tif (curr == 0) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (unlikely(curr == ~(__u64)0)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* No snapshots (started from a hole block) */\n\t\tgoto out;\n\t}\n\tkaddr = kmap_atomic(bh->b_page);\n\twhile (n < nci) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\n\t\tcurr = ~(__u64)0; /* Terminator */\n\t\tif (unlikely(nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)))\n\t\t\tbreak;\n\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\n\t\tci = (void *)ci + cisz;\n\t\tn++;\n\t\tnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n\t\tif (next == 0)\n\t\t\tbreak; /* reach end of the snapshot list */\n\n\t\tnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\n\t\tif (curr_blkoff != next_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\n\t\t\t\t\t\t\t\t0, &bh);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkaddr = kmap_atomic(bh->b_page);\n\t\t}\n\t\tcurr = next;\n\t\tcurr_blkoff = next_blkoff;\n\t}\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\t*cnop = curr;\n\tret = n;\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\t__u64 curr = *cnop, next;\n\tunsigned long curr_blkoff, next_blkoff;\n\tvoid *kaddr;\n\tint n = 0, ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tif (curr == 0) {\n\t\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tcurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t\tif (curr == 0) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (unlikely(curr == ~(__u64)0)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* No snapshots (started from a hole block) */\n\t\tgoto out;\n\t}\n\tkaddr = kmap_atomic(bh->b_page);\n\twhile (n < nci) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\n\t\tcurr = ~(__u64)0; /* Terminator */\n\t\tif (unlikely(nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)))\n\t\t\tbreak;\n\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\n\t\tci = (void *)ci + cisz;\n\t\tn++;\n\t\tnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n\t\tif (next == 0)\n\t\t\tbreak; /* reach end of the snapshot list */\n\n\t\tnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\n\t\tif (curr_blkoff != next_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\n\t\t\t\t\t\t\t\t0, &bh);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkaddr = kmap_atomic(bh->b_page);\n\t\t}\n\t\tcurr = next;\n\t\tcurr_blkoff = next_blkoff;\n\t}\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\t*cnop = curr;\n\tret = n;\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_do_get_cpinfo",
          "args": [
            "cpfile",
            "cnop",
            "buf",
            "cisz",
            "nci"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_do_get_cpinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "390-438",
          "snippet": "static ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\n\t\t\t\tvoid *buf, unsigned cisz, size_t nci)\n{\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\treturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "nilfs_cpfile_do_get_ssinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "440-516",
    "snippet": "static ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\t__u64 curr = *cnop, next;\n\tunsigned long curr_blkoff, next_blkoff;\n\tvoid *kaddr;\n\tint n = 0, ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tif (curr == 0) {\n\t\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tcurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t\tif (curr == 0) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (unlikely(curr == ~(__u64)0)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* No snapshots (started from a hole block) */\n\t\tgoto out;\n\t}\n\tkaddr = kmap_atomic(bh->b_page);\n\twhile (n < nci) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\n\t\tcurr = ~(__u64)0; /* Terminator */\n\t\tif (unlikely(nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)))\n\t\t\tbreak;\n\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\n\t\tci = (void *)ci + cisz;\n\t\tn++;\n\t\tnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n\t\tif (next == 0)\n\t\t\tbreak; /* reach end of the snapshot list */\n\n\t\tnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\n\t\tif (curr_blkoff != next_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\n\t\t\t\t\t\t\t\t0, &bh);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkaddr = kmap_atomic(bh->b_page);\n\t\t}\n\t\tcurr = next;\n\t\tcurr_blkoff = next_blkoff;\n\t}\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\t*cnop = curr;\n\tret = n;\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret == -ENOENT"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "next",
            "0",
            "&bh"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_blkoff",
          "args": [
            "cpfile",
            "next"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "40-46",
          "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "cp->cp_snapshot_list.ssl_next"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoint_to_cpinfo",
          "args": [
            "cpfile",
            "cp",
            "ci"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoint_to_cpinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "377-388",
          "snippet": "static void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_snapshot",
          "args": [
            "cp"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "curr",
            "bh",
            "kaddr"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "curr == ~(__u64)0"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "bh",
            "kaddr"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&bh"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\t__u64 curr = *cnop, next;\n\tunsigned long curr_blkoff, next_blkoff;\n\tvoid *kaddr;\n\tint n = 0, ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tif (curr == 0) {\n\t\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tcurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t\tif (curr == 0) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (unlikely(curr == ~(__u64)0)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* No snapshots (started from a hole block) */\n\t\tgoto out;\n\t}\n\tkaddr = kmap_atomic(bh->b_page);\n\twhile (n < nci) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\n\t\tcurr = ~(__u64)0; /* Terminator */\n\t\tif (unlikely(nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)))\n\t\t\tbreak;\n\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\n\t\tci = (void *)ci + cisz;\n\t\tn++;\n\t\tnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n\t\tif (next == 0)\n\t\t\tbreak; /* reach end of the snapshot list */\n\n\t\tnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\n\t\tif (curr_blkoff != next_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\n\t\t\t\t\t\t\t\t0, &bh);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkaddr = kmap_atomic(bh->b_page);\n\t\t}\n\t\tcurr = next;\n\t\tcurr_blkoff = next_blkoff;\n\t}\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\t*cnop = curr;\n\tret = n;\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_do_get_cpinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "390-438",
    "snippet": "static ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoint_to_cpinfo",
          "args": [
            "cpfile",
            "cp",
            "ci"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoint_to_cpinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "377-388",
          "snippet": "static void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "bh",
            "kaddr"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "cno",
            "0",
            "&bh"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_in_block",
          "args": [
            "cpfile",
            "cno",
            "cur_cno"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_in_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "56-65",
          "snippet": "static unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_cno",
          "args": [
            "cpfile"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "109-112",
          "snippet": "static inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned cisz, size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT; /* checkpoint number 0 is invalid */\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; cno < cur_cno && n < nci; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tgoto out;\n\t\t\tcontinue; /* skip hole */\n\t\t}\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_checkpoint_to_cpinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "377-388",
    "snippet": "static void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "cp->cp_snapshot_list.ssl_next"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cp->cp_flags"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}"
  },
  {
    "function_name": "nilfs_cpfile_delete_checkpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "278-375",
    "snippet": "int nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "header_bh"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "cpfile"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "header_bh"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&header->ch_ncheckpoints",
            "-(u64)tnicps"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "header_bh",
            "kaddr"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "header_bh->b_page"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\"",
            "__func__"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_delete_checkpoint_block",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_delete_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "149-154",
          "snippet": "static inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t       __u64 cno)\n{\n\treturn nilfs_mdt_delete_block(cpfile,\n\t\t\t\t      nilfs_cpfile_get_blkoff(cpfile, cno));\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t       __u64 cno)\n{\n\treturn nilfs_mdt_delete_block(cpfile,\n\t\t\t\t      nilfs_cpfile_get_blkoff(cpfile, cno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_sub_valid_checkpoints",
          "args": [
            "cpfile",
            "cp_bh",
            "kaddr",
            "nicps"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_sub_valid_checkpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "87-100",
          "snippet": "static unsigned int\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) - n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned int\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) - n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_is_in_first",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_is_in_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "67-71",
          "snippet": "static inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_set_invalid",
          "args": [
            "cp"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_snapshot",
          "args": [
            "cp"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "cp_bh",
            "kaddr"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "cno",
            "0",
            "&cp_bh"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_in_block",
          "args": [
            "cpfile",
            "cno",
            "end"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_in_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "56-65",
          "snippet": "static unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&header_bh"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "start == 0 || start > end"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tprintk(KERN_ERR \"%s: invalid range of checkpoint numbers: \"\n\t\t       \"[%llu, %llu)\\n\", __func__,\n\t\t       (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t/* skip hole */\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t/* make hole */\n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t       \"%s: cannot delete block\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_put_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "252-257",
    "snippet": "void nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh->b_page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "181-240",
    "snippet": "int nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "header_bh"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "cpfile"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "header_bh"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&header->ch_ncheckpoints",
            "1"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_header",
          "args": [
            "cpfile",
            "header_bh",
            "kaddr"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "102-108",
          "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "header_bh->b_page"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_add_valid_checkpoints",
          "args": [
            "cpfile",
            "cp_bh",
            "kaddr",
            "1"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_add_valid_checkpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "73-85",
          "snippet": "static unsigned int\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) + n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned int\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) + n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_is_in_first",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_is_in_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "67-71",
          "snippet": "static inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_clear_invalid",
          "args": [
            "cp"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_invalid",
          "args": [
            "cp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_block_get_checkpoint",
          "args": [
            "cpfile",
            "cno",
            "cp_bh",
            "kaddr"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_block_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "110-117",
          "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "cp_bh->b_page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint_block",
          "args": [
            "cpfile",
            "cno",
            "create",
            "&cp_bh"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "139-147",
          "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_header_block",
          "args": [
            "cpfile",
            "&header_bh"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "133-137",
          "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&NILFS_MDT(cpfile)->mi_sem"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_cno",
          "args": [
            "cpfile"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "109-112",
          "snippet": "static inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u64 nilfs_mdt_cno(struct inode *inode)\n{\n\treturn ((struct the_nilfs *)inode->i_sb->s_fs_info)->ns_cno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cpfile_delete_checkpoint_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "149-154",
    "snippet": "static inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t       __u64 cno)\n{\n\treturn nilfs_mdt_delete_block(cpfile,\n\t\t\t\t      nilfs_cpfile_get_blkoff(cpfile, cno));\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_delete_block",
          "args": [
            "cpfile",
            "nilfs_cpfile_get_blkoff(cpfile, cno)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "275-286",
          "snippet": "int nilfs_mdt_delete_block(struct inode *inode, unsigned long block)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\terr = nilfs_bmap_delete(ii->i_bmap, block);\n\tif (!err || err == -ENOENT) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\tnilfs_mdt_forget_block(inode, block);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_delete_block(struct inode *inode, unsigned long block)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\terr = nilfs_bmap_delete(ii->i_bmap, block);\n\tif (!err || err == -ENOENT) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\tnilfs_mdt_forget_block(inode, block);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_blkoff",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "40-46",
          "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t       __u64 cno)\n{\n\treturn nilfs_mdt_delete_block(cpfile,\n\t\t\t\t      nilfs_cpfile_get_blkoff(cpfile, cno));\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_checkpoint_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "139-147",
    "snippet": "static inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_get_block",
          "args": [
            "cpfile",
            "nilfs_cpfile_get_blkoff(cpfile, cno)",
            "create",
            "nilfs_cpfile_block_init",
            "bhp"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "242-261",
          "snippet": "int nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_blkoff",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "40-46",
          "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_header_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "133-137",
    "snippet": "static inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_get_block",
          "args": [
            "cpfile",
            "0",
            "0",
            "NULL",
            "bhp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "242-261",
          "snippet": "int nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "119-131",
    "snippet": "static void nilfs_cpfile_block_init(struct inode *cpfile,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    void *kaddr)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\tint n = nilfs_cpfile_checkpoints_per_block(cpfile);\n\n\twhile (n-- > 0) {\n\t\tnilfs_checkpoint_set_invalid(cp);\n\t\tcp = (void *)cp + cpsz;\n\t}\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_checkpoint_set_invalid",
          "args": [
            "cp"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_per_block",
          "args": [
            "cpfile"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "33-37",
          "snippet": "static inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic void nilfs_cpfile_block_init(struct inode *cpfile,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    void *kaddr)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\tint n = nilfs_cpfile_checkpoints_per_block(cpfile);\n\n\twhile (n-- > 0) {\n\t\tnilfs_checkpoint_set_invalid(cp);\n\t\tcp = (void *)cp + cpsz;\n\t}\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_get_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "110-117",
    "snippet": "static struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_offset",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "49-54",
          "snippet": "static unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_get_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "102-108",
    "snippet": "static inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_sub_valid_checkpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "87-100",
    "snippet": "static unsigned int\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) - n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "count"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cp->cp_checkpoints_count"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "le32_to_cpu(cp->cp_checkpoints_count) < n"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned int\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) - n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}"
  },
  {
    "function_name": "nilfs_cpfile_block_add_valid_checkpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "73-85",
    "snippet": "static unsigned int\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) + n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "count"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cp->cp_checkpoints_count"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned int\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) + n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}"
  },
  {
    "function_name": "nilfs_cpfile_is_in_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "67-71",
    "snippet": "static inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_blkoff",
          "args": [
            "cpfile",
            "cno"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "40-46",
          "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}"
  },
  {
    "function_name": "nilfs_cpfile_checkpoints_in_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "56-65",
    "snippet": "static unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "__u64",
            "nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr)",
            "max - curr"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_offset",
          "args": [
            "cpfile",
            "curr"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "49-54",
          "snippet": "static unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_per_block",
          "args": [
            "cpfile"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "33-37",
          "snippet": "static inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "49-54",
    "snippet": "static unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tcno",
            "nilfs_cpfile_checkpoints_per_block(cpfile)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_per_block",
          "args": [
            "cpfile"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "33-37",
          "snippet": "static inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}"
  },
  {
    "function_name": "nilfs_cpfile_get_blkoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "40-46",
    "snippet": "static unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tcno",
            "nilfs_cpfile_checkpoints_per_block(cpfile)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_checkpoints_per_block",
          "args": [
            "cpfile"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_checkpoints_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "33-37",
          "snippet": "static inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}"
  },
  {
    "function_name": "nilfs_cpfile_checkpoints_per_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
    "lines": "33-37",
    "snippet": "static inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}",
    "includes": [
      "#include \"cpfile.h\"",
      "#include \"mdt.h\"",
      "#include <linux/nilfs2_fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "cpfile"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}"
  }
]