[
  {
    "function_name": "nfsd4_get_writestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6600-6604",
    "snippet": "void\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate, struct nfsd4_write *write)\n{\n\tget_stateid(cstate, &write->wr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&write->wr_stateid"
          ],
          "line": 6603
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate, struct nfsd4_write *write)\n{\n\tget_stateid(cstate, &write->wr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_readstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6594-6598",
    "snippet": "void\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate, struct nfsd4_read *read)\n{\n\tget_stateid(cstate, &read->rd_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&read->rd_stateid"
          ],
          "line": 6597
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate, struct nfsd4_read *read)\n{\n\tget_stateid(cstate, &read->rd_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_lockustateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6588-6592",
    "snippet": "void\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate, struct nfsd4_locku *locku)\n{\n\tget_stateid(cstate, &locku->lu_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&locku->lu_stateid"
          ],
          "line": 6591
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate, struct nfsd4_locku *locku)\n{\n\tget_stateid(cstate, &locku->lu_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_closestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6582-6586",
    "snippet": "void\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tget_stateid(cstate, &close->cl_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&close->cl_stateid"
          ],
          "line": 6585
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tget_stateid(cstate, &close->cl_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_setattrstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6576-6580",
    "snippet": "void\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate, struct nfsd4_setattr *setattr)\n{\n\tget_stateid(cstate, &setattr->sa_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&setattr->sa_stateid"
          ],
          "line": 6579
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate, struct nfsd4_setattr *setattr)\n{\n\tget_stateid(cstate, &setattr->sa_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_freestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6570-6574",
    "snippet": "void\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate, struct nfsd4_free_stateid *fsp)\n{\n\tget_stateid(cstate, &fsp->fr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&fsp->fr_stateid"
          ],
          "line": 6573
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate, struct nfsd4_free_stateid *fsp)\n{\n\tget_stateid(cstate, &fsp->fr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_delegreturnstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6564-6568",
    "snippet": "void\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate, struct nfsd4_delegreturn *drp)\n{\n\tget_stateid(cstate, &drp->dr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&drp->dr_stateid"
          ],
          "line": 6567
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate, struct nfsd4_delegreturn *drp)\n{\n\tget_stateid(cstate, &drp->dr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_opendowngradestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6558-6562",
    "snippet": "void\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tget_stateid(cstate, &odp->od_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&odp->od_stateid"
          ],
          "line": 6561
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6505-6510",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tget_stateid(cstate, &odp->od_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_lockstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6548-6552",
    "snippet": "void\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate, struct nfsd4_lock *lock)\n{\n\tput_stateid(cstate, &lock->lk_resp_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&lock->lk_resp_stateid"
          ],
          "line": 6551
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6512-6519",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate, struct nfsd4_lock *lock)\n{\n\tput_stateid(cstate, &lock->lk_resp_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_closestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6542-6546",
    "snippet": "void\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tput_stateid(cstate, &close->cl_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&close->cl_stateid"
          ],
          "line": 6545
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6512-6519",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tput_stateid(cstate, &close->cl_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_openstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6536-6540",
    "snippet": "void\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tput_stateid(cstate, &open->op_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&open->op_stateid"
          ],
          "line": 6539
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6512-6519",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tput_stateid(cstate, &open->op_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_opendowngradestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6530-6534",
    "snippet": "void\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tput_stateid(cstate, &odp->od_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&odp->od_stateid"
          ],
          "line": 6533
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6512-6519",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tput_stateid(cstate, &odp->od_stateid);\n}"
  },
  {
    "function_name": "clear_current_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6521-6525",
    "snippet": "void\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLEAR_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}"
  },
  {
    "function_name": "put_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6512-6519",
    "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cstate->current_stateid",
            "stateid",
            "sizeof(stateid_t)"
          ],
          "line": 6516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
  },
  {
    "function_name": "get_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6505-6510",
    "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stateid",
            "&cstate->current_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 6509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURRENT_STATEID",
          "args": [
            "stateid"
          ],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
  },
  {
    "function_name": "nfs4_state_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6498-6503",
    "snippet": "void\nnfs4_state_shutdown(void)\n{\n\tdestroy_workqueue(laundry_wq);\n\tnfsd4_destroy_callback_queue();\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_destroy_callback_queue",
          "args": [],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_destroy_callback_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "983-986",
          "snippet": "void nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "laundry_wq"
          ],
          "line": 6501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nvoid\nnfs4_state_shutdown(void)\n{\n\tdestroy_workqueue(laundry_wq);\n\tnfsd4_destroy_callback_queue();\n}"
  },
  {
    "function_name": "nfs4_state_shutdown_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6469-6496",
    "snippet": "void\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_destroy_net",
          "args": [
            "net"
          ],
          "line": 6495
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_destroy_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6394-6419",
          "snippet": "static void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_exit",
          "args": [
            "net"
          ],
          "line": 6494
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1450-1460",
          "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 6491
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 6490
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "663-676",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&reaplist"
          ],
          "line": 6487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6486
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 6484
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 6483
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 6482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->del_recall_lru"
          ],
          "line": 6481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6480
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 6479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_end_grace",
          "args": [
            "&nn->nfsd4_manager"
          ],
          "line": 6477
        },
        "resolved": true,
        "details": {
          "function_name": "locks_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "49-55",
          "snippet": "void\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(grace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(grace_lock);\n\nvoid\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&nn->laundromat_work"
          ],
          "line": 6476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n}"
  },
  {
    "function_name": "nfs4_state_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6442-6467",
    "snippet": "int\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tret = set_callback_cred();\n\tif (ret)\n\t\treturn -ENOMEM;\n\tlaundry_wq = create_singlethread_workqueue(\"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_recovery;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout_recovery:\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "laundry_wq"
          ],
          "line": 6464
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_max_delegations",
          "args": [],
          "line": 6459
        },
        "resolved": true,
        "details": {
          "function_name": "set_max_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6338-6348",
          "snippet": "static void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long max_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nunsigned long max_delegations;\n\nstatic void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_create_callback_queue",
          "args": [],
          "line": 6455
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_create_callback_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "975-981",
          "snippet": "int nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nint nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"nfsd4\""
          ],
          "line": 6450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_callback_cred",
          "args": [],
          "line": 6447
        },
        "resolved": true,
        "details": {
          "function_name": "set_callback_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "708-716",
          "snippet": "int set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_cred *callback_cred;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_cred *callback_cred;\n\nint set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nint\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tret = set_callback_cred();\n\tif (ret)\n\t\treturn -ENOMEM;\n\tlaundry_wq = create_singlethread_workqueue(\"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_recovery;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout_recovery:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_state_start_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6421-6438",
    "snippet": "int\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = nfs4_state_create_net(net);\n\tif (ret)\n\t\treturn ret;\n\tnn->boot_time = get_seconds();\n\tnn->grace_ended = false;\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\",\n\t       nn->nfsd4_grace, net);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "laundry_wq",
            "&nn->laundromat_work",
            "nn->nfsd4_grace * HZ"
          ],
          "line": 6436
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\"",
            "nn->nfsd4_grace",
            "net"
          ],
          "line": 6434
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_init",
          "args": [
            "net"
          ],
          "line": 6433
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1402-1448",
          "snippet": "int\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};",
            "static struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};",
            "static struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};\nstatic struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};\nstatic struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};\n\nint\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_start_grace",
          "args": [
            "net",
            "&nn->nfsd4_manager"
          ],
          "line": 6432
        },
        "resolved": true,
        "details": {
          "function_name": "locks_start_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "27-35",
          "snippet": "void\nlocks_start_grace(struct net *net, struct lock_manager *lm)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\tspin_lock(&grace_lock);\n\tlist_add(&lm->list, grace_list);\n\tspin_unlock(&grace_lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;",
            "static DEFINE_SPINLOCK(grace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\nstatic DEFINE_SPINLOCK(grace_lock);\n\nvoid\nlocks_start_grace(struct net *net, struct lock_manager *lm)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\tspin_lock(&grace_lock);\n\tlist_add(&lm->list, grace_list);\n\tspin_unlock(&grace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 6430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_create_net",
          "args": [
            "net"
          ],
          "line": 6427
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_create_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6350-6392",
          "snippet": "static int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nint\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = nfs4_state_create_net(net);\n\tif (ret)\n\t\treturn ret;\n\tnn->boot_time = get_seconds();\n\tnn->grace_ended = false;\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\",\n\t       nn->nfsd4_grace, net);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_state_destroy_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6394-6419",
    "snippet": "static void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 6418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->conf_id_hashtbl"
          ],
          "line": 6417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->unconf_id_hashtbl"
          ],
          "line": 6416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->sessionid_hashtbl"
          ],
          "line": 6415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_client",
          "args": [
            "clp"
          ],
          "line": 6411
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1657-1662",
          "snippet": "static void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->unconf_id_hashtbl[i].next",
            "structnfs4_client",
            "cl_idhash"
          ],
          "line": 6410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->unconf_id_hashtbl[i]"
          ],
          "line": 6409
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->conf_id_hashtbl[i].next",
            "structnfs4_client",
            "cl_idhash"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}"
  },
  {
    "function_name": "nfs4_state_create_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6350-6392",
    "snippet": "static int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->conf_id_hashtbl"
          ],
          "line": 6389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->unconf_id_hashtbl"
          ],
          "line": 6387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 6382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&nn->laundromat_work",
            "laundromat_main"
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->del_recall_lru"
          ],
          "line": 6378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->close_lru"
          ],
          "line": 6377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->client_lru"
          ],
          "line": 6376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->sessionid_hashtbl[i]"
          ],
          "line": 6373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->unconf_id_hashtbl[i]"
          ],
          "line": 6370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->conf_id_hashtbl[i]"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 6363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "set_max_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6338-6348",
    "snippet": "static void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long max_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 6347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nunsigned long max_delegations;\n\nstatic void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}"
  },
  {
    "function_name": "nfsd_inject_recall_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6305-6326",
    "snippet": "u64\nnfsd_inject_recall_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && ++count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_recall_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6324
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_recall_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6259-6280",
          "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6323
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "max - count",
            "&reaplist"
          ],
          "line": 6319
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6130-6169",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6317
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_recall_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && ++count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_recall_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6282-6303",
    "snippet": "u64\nnfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_recall_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6301
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_recall_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6259-6280",
          "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6299
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "&reaplist"
          ],
          "line": 6298
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6130-6169",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6296
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5746-5761",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6295
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_recall_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6259-6280",
    "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6278
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5740-5744",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_break_one_deleg",
          "args": [
            "dp"
          ],
          "line": 6277
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_break_one_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3421-3432",
          "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6276
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6274
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "reaplist",
            "dl_recall_lru"
          ],
          "line": 6265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_forget_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6236-6257",
    "snippet": "u64\nnfsd_inject_forget_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_forget_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6255
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_forget_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6199-6211",
          "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6254
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "max - count",
            "&reaplist"
          ],
          "line": 6250
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6130-6169",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6213-6234",
    "snippet": "u64\nnfsd_inject_forget_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_forget_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_forget_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6199-6211",
          "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "&reaplist"
          ],
          "line": 6229
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6130-6169",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6227
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5746-5761",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6226
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_forget_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6199-6211",
    "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6209
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5740-5744",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_delegation",
          "args": [
            "dp"
          ],
          "line": 6208
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "721-737",
          "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "reaplist",
            "dl_recall_lru"
          ],
          "line": 6205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6180-6197",
    "snippet": "u64\nnfsd_inject_print_delegations(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_delegations(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_delegations",
          "args": [
            "clp"
          ],
          "line": 6193
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6171-6178",
          "snippet": "static u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6191
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_delegations(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_delegations(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_print_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6171-6178",
    "snippet": "static u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"delegations\""
          ],
          "line": 6176
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5841-5847",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "NULL"
          ],
          "line": 6174
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6130-6169",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_find_all_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6130-6169",
    "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6167
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "victims"
          ],
          "line": 6154
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 6153
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "&clp->cl_delegations",
            "dl_perclnt"
          ],
          "line": 6141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tunhash_delegation_locked(dp);\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6106-6128",
    "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_openowners",
          "args": [
            "&reaplist"
          ],
          "line": 6126
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6070-6082",
          "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_openowners",
          "args": [
            "clp",
            "&reaplist",
            "max - count"
          ],
          "line": 6120
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6043-6049",
          "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6118
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6084-6104",
    "snippet": "u64\nnfsd_inject_forget_client_openowners(struct sockaddr_storage *addr,\n\t\t\t\t     size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_openowners(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_openowners",
          "args": [
            "&reaplist"
          ],
          "line": 6102
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6070-6082",
          "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_openowners",
          "args": [
            "clp",
            "&reaplist",
            "0"
          ],
          "line": 6100
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6043-6049",
          "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6098
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5746-5761",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6097
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_openowners(struct sockaddr_storage *addr,\n\t\t\t\t     size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_openowners(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_reap_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6070-6082",
    "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6080
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5740-5744",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oop"
          ],
          "line": 6079
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1112-1132",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oop->oo_perclient"
          ],
          "line": 6077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oop",
            "next",
            "reaplist",
            "oo_perclient"
          ],
          "line": 6076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6051-6068",
    "snippet": "u64\nnfsd_inject_print_openowners(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_openowners(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6065
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_openowners",
          "args": [
            "clp"
          ],
          "line": 6064
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6034-6041",
          "snippet": "static u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_openowners(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_openowners(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_collect_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6043-6049",
    "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_foreach_client_openowner",
          "args": [
            "clp",
            "max",
            "collect",
            "unhash_openowner_locked"
          ],
          "line": 6047
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5997-6032",
          "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
  },
  {
    "function_name": "nfsd_print_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "6034-6041",
    "snippet": "static u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"openowners\""
          ],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5841-5847",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_foreach_client_openowner",
          "args": [
            "clp",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 6037
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5997-6032",
          "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_foreach_client_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5997-6032",
    "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6029
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&oop->oo_perclient",
            "collect"
          ],
          "line": 6015
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "oop"
          ],
          "line": 6012
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cleaner_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "288-292",
          "snippet": "static void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tcache_cleaner_func(struct work_struct *unused);",
            "static DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\tcache_cleaner_func(struct work_struct *unused);\nstatic DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);\n\nstatic void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oop",
            "next",
            "&clp->cl_openowners",
            "oo_perclient"
          ],
          "line": 6010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6009
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5974-5995",
    "snippet": "u64\nnfsd_inject_forget_locks(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_locks(clp, &reaplist, max - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_locks",
          "args": [
            "&reaplist"
          ],
          "line": 5993
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5939-5951",
          "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5992
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_locks",
          "args": [
            "clp",
            "&reaplist",
            "max - count"
          ],
          "line": 5988
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5905-5910",
          "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5986
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_locks(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_locks(clp, &reaplist, max - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5953-5972",
    "snippet": "u64\nnfsd_inject_forget_client_locks(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_locks(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_locks",
          "args": [
            "&reaplist"
          ],
          "line": 5970
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5939-5951",
          "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_locks",
          "args": [
            "clp",
            "&reaplist",
            "0"
          ],
          "line": 5968
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5905-5910",
          "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 5966
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5746-5761",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5965
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 5960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_locks(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_locks(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_reap_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5939-5951",
    "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 5949
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5740-5744",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&stp->st_locks"
          ],
          "line": 5946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stp",
            "next",
            "reaplist",
            "st_locks"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5920-5937",
    "snippet": "u64\nnfsd_inject_print_locks(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_locks(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5934
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_locks",
          "args": [
            "clp"
          ],
          "line": 5933
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5912-5918",
          "snippet": "static u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 5932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5931
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_locks(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_locks(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_print_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5912-5918",
    "snippet": "static u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"locked files\""
          ],
          "line": 5916
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5841-5847",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_foreach_client_lock",
          "args": [
            "clp",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 5915
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5865-5903",
          "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_collect_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5905-5910",
    "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_foreach_client_lock",
          "args": [
            "clp",
            "max",
            "collect",
            "unhash_lock_stateid"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5865-5903",
          "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
  },
  {
    "function_name": "nfsd_foreach_client_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5865-5903",
    "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5900
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 5893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_inject_add_lock_to_list",
          "args": [
            "lst",
            "collect"
          ],
          "line": 5882
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_add_lock_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5849-5863",
          "snippet": "static void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "lst"
          ],
          "line": 5881
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cleaner_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "288-292",
          "snippet": "static void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tcache_cleaner_func(struct work_struct *unused);",
            "static DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\tcache_cleaner_func(struct work_struct *unused);\nstatic DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);\n\nstatic void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lst",
            "lst_next",
            "&stp->st_locks",
            "st_locks"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stp",
            "st_next",
            "&oop->oo_owner.so_stateids",
            "st_perstateowner"
          ],
          "line": 5876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "oop",
            "&clp->cl_openowners",
            "oo_perclient"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5874
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    void (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc(lst);\n\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_add_lock_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5849-5863",
    "snippet": "static void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lst->st_locks",
            "collect"
          ],
          "line": 5862
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}"
  },
  {
    "function_name": "nfsd_print_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5841-5847",
    "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFS Client: %s has %u %s\\n\"",
            "buf",
            "count",
            "type"
          ],
          "line": 5846
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "buf",
            "sizeof(buf)"
          ],
          "line": 5845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
  },
  {
    "function_name": "nfsd_inject_forget_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5813-5839",
    "snippet": "u64\nnfsd_inject_forget_clients(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok) {\n\t\t\tlist_add(&clp->cl_lru, &reaplist);\n\t\t\tif (max != 0 && ++count >= max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tlist_for_each_entry_safe(clp, next, &reaplist, cl_lru)\n\t\texpire_client(clp);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 5836
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&reaplist",
            "cl_lru"
          ],
          "line": 5835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5833
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&clp->cl_lru",
            "&reaplist"
          ],
          "line": 5828
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5825
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_clients(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok) {\n\t\t\tlist_add(&clp->cl_lru, &reaplist);\n\t\t\tif (max != 0 && ++count >= max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tlist_for_each_entry_safe(clp, next, &reaplist, cl_lru)\n\t\texpire_client(clp);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5786-5811",
    "snippet": "u64\nnfsd_inject_forget_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok)\n\t\t\t++count;\n\t\telse\n\t\t\tclp = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tif (clp)\n\t\texpire_client(clp);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 5808
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5805
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 5800
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 5798
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5746-5761",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5797
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok)\n\t\t\t++count;\n\t\telse\n\t\t\tclp = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tif (clp)\n\t\texpire_client(clp);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_print_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5763-5784",
    "snippet": "u64\nnfsd_inject_print_clients(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\tchar buf[INET6_ADDRSTRLEN];\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\t\tpr_info(\"NFS Client: %s\\n\", buf);\n\t\t++count;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5781
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NFS Client: %s\\n\"",
            "buf"
          ],
          "line": 5778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "buf",
            "sizeof(buf)"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 5776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 5775
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_clients(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\tchar buf[INET6_ADDRSTRLEN];\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\t\tpr_info(\"NFS Client: %s\\n\", buf);\n\t\t++count;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_find_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5746-5761",
    "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&clp->cl_addr",
            "addr",
            "addr_size"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 5756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 5753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 5750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5740-5744",
    "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 5743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
  },
  {
    "function_name": "nfs4_check_open_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5718-5737",
    "snippet": "__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_record_check",
          "args": [
            "cstate->clp"
          ],
          "line": 5733
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1480-1489",
          "snippet": "int\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_RECLAIM_COMPLETE",
            "&cstate->clp->cl_flags"
          ],
          "line": 5730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_find_reclaim_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5698-5713",
    "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_name",
          "args": [
            "crp->cr_recdir",
            "recdir"
          ],
          "line": 5708
        },
        "resolved": true,
        "details": {
          "function_name": "same_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1713-1716",
          "snippet": "static int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "crp",
            "&nn->reclaim_str_hashtbl[strhashval]",
            "cr_strhash"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientstr_hashval",
          "args": [
            "recdir"
          ],
          "line": 5706
        },
        "resolved": true,
        "details": {
          "function_name": "clientstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "748-751",
          "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\"",
            "recdir"
          ],
          "line": 5704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_release_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5680-5694",
    "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nn->reclaim_str_hashtbl_size"
          ],
          "line": 5693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_remove_reclaim_record",
          "args": [
            "crp",
            "nn"
          ],
          "line": 5690
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_reclaim_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5672-5678",
          "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->reclaim_str_hashtbl[i].next",
            "structnfs4_client_reclaim",
            "cr_strhash"
          ],
          "line": 5688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->reclaim_str_hashtbl[i]"
          ],
          "line": 5687
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
  },
  {
    "function_name": "nfs4_remove_reclaim_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5672-5678",
    "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crp"
          ],
          "line": 5676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&crp->cr_strhash"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
  },
  {
    "function_name": "nfs4_client_to_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5653-5670",
    "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crp->cr_recdir",
            "name",
            "HEXDIR_LEN"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&crp->cr_strhash",
            "&nn->reclaim_str_hashtbl[strhashval]"
          ],
          "line": 5664
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&crp->cr_strhash"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientstr_hashval",
          "args": [
            "name"
          ],
          "line": 5662
        },
        "resolved": true,
        "details": {
          "function_name": "clientstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "748-751",
          "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_reclaim",
          "args": [],
          "line": 5660
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5635-5639",
          "snippet": "static inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\"",
            "HEXDIR_LEN",
            "name"
          ],
          "line": 5659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
  },
  {
    "function_name": "nfs4_has_reclaimed_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5641-5648",
    "snippet": "bool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "name",
            "nn"
          ],
          "line": 5646
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5698-5713",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nbool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}"
  },
  {
    "function_name": "alloc_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5635-5639",
    "snippet": "static inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfs4_client_reclaim)",
            "GFP_KERNEL"
          ],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}"
  },
  {
    "function_name": "nfsd4_release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5585-5633",
    "snippet": "__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tstruct nfsd4_release_lockowner *rlockowner)\n{\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (lo)\n\t\trelease_lockowner(lo);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_lockowner",
          "args": [
            "lo"
          ],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "release_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1031-1050",
          "snippet": "static void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5629
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "sop"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_locks",
          "args": [
            "stp->st_stid.sc_file",
            "lo"
          ],
          "line": 5619
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5553-5583",
          "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stp",
            "&sop->so_stateids",
            "st_perstateowner"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5617
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "sop",
            "owner"
          ],
          "line": 5613
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "219-224",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sop",
            "&clp->cl_ownerstr_hashtbl[hashval]",
            "so_strhash"
          ],
          "line": 5610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5609
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 5603
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\"",
            "clid->cl_boot",
            "clid->cl_id"
          ],
          "line": 5600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "owner"
          ],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "374-380",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tstruct nfsd4_release_lockowner *rlockowner)\n{\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (lo)\n\t\trelease_lockowner(lo);\n\treturn status;\n}"
  },
  {
    "function_name": "check_for_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5553-5583",
    "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5581
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 5579
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&flctx->flc_posix",
            "fl_list"
          ],
          "line": 5573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 5572
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_posix"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 5568
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "fp"
          ],
          "line": 5558
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "346-360",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5479-5546",
    "snippet": "__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_locku *locku)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tfilp = find_any_file(stp->st_stid.sc_file);\n\tif (!filp) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto fput;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&locku->lu_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\nfput:\n\tfput(filp);\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto fput;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 5540
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&locku->lu_stateid",
            "&stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 5531
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\""
          ],
          "line": 5528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "file_lock",
            "NULL"
          ],
          "line": 5526
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5524
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4926-4933",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "locku->lu_offset",
            "locku->lu_length"
          ],
          "line": 5522
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4908-4916",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(stp->st_stateowner)"
          ],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5507
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 5502
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "346-360",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "locku->lu_seqid",
            "&locku->lu_stateid",
            "NFS4_LOCK_STID",
            "&stp",
            "nn"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4651-4677",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "locku->lu_offset",
            "locku->lu_length"
          ],
          "line": 5494
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5143-5148",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\"",
            "(long long) locku->lu_offset",
            "(long long) locku->lu_length"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\n__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_locku *locku)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tfilp = find_any_file(stp->st_stid.sc_file);\n\tif (!filp) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto fput;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&locku->lu_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\nfput:\n\tfput(filp);\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto fput;\n}"
  },
  {
    "function_name": "nfsd4_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5405-5477",
    "snippet": "__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_lockt *lockt)\n{\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = lookup_clientid(&lockt->lt_clientid, cstate, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(&lockt->lt_clientid, &lockt->lt_owner,\n\t\t\t\tcstate->clp);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5473
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_set_lock_denied",
          "args": [
            "file_lock",
            "&lockt->lt_denied"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4956-4984",
          "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_test_lock",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "file_lock"
          ],
          "line": 5463
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5391-5400",
          "snippet": "static __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tnfsd_close(file);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tnfsd_close(file);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5461
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4926-4933",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "lockt->lt_offset",
            "lockt->lt_length"
          ],
          "line": 5459
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4908-4916",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str",
          "args": [
            "&lockt->lt_clientid",
            "&lockt->lt_owner",
            "cstate->clp"
          ],
          "line": 5451
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5005-5015",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_lockt: bad lock type!\\n\""
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5429
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "&lockt->lt_clientid",
            "cstate",
            "nn"
          ],
          "line": 5421
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 5420
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "lockt->lt_offset",
            "lockt->lt_length"
          ],
          "line": 5417
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5143-5148",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 5414
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_lockt *lockt)\n{\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = lookup_clientid(&lockt->lt_clientid, cstate, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(&lockt->lt_clientid, &lockt->lt_owner,\n\t\t\t\tcstate->clp);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5391-5400",
    "snippet": "static __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tnfsd_close(file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_close",
          "args": [
            "file"
          ],
          "line": 5397
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "767-771",
          "snippet": "void\nnfsd_close(struct file *filp)\n{\n\tfput(filp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid\nnfsd_close(struct file *filp)\n{\n\tfput(filp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "vfs_test_lock(file, lock)"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "file",
            "lock"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1953-1959",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "fhp",
            "S_IFREG",
            "NFSD_MAY_READ",
            "&file"
          ],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "677-762",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tnfsd_close(file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5204-5383",
    "snippet": "__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t/* See rfc 5661 18.10.3: given clientid is ignored: */\n\t\t\tmemcpy(&lock->v.new.clientid,\n\t\t\t\t&cstate->session->se_client->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\tstatus = nfserr_stale_clientid;\n\t\tif (STALE_CLIENTID(&lock->lk_new_clientid, nn))\n\t\t\tgoto out;\n\n\t\t/* validate and update open stateid and open seqid */\n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->v.new.clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_readable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_writeable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\tif (!filp) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, conflock);\n\tswitch (-err) {\n\tcase 0: /* success! */\n\t\tupdate_stateid(&lock_stp->st_stid.sc_stateid);\n\t\tmemcpy(&lock->lk_resp_stateid, &lock_stp->st_stid.sc_stateid, \n\t\t\t\tsizeof(stateid_t));\n\t\tstatus = 0;\n\t\tbreak;\n\tcase (EAGAIN):\t\t/* conflock holds conflicting lock */\n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase (EDEADLK):\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (filp)\n\t\tfput(filp);\n\tif (lock_stp) {\n\t\t/* Bump seqid manually if the 4.0 replay owner is openowner */\n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\t/*\n\t\t * If this is a new, never-before-used stateid, and we are\n\t\t * returning an error, then just go ahead and release it.\n\t\t */\n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "conflock"
          ],
          "line": 5381
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5377
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&open_stp->st_stid"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_lock_stateid",
          "args": [
            "lock_stp"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "release_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "989-997",
          "snippet": "static void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tnfs4_put_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tnfs4_put_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seqid_mutating_err",
          "args": [
            "ntohl(status)"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5358
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\"",
            "err"
          ],
          "line": 5352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_lock_denied",
          "args": [
            "conflock",
            "&lock->lk_denied"
          ],
          "line": 5346
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4956-4984",
          "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: conflicting lock found!\\n\""
          ],
          "line": 5345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lock->lk_resp_stateid",
            "&lock_stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&lock_stp->st_stid.sc_stateid"
          ],
          "line": 5338
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "file_lock",
            "conflock"
          ],
          "line": 5335
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5328
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4926-4933",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "lock->lk_offset",
            "lock->lk_length"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4908-4916",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(&lock_sop->lo_owner)"
          ],
          "line": 5319
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lock_sop->lo_owner"
          ],
          "line": 5319
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_access",
          "args": [
            "lock_stp",
            "NFS4_SHARE_ACCESS_WRITE"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5150-5160",
          "snippet": "static void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writeable_file_locked",
          "args": [
            "fp"
          ],
          "line": 5304
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "297-308",
          "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5303
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_readable_file_locked",
          "args": [
            "fp"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "322-332",
          "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 5280
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_openmode",
          "args": [
            "lock_stp",
            "lkflg"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_openmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4311-4326",
          "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlkflg",
          "args": [
            "lock->lk_type"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "setlkflg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4618-4623",
          "snippet": "static inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "lock->lk_old_lock_seqid",
            "&lock->lk_old_lock_stateid",
            "NFS4_LOCK_STID",
            "&lock_stp",
            "nn"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4651-4677",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_or_create_lock_state",
          "args": [
            "cstate",
            "open_stp",
            "lock",
            "&lock_stp",
            "&new"
          ],
          "line": 5259
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_or_create_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5162-5199",
          "snippet": "static __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = cstate->current_fh.fh_dentry->d_inode;\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(&cl->cl_clientid, &lock->v.new.owner, cl);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->v.new.owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = cstate->current_fh.fh_dentry->d_inode;\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(&cl->cl_clientid, &lock->v.new.owner, cl);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->v.new.owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&open_sop->oo_owner.so_client->cl_clientid",
            "&lock->v.new.clientid"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1724-1728",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "open_stp->st_stateowner"
          ],
          "line": 5254
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_confirmed_seqid_op",
          "args": [
            "cstate",
            "lock->lk_new_open_seqid",
            "&lock->lk_new_open_stateid",
            "&open_stp",
            "nn"
          ],
          "line": 5248
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_confirmed_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4679-4697",
          "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "&lock->lk_new_clientid",
            "nn"
          ],
          "line": 5244
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1495-1508",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lock->v.new.clientid",
            "&cstate->session->se_client->cl_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 5239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: permission denied!\\n\""
          ],
          "line": 5232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "NFSD_MAY_LOCK"
          ],
          "line": 5230
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "lock->lk_offset",
            "lock->lk_length"
          ],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5143-5148",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\"",
            "(long long) lock->lk_offset",
            "(long long) lock->lk_length"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 5221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\n__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t/* See rfc 5661 18.10.3: given clientid is ignored: */\n\t\t\tmemcpy(&lock->v.new.clientid,\n\t\t\t\t&cstate->session->se_client->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\tstatus = nfserr_stale_clientid;\n\t\tif (STALE_CLIENTID(&lock->lk_new_clientid, nn))\n\t\t\tgoto out;\n\n\t\t/* validate and update open stateid and open seqid */\n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->v.new.clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_readable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_writeable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\tif (!filp) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, conflock);\n\tswitch (-err) {\n\tcase 0: /* success! */\n\t\tupdate_stateid(&lock_stp->st_stid.sc_stateid);\n\t\tmemcpy(&lock->lk_resp_stateid, &lock_stp->st_stid.sc_stateid, \n\t\t\t\tsizeof(stateid_t));\n\t\tstatus = 0;\n\t\tbreak;\n\tcase (EAGAIN):\t\t/* conflock holds conflicting lock */\n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase (EDEADLK):\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (filp)\n\t\tfput(filp);\n\tif (lock_stp) {\n\t\t/* Bump seqid manually if the 4.0 replay owner is openowner */\n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\t/*\n\t\t * If this is a new, never-before-used stateid, and we are\n\t\t * returning an error, then just go ahead and release it.\n\t\t */\n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}"
  },
  {
    "function_name": "lookup_or_create_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5162-5199",
    "snippet": "static __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = cstate->current_fh.fh_dentry->d_inode;\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(&cl->cl_clientid, &lock->v.new.owner, cl);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->v.new.owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_create_lock_stateid",
          "args": [
            "lo",
            "fi",
            "inode",
            "ost",
            "new"
          ],
          "line": 5190
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_create_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5110-5141",
          "snippet": "static struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_init_lock_stateowner",
          "args": [
            "strhashval",
            "cl",
            "ost",
            "lock"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_lock_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5041-5066",
          "snippet": "static struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(&clp->cl_clientid,\n\t\t\t&lock->lk_new_owner, clp);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_lockowner(&lo->lo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;",
            "static const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(&clp->cl_clientid,\n\t\t\t&lock->lk_new_owner, clp);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_lockowner(&lo->lo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "&lock->v.new.owner"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "374-380",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str",
          "args": [
            "&cl->cl_clientid",
            "&lock->v.new.owner",
            "cl"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5005-5015",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ost->st_stateowner"
          ],
          "line": 5170
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = cstate->current_fh.fh_dentry->d_inode;\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(&cl->cl_clientid, &lock->v.new.owner, cl);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->v.new.owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}"
  },
  {
    "function_name": "get_lock_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5150-5160",
    "snippet": "static void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_access",
          "args": [
            "access",
            "lock_stp"
          ],
          "line": 5159
        },
        "resolved": true,
        "details": {
          "function_name": "set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "784-791",
          "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs4_file_get_access",
          "args": [
            "fp",
            "access"
          ],
          "line": 5158
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "398-407",
          "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "access",
            "lock_stp"
          ],
          "line": 5156
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}"
  },
  {
    "function_name": "check_lock_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5143-5148",
    "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOFF_OVERFLOW",
          "args": [
            "offset",
            "length"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0)  || ((length != NFS4_MAX_UINT64) &&\n\t     LOFF_OVERFLOW(offset, length)));\n}"
  },
  {
    "function_name": "find_or_create_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5110-5141",
    "snippet": "static struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "ns"
          ],
          "line": 5139
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5137
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_lock_stateid",
          "args": [
            "lst",
            "lo",
            "fi",
            "inode",
            "ost"
          ],
          "line": 5132
        },
        "resolved": true,
        "details": {
          "function_name": "init_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5068-5091",
          "snippet": "static void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "ns"
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!lst"
          ],
          "line": 5130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_stateid",
          "args": [
            "lo",
            "fi"
          ],
          "line": 5129
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5093-5108",
          "snippet": "static struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "stateid_slab"
          ],
          "line": 5124
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "474-510",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ost->st_stateowner"
          ],
          "line": 5117
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}"
  },
  {
    "function_name": "find_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5093-5108",
    "snippet": "static struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lst->st_stid.sc_count"
          ],
          "line": 5103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lst",
            "&lo->lo_owner.so_stateids",
            "st_perstateowner"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5068-5091",
    "snippet": "static void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5090
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perfile",
            "&fp->fi_stateids"
          ],
          "line": 5089
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5088
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 5080
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "605-608",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5079
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&stp->st_stid.sc_count"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}"
  },
  {
    "function_name": "alloc_init_lock_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5041-5066",
    "snippet": "static struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(&clp->cl_clientid,\n\t\t\t&lock->lk_new_owner, clp);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_lockowner(&lo->lo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *lockowner_slab;",
      "static const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5064
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_free_lockowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5063
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lo->lo_owner.so_strhash",
            "&clp->cl_ownerstr_hashtbl[strhashval]"
          ],
          "line": 5059
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str_locked",
          "args": [
            "&clp->cl_clientid",
            "&lock->lk_new_owner",
            "clp"
          ],
          "line": 5056
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4986-5003",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5055
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lo->lo_owner.so_stateids"
          ],
          "line": 5051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_stateowner",
          "args": [
            "lockowner_slab",
            "&lock->lk_new_owner",
            "clp"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3149-3169",
          "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(&clp->cl_clientid,\n\t\t\t&lock->lk_new_owner, clp);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_lockowner(&lo->lo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
  },
  {
    "function_name": "nfs4_free_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5022-5027",
    "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *lockowner_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "lockowner_slab",
            "lo"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
  },
  {
    "function_name": "nfs4_unhash_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5017-5020",
    "snippet": "static void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_lockowner_locked",
          "args": [
            "lockowner(sop)"
          ],
          "line": 5019
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lockowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "999-1006",
          "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5019
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}"
  },
  {
    "function_name": "find_lockowner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "5005-5015",
    "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5013
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str_locked",
          "args": [
            "clid",
            "owner",
            "clp"
          ],
          "line": 5012
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4986-5003",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clid, owner, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
  },
  {
    "function_name": "find_lockowner_str_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4986-5003",
    "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(so)"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "so",
            "owner"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "219-224",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "so",
            "&clp->cl_ownerstr_hashtbl[strhashval]",
            "so_strhash"
          ],
          "line": 4995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "owner"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "374-380",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(clientid_t *clid, struct xdr_netobj *owner,\n\t\tstruct nfs4_client *clp)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_set_lock_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4956-4984",
    "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "lo->lo_owner.so_owner.data",
            "lo->lo_owner.so_owner.len",
            "GFP_KERNEL"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
  },
  {
    "function_name": "nfsd4_fl_put_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4941-4949",
    "snippet": "static void nfsd4_fl_put_owner(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)fl->fl_owner;\n\n\tif (lo) {\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\t\tfl->fl_owner = NULL;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_fl_put_owner(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)fl->fl_owner;\n\n\tif (lo) {\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\t\tfl->fl_owner = NULL;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_fl_get_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4935-4939",
    "snippet": "static void nfsd4_fl_get_owner(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)src->fl_owner;\n\tdst->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lo->lo_owner));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(&lo->lo_owner)"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_fl_get_owner(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)src->fl_owner;\n\tdst->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lo->lo_owner));\n}"
  },
  {
    "function_name": "nfs4_transform_lock_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4926-4933",
    "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
  },
  {
    "function_name": "last_byte_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4908-4916",
    "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!len"
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "end_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4898-4905",
    "snippet": "static inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end: NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end: NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "nfsd4_delegreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4867-4893",
    "snippet": "__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_delegreturn *dr)\n{\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = check_stateid_generation(stateid, &dp->dl_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_delegation",
          "args": [
            "dp"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "712-719",
          "snippet": "static void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tspin_lock(&state_lock);\n\tunhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\tnfs4_put_stid(&dp->dl_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tspin_lock(&state_lock);\n\tunhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\tnfs4_put_stid(&dp->dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&dp->dl_stid.sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 4884
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4361-4387",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 4884
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 4883
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "151-154",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "NFS4_DELEG_STID",
            "&s",
            "nn"
          ],
          "line": 4880
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4442-4463",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 4877
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_delegreturn *dr)\n{\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = check_stateid_generation(stateid, &dp->dl_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4834-4865",
    "snippet": "__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&close->cl_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tnfsd4_return_all_file_layouts(stp->st_stateowner->so_client,\n\t\t\t\t      stp->st_stid.sc_file);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4862
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_close_open_stateid",
          "args": [
            "stp"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_close_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4811-4829",
          "snippet": "static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tmove_to_close_lru(s, clp->net);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tmove_to_close_lru(s, clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_file_layouts",
          "args": [
            "stp->st_stateowner->so_client",
            "stp->st_stid.sc_file"
          ],
          "line": 4856
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_file_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "558-572",
          "snippet": "void\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&close->cl_stateid",
            "&stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "close->cl_seqid",
            "&close->cl_stateid",
            "NFS4_OPEN_STID|NFS4_CLOSED_STID",
            "&stp",
            "nn"
          ],
          "line": 4846
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4651-4677",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_close on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&close->cl_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tnfsd4_return_all_file_layouts(stp->st_stateowner->so_client,\n\t\t\t\t      stp->st_stid.sc_file);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_close_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4811-4829",
    "snippet": "static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tmove_to_close_lru(s, clp->net);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_to_close_lru",
          "args": [
            "s",
            "clp->net"
          ],
          "line": 4827
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_close_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3252-3287",
          "snippet": "static void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 4826
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1012-1029",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 4825
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "s",
            "&reaplist"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "959-976",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "s",
            "&reaplist"
          ],
          "line": 4818
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1065-1072",
          "snippet": "static void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 4817
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tmove_to_close_lru(s, clp->net);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4765-4809",
    "snippet": "__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_open_downgrade *od)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t/* We don't yet support WANT bits: */\n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&od->od_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 4807
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&od->od_stateid",
            "&stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "od->od_share_deny",
            "stp"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "871-887",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_downgrade",
          "args": [
            "stp",
            "od->od_share_access"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_downgrade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4747-4763",
          "snippet": "static inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\"",
            "stp->st_deny_bmap",
            "od->od_share_deny"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_deny",
          "args": [
            "od->od_share_deny",
            "stp"
          ],
          "line": 4792
        },
        "resolved": true,
        "details": {
          "function_name": "test_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "833-839",
          "snippet": "static inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\"",
            "stp->st_access_bmap",
            "od->od_share_access"
          ],
          "line": 4788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "od->od_share_access",
            "stp"
          ],
          "line": 4787
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_confirmed_seqid_op",
          "args": [
            "cstate",
            "od->od_seqid",
            "&od->od_stateid",
            "&stp",
            "nn"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_confirmed_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4679-4697",
          "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: od_deleg_want=0x%x ignored\\n\"",
            "__func__",
            "od->od_deleg_want"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_open_downgrade on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_open_downgrade *od)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t/* We don't yet support WANT bits: */\n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&od->od_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_stateid_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4747-4763",
    "snippet": "static inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_downgrade_bit",
          "args": [
            "stp",
            "NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_downgrade_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4739-4745",
          "snippet": "static inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
  },
  {
    "function_name": "nfs4_stateid_downgrade_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4739-4745",
    "snippet": "static inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_access",
          "args": [
            "access",
            "stp"
          ],
          "line": 4744
        },
        "resolved": true,
        "details": {
          "function_name": "clear_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "794-801",
          "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "stp->st_stid.sc_file",
            "access"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "464-472",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "access",
            "stp"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}"
  },
  {
    "function_name": "nfsd4_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4699-4737",
    "snippet": "__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_open_confirm *oc)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED)\n\t\tgoto put_stateid;\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&oc->oc_resp_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\tdprintk(\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\",\n\t\t__func__, oc->oc_seqid, STATEID_VAL(&stp->st_stid.sc_stateid));\n\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 4735
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4733
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_record_create",
          "args": [
            "oo->oo_owner.so_client"
          ],
          "line": 4730
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1462-1469",
          "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\"",
            "__func__",
            "oc->oc_seqid",
            "STATEID_VAL(&stp->st_stid.sc_stateid)"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&oc->oc_resp_stateid",
            "&stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4725
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4720
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "oc->oc_seqid",
            "&oc->oc_req_stateid",
            "NFS4_OPEN_STID",
            "&stp",
            "nn"
          ],
          "line": 4715
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4651-4677",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 4711
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_open_confirm on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 4708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_open_confirm *oc)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED)\n\t\tgoto put_stateid;\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&oc->oc_resp_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\tdprintk(\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\",\n\t\t__func__, oc->oc_seqid, STATEID_VAL(&stp->st_stid.sc_stateid));\n\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_preprocess_confirmed_seqid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4679-4697",
    "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4692
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "seqid",
            "stateid",
            "NFS4_OPEN_STID",
            "&stp",
            "nn"
          ],
          "line": 4686
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4651-4677",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_preprocess_seqid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4651-4677",
    "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_seqid_op_checks",
          "args": [
            "cstate",
            "stateid",
            "seqid",
            "stp"
          ],
          "line": 4671
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_seqid_op_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4625-4646",
          "snippet": "static __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_fh(current_fh, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_fh(current_fh, stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_assign_replay",
          "args": [
            "cstate",
            "stp->st_stateowner"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_assign_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3129-3136",
          "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "typemask",
            "&s",
            "nn"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4442-4463",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\"",
            "__func__",
            "seqid",
            "STATEID_VAL(stateid)"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "stateid"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_seqid_op_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4625-4646",
    "snippet": "static __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_fh(current_fh, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_check_fh",
          "args": [
            "current_fh",
            "stp"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4289-4294",
          "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&stp->st_stid.sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 4642
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4361-4387",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 4642
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_seqid",
          "args": [
            "cstate",
            "sop",
            "seqid"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3487-3496",
          "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_fh(current_fh, stp);\n}"
  },
  {
    "function_name": "setlkflg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4618-4623",
    "snippet": "static inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}"
  },
  {
    "function_name": "nfsd4_free_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4564-4616",
    "snippet": "__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_free_stateid *free_stateid)\n{\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstp = openlockstateid(s);\n\t\tret = nfserr_locks_held;\n\t\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t\t    lockowner(stp->st_stateowner)))\n\t\t\tbreak;\n\t\tunhash_lock_stateid(stp);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t/* Default falls through and returns nfserr_bad_stateid */\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "s"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 4604
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "151-154",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "978-987",
          "snippet": "static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_locks",
          "args": [
            "stp->st_stid.sc_file",
            "lockowner(stp->st_stateowner)"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5553-5583",
          "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4596
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "1"
          ],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4361-4387",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "stateid"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1820-1829",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4575
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_free_stateid *free_stateid)\n{\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstp = openlockstateid(s);\n\t\tret = nfserr_locks_held;\n\t\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t\t    lockowner(stp->st_stateowner)))\n\t\t\tbreak;\n\t\tunhash_lock_stateid(stp);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t/* Default falls through and returns nfserr_bad_stateid */\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4550-4562",
    "snippet": "__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_validate_stateid",
          "args": [
            "cl",
            "&stateid->ts_id_stateid"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_validate_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4389-4440",
          "snippet": "static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *ols;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tols = openlockstateid(s);\n\t\tif (ols->st_stateowner->so_is_open_owner\n\t    \t\t\t&& !(openowner(ols->st_stateowner)->oo_flags\n\t\t\t\t\t\t& NFS4_OO_CONFIRMED))\n\t\t\tstatus = nfserr_bad_stateid;\n\t\telse\n\t\t\tstatus = nfs_ok;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *ols;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tols = openlockstateid(s);\n\t\tif (ols->st_stateowner->so_is_open_owner\n\t    \t\t\t&& !(openowner(ols->st_stateowner)->oo_flags\n\t\t\t\t\t\t& NFS4_OO_CONFIRMED))\n\t\t\tstatus = nfserr_bad_stateid;\n\t\telse\n\t\t\tstatus = nfs_ok;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stateid",
            "&test_stateid->ts_stateid_list",
            "ts_id_list"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_preprocess_stateid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4468-4545",
    "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "s"
          ],
          "line": 4543
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writeable_file",
          "args": [
            "fp"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "310-320",
          "snippet": "static struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_readable_file",
          "args": [
            "fp"
          ],
          "line": 4530
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "334-344",
          "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_openmode",
          "args": [
            "stp",
            "flags"
          ],
          "line": 4523
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_openmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4311-4326",
          "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4521
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_fh",
          "args": [
            "current_fh",
            "stp"
          ],
          "line": 4517
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4289-4294",
          "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_check_delegmode",
          "args": [
            "dp",
            "flags"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_delegmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3587-3594",
          "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "151-154",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4361-4387",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "NFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID",
            "&s",
            "nn"
          ],
          "line": 4490
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4442-4463",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_special_stateids",
          "args": [
            "net",
            "current_fh",
            "stateid",
            "flags"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "check_special_stateids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4328-4343",
          "snippet": "static inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (locks_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (locks_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grace_disallows_io",
          "args": [
            "net",
            "ino"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "grace_disallows_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4349-4353",
          "snippet": "static inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn locks_in_grace(net) && mandatory_lock(inode);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn locks_in_grace(net) && mandatory_lock(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_lookup_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4442-4463",
    "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_stateid_by_type",
          "args": [
            "cstate->clp",
            "stateid",
            "typemask"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1831-1846",
          "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "&stateid->si_opaque.so_clid",
            "cstate",
            "nn"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_validate_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4389-4440",
    "snippet": "static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *ols;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tols = openlockstateid(s);\n\t\tif (ols->st_stateowner->so_is_open_owner\n\t    \t\t\t&& !(openowner(ols->st_stateowner)->oo_flags\n\t\t\t\t\t\t& NFS4_OO_CONFIRMED))\n\t\t\tstatus = nfserr_bad_stateid;\n\t\telse\n\t\t\tstatus = nfs_ok;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"unknown stateid type %x\\n\"",
            "s->sc_type"
          ],
          "line": 4431
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ols->st_stateowner"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "1"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4361-4387",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "stateid"
          ],
          "line": 4407
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1820-1829",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\"",
            "addr_str"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&cl->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&stateid->si_opaque.so_clid",
            "&cl->cl_clientid"
          ],
          "line": 4398
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1724-1728",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *ols;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tols = openlockstateid(s);\n\t\tif (ols->st_stateowner->so_is_open_owner\n\t    \t\t\t&& !(openowner(ols->st_stateowner)->oo_flags\n\t\t\t\t\t\t& NFS4_OO_CONFIRMED))\n\t\t\tstatus = nfserr_bad_stateid;\n\t\telse\n\t\t\tstatus = nfs_ok;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "check_stateid_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4361-4387",
    "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stateid_generation_after",
          "args": [
            "in",
            "ref"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "stateid_generation_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4356-4359",
          "snippet": "static bool stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
  },
  {
    "function_name": "stateid_generation_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4356-4359",
    "snippet": "static bool stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "a->si_generation - b->si_generation"
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}"
  },
  {
    "function_name": "grace_disallows_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4349-4353",
    "snippet": "static inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn locks_in_grace(net) && mandatory_lock(inode);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1199-1224",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn locks_in_grace(net) && mandatory_lock(inode);\n}"
  },
  {
    "function_name": "check_special_stateids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4328-4343",
    "snippet": "static inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (locks_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_share_conflict",
          "args": [
            "current_fh",
            "NFS4_SHARE_DENY_READ"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_share_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3343-3359",
          "snippet": "static __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 4333
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (locks_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}"
  },
  {
    "function_name": "nfs4_check_openmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4311-4326",
    "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access_permit_read",
          "args": [
            "stp"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "access_permit_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4296-4302",
          "snippet": "static inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_permit_write",
          "args": [
            "stp"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "access_permit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4304-4309",
          "snippet": "static inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "access_permit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4304-4309",
    "snippet": "static inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "NFS4_SHARE_ACCESS_BOTH",
            "stp"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}"
  },
  {
    "function_name": "access_permit_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4296-4302",
    "snippet": "static inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "NFS4_SHARE_ACCESS_WRITE",
            "stp"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}"
  },
  {
    "function_name": "nfs4_check_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4289-4294",
    "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&fhp->fh_handle",
            "&stp->st_stid.sc_file->fi_fhandle"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "190-197",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->st_stid.sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "laundromat_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4275-4287",
    "snippet": "static void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime_t t;\n\tstruct delayed_work *dwork = container_of(laundry, struct delayed_work,\n\t\t\t\t\t\t  work);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tdprintk(\"NFSD: laundromat_main - sleeping for %ld seconds\\n\", t);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;",
      "static void laundromat_main(struct work_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "laundry_wq",
            "&nn->laundromat_work",
            "t*HZ"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: laundromat_main - sleeping for %ld seconds\\n\"",
            "t"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_laundromat",
          "args": [
            "nn"
          ],
          "line": 4284
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_laundromat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4191-4270",
          "snippet": "static time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (net_generic(dp->dl_stid.sc_client->net, nfsd_net_id) != nn)\n\t\t\tcontinue;\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (net_generic(dp->dl_stid.sc_client->net, nfsd_net_id) != nn)\n\t\t\tcontinue;\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structnfsd_net",
            "laundromat_work"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "laundry",
            "structdelayed_work",
            "work"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\nstatic void laundromat_main(struct work_struct *);\n\nstatic void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime_t t;\n\tstruct delayed_work *dwork = container_of(laundry, struct delayed_work,\n\t\t\t\t\t\t  work);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tdprintk(\"NFSD: laundromat_main - sleeping for %ld seconds\\n\", t);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}"
  },
  {
    "function_name": "nfs4_laundromat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4191-4270",
    "snippet": "static time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (net_generic(dp->dl_stid.sc_client->net, nfsd_net_id) != nn)\n\t\t\tcontinue;\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "time_t",
            "new_timeo",
            "NFSD_LAUNDROMAT_MINTIMEOUT"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "new_timeo",
            "t"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)oo->oo_time",
            "(unsigned long)cutoff"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&nn->close_lru",
            "structnfs4_openowner",
            "oo_close_lru"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->close_lru"
          ],
          "line": 4250
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_delegation",
          "args": [
            "dp"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "721-737",
          "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&reaplist",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 4239
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)dp->dl_time",
            "(unsigned long)cutoff"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "dp->dl_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->del_recall_lru"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: purging unused client (clientid %08x)\\n\"",
            "clp->cl_clientid.cl_id"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_client",
            "cl_lru"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&reaplist"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: client in use (clientid %08x)\\n\"",
            "clp->cl_clientid.cl_id"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)clp->cl_time",
            "(unsigned long)cutoff"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_client",
            "cl_lru"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->client_lru"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_end_grace",
          "args": [
            "nn"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4158-4189",
          "snippet": "void\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: laundromat service - starting\\n\""
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (net_generic(dp->dl_stid.sc_client->net, nfsd_net_id) != nn)\n\t\t\tcontinue;\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}"
  },
  {
    "function_name": "nfsd4_end_grace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4158-4189",
    "snippet": "void\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_end_grace",
          "args": [
            "&nn->nfsd4_manager"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "locks_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "49-55",
          "snippet": "void\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(grace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(grace_lock);\n\nvoid\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_record_grace_done",
          "args": [
            "nn"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_record_grace_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1491-1496",
          "snippet": "void\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: end of grace period\\n\""
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}"
  },
  {
    "function_name": "nfsd4_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4135-4156",
    "snippet": "__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    clientid_t *clid)\n{\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"process_renew(%08x/%08x): starting\\n\", \n\t\t\tclid->cl_boot, clid->cl_id);\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\tgoto out;\n\tclp = cstate->clp;\n\tstatus = nfserr_cb_path_down;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\tgoto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 4145
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"process_renew(%08x/%08x): starting\\n\"",
            "clid->cl_boot",
            "clid->cl_id"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    clientid_t *clid)\n{\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"process_renew(%08x/%08x): starting\\n\", \n\t\t\tclid->cl_boot, clid->cl_id);\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\tgoto out;\n\tclp = cstate->clp;\n\tstatus = nfserr_cb_path_down;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\tgoto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_cleanup_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4120-4133",
    "snippet": "void nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open, __be32 status)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&open->op_stp->st_stid"
          ],
          "line": 4132
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_slab",
            "open->op_file"
          ],
          "line": 4130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "so"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_assign_replay",
          "args": [
            "cstate",
            "so"
          ],
          "line": 4126
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_assign_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3129-3136",
          "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nvoid nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open, __be32 status)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n}"
  },
  {
    "function_name": "nfsd4_process_open2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4026-4118",
    "snippet": "__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t\tstatus = nfserr_jukebox;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status)\n\t\t\tgoto out;\n\t} else {\n\t\tstp = open->op_stp;\n\t\topen->op_stp = NULL;\n\t\tinit_open_stateid(stp, fp, open);\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&open->op_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tnfs4_set_claim_prev(open, nfsd4_has_session(&resp->cstate));\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_set_claim_prev",
          "args": [
            "open",
            "nfsd4_has_session(&resp->cstate)"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_claim_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3785-3789",
          "snippet": "static void\nnfs4_set_claim_prev(struct nfsd4_open *open, bool has_session)\n{\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_set_claim_prev(struct nfsd4_open *open, bool has_session)\n{\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_deleg_xgrade_none_ext",
          "args": [
            "open",
            "dp"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_deleg_xgrade_none_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4008-4024",
          "snippet": "static void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: stateid=\" STATEID_FMT \"\\n\"",
            "__func__",
            "STATEID_VAL(&stp->st_stid.sc_stateid)"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_open_delegation",
          "args": [
            "current_fh",
            "open",
            "stp"
          ],
          "line": 4089
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_open_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3939-4006",
          "snippet": "static void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs....\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs....\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&open->op_stateid",
            "&stp->st_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_open_stateid",
          "args": [
            "stp"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "release_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1074-1083",
          "snippet": "static void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tunhash_open_stateid(stp, &reaplist);\n\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tunhash_open_stateid(stp, &reaplist);\n\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_vfs_file",
          "args": [
            "rqstp",
            "fp",
            "current_fh",
            "stp",
            "open"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_vfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3691-3754",
          "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_open_stateid",
          "args": [
            "stp",
            "fp",
            "open"
          ],
          "line": 4067
        },
        "resolved": true,
        "details": {
          "function_name": "init_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3227-3245",
          "snippet": "static void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *open) {\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *open) {\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_upgrade_open",
          "args": [
            "rqstp",
            "fp",
            "current_fh",
            "stp",
            "open"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_upgrade_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3756-3783",
          "snippet": "static __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\told_deny_bmap = stp->st_deny_bmap;\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\told_deny_bmap = stp->st_deny_bmap;\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_is_deleg_cur",
          "args": [
            "open"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_is_deleg_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3611-3615",
          "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_find_existing_open",
          "args": [
            "fp",
            "open"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_existing_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3644-3663",
          "snippet": "static struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_deleg",
          "args": [
            "cl",
            "open",
            "&dp"
          ],
          "line": 4043
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3617-3642",
          "snippet": "static __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_add_file",
          "args": [
            "open->op_file",
            "&current_fh->fh_handle"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3316-3337",
          "snippet": "static struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\n__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t\tstatus = nfserr_jukebox;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status)\n\t\t\tgoto out;\n\t} else {\n\t\tstp = open->op_stp;\n\t\topen->op_stp = NULL;\n\t\tinit_open_stateid(stp, fp, open);\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&open->op_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tnfs4_set_claim_prev(open, nfsd4_has_session(&resp->cstate));\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_deleg_xgrade_none_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "4008-4024",
    "snippet": "static void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}"
  },
  {
    "function_name": "nfs4_open_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3939-4006",
    "snippet": "static void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs....\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_open_deleg_none_ext",
          "args": [
            "open",
            "status"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_open_deleg_none_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3912-3931",
          "snippet": "static void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: WARNING: refusing delegation reclaim\\n\""
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\"",
            "STATEID_VAL(&dp->dl_stid.sc_stateid)"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&dp->dl_stid.sc_stateid"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&open->op_delegate_stateid",
            "&dp->dl_stid.sc_stateid",
            "sizeof(dp->dl_stid.sc_stateid)"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dp"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_delegation",
          "args": [
            "clp",
            "fh",
            "stp->st_stid.sc_file"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3870-3910",
          "snippet": "static struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tdp = alloc_init_deleg(clp, fh);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\t++fp->fi_delegees;\n\thash_delegation_locked(dp, fp);\n\tstatus = 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tdp = alloc_init_deleg(clp, fh);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\t++fp->fi_delegees;\n\thash_delegation_locked(dp, fp);\n\tstatus = 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "clp->net"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cb_channel_good",
          "args": [
            "oo->oo_owner.so_client"
          ],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cb_channel_good",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3792-3802",
          "snippet": "static bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs....\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}"
  },
  {
    "function_name": "nfsd4_open_deleg_none_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3912-3931",
    "snippet": "static void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nfs4_set_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3870-3910",
    "snippet": "static struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tdp = alloc_init_deleg(clp, fh);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\t++fp->fi_delegees;\n\thash_delegation_locked(dp, fp);\n\tstatus = 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 3906
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3903
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_delegation_locked",
          "args": [
            "dp",
            "fp"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "hash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "683-693",
          "snippet": "static void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_setlease",
          "args": [
            "dp"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3820-3868",
          "snippet": "static int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl, *ret;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tret = fl;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = 0;\n\t\t++fp->fi_delegees;\n\t\thash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 1;\n\thash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl, *ret;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tret = fl;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = 0;\n\t\t++fp->fi_delegees;\n\t\thash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 1;\n\thash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "605-608",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_init_deleg",
          "args": [
            "clp",
            "fh"
          ],
          "line": 3880
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "608-642",
          "snippet": "static struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *deleg_slab;",
            "static struct nfsd4_callback_ops nfsd4_cb_recall_ops;",
            "static atomic_long_t num_delegations;",
            "unsigned long max_delegations;",
            "static struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *deleg_slab;\nstatic struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\nstatic struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tdp = alloc_init_deleg(clp, fh);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\t++fp->fi_delegees;\n\thash_delegation_locked(dp, fp);\n\tstatus = 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}"
  },
  {
    "function_name": "nfs4_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3820-3868",
    "snippet": "static int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl, *ret;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tret = fl;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = 0;\n\t\t++fp->fi_delegees;\n\t\thash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 1;\n\thash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_delegation_locked",
          "args": [
            "dp",
            "fp"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "hash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "683-693",
          "snippet": "static void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "fl->fl_type",
            "&fl",
            "NULL"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_readable_file",
          "args": [
            "fp"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "334-344",
          "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_init_lease",
          "args": [
            "fp",
            "NFS4_OPEN_DELEGATE_READ"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_init_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3804-3818",
          "snippet": "static struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl, *ret;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tret = fl;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = 0;\n\t\t++fp->fi_delegees;\n\t\thash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 1;\n\thash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_alloc_init_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3804-3818",
    "snippet": "static struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}"
  },
  {
    "function_name": "nfsd4_cb_channel_good",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3792-3802",
    "snippet": "static bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}"
  },
  {
    "function_name": "nfs4_set_claim_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3785-3789",
    "snippet": "static void\nnfs4_set_claim_prev(struct nfsd4_open *open, bool has_session)\n{\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_set_claim_prev(struct nfsd4_open *open, bool has_session)\n{\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n}"
  },
  {
    "function_name": "nfs4_upgrade_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3756-3783",
    "snippet": "static __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\told_deny_bmap = stp->st_deny_bmap;\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "old_deny_bmap",
            "stp"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "871-887",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_truncate",
          "args": [
            "rqstp",
            "cur_fh",
            "open"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3676-3689",
          "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_deny",
          "args": [
            "open->op_share_deny",
            "stp"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "set_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "813-820",
          "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_check_deny",
          "args": [
            "fp",
            "open->op_share_deny"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_check_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "426-443",
          "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_vfs_file",
          "args": [
            "rqstp",
            "fp",
            "cur_fh",
            "stp",
            "open"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_vfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3691-3754",
          "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "open->op_share_access",
            "stp"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\told_deny_bmap = stp->st_deny_bmap;\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_get_vfs_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3691-3754",
    "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "bmap_to_share_mode(old_deny_bmap)",
            "stp"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "871-887",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap_to_share_mode",
          "args": [
            "old_deny_bmap"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_to_share_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "771-781",
          "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "fp",
            "open->op_share_access"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "464-472",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_truncate",
          "args": [
            "rqstp",
            "cur_fh",
            "open"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3676-3689",
          "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "cur_fh",
            "S_IFREG",
            "access",
            "&filp"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "677-762",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tnfsd_close(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_deny",
          "args": [
            "open->op_share_deny",
            "stp"
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "set_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "813-820",
          "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_access",
          "args": [
            "open->op_share_access",
            "stp"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "784-791",
          "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_get_access",
          "args": [
            "fp",
            "open->op_share_access"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "409-424",
          "snippet": "static __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_check_deny",
          "args": [
            "fp",
            "open->op_share_deny"
          ],
          "line": 3707
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_check_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "426-443",
          "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_access_to_access",
          "args": [
            "open->op_share_access"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_access_to_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3665-3674",
          "snippet": "static inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_access_to_omode",
          "args": [
            "open->op_share_access"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_access_to_omode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "841-853",
          "snippet": "static int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3676-3689",
    "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "fh",
            "&iattr",
            "0",
            "(time_t)0"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "397-480",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
  },
  {
    "function_name": "nfs4_access_to_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3665-3674",
    "snippet": "static inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}"
  },
  {
    "function_name": "nfsd4_find_existing_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3644-3663",
    "snippet": "static struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ret->st_stid.sc_count"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "local",
            "&fp->fi_stateids",
            "st_perfile"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_check_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3617-3642",
    "snippet": "static __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_is_deleg_cur",
          "args": [
            "open"
          ],
          "line": 3636
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_is_deleg_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3611-3615",
          "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&deleg->dl_stid"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_delegmode",
          "args": [
            "deleg",
            "flags"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_delegmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3587-3594",
          "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "share_access_to_flags",
          "args": [
            "open->op_share_access"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "share_access_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3596-3599",
          "snippet": "static int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_deleg_stateid",
          "args": [
            "cl",
            "&open->op_delegate_stateid"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "find_deleg_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3601-3609",
          "snippet": "static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_is_deleg_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3611-3615",
    "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
  },
  {
    "function_name": "find_deleg_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3601-3609",
    "snippet": "static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "ret"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "151-154",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_by_type",
          "args": [
            "cl",
            "s",
            "NFS4_DELEG_STID"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1831-1846",
          "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}"
  },
  {
    "function_name": "share_access_to_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3596-3599",
    "snippet": "static int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}"
  },
  {
    "function_name": "nfs4_check_delegmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3587-3594",
    "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_process_open1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3534-3585",
    "snippet": "__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_alloc_open_stateid",
          "args": [
            "clp"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "512-524",
          "snippet": "static struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_init_open_stateowner",
          "args": [
            "strhashval",
            "open",
            "cstate"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_open_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3197-3225",
          "snippet": "static struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_openowner(&oo->oo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *openowner_slab;",
            "static const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_openowner(&oo->oo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_seqid",
          "args": [
            "cstate",
            "&oo->oo_owner",
            "open->op_seqid"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3487-3496",
          "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oo"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1112-1132",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str",
          "args": [
            "strhashval",
            "open",
            "clp"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "244-254",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "&open->op_owner"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "374-380",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clientid",
            "cstate",
            "nn"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3498-3532",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_alloc_file",
          "args": [],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3045-3048",
          "snippet": "static struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "&open->op_clientid",
            "nn"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1495-1508",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "lookup_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3498-3532",
    "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&found->cl_refcount"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1970",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cstate->session"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "clid",
            "nn"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1495-1508",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&found->cl_clientid",
            "clid"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1724-1728",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_check_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3487-3496",
    "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
  },
  {
    "function_name": "nfsd_change_deleg_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3472-3480",
    "snippet": "static int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tif (arg & F_UNLCK)\n\t\treturn lease_modify(onlist, arg, dispose);\n\telse\n\t\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "onlist",
            "arg",
            "dispose"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1303-1324",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tif (arg & F_UNLCK)\n\t\treturn lease_modify(onlist, arg, dispose);\n\telse\n\t\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "nfsd_break_deleg_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3435-3470",
    "snippet": "static bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_file *fp = (struct nfs4_file *)fl->fl_owner;\n\tstruct nfs4_delegation *dp;\n\n\tif (!fp) {\n\t\tWARN(1, \"(%p)->fl_owner NULL\\n\", fl);\n\t\treturn ret;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tWARN(1, \"duplicate break on %p\\n\", fp);\n\t\treturn ret;\n\t}\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\t/*\n\t * If there are no delegations on the list, then return true\n\t * so that the lease code will go ahead and delete it.\n\t */\n\tif (list_empty(&fp->fi_delegations))\n\t\tret = true;\n\telse\n\t\tlist_for_each_entry(dp, &fp->fi_delegations, dl_perfile)\n\t\t\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_break_one_deleg",
          "args": [
            "dp"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_break_one_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3421-3432",
          "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dp",
            "&fp->fi_delegations",
            "dl_perfile"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fp->fi_delegations"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"duplicate break on %p\\n\"",
            "fp"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"(%p)->fl_owner NULL\\n\"",
            "fl"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_file *fp = (struct nfs4_file *)fl->fl_owner;\n\tstruct nfs4_delegation *dp;\n\n\tif (!fp) {\n\t\tWARN(1, \"(%p)->fl_owner NULL\\n\", fl);\n\t\treturn ret;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tWARN(1, \"duplicate break on %p\\n\", fp);\n\t\treturn ret;\n\t}\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\t/*\n\t * If there are no delegations on the list, then return true\n\t * so that the lease code will go ahead and delete it.\n\t */\n\tif (list_empty(&fp->fi_delegations))\n\t\tret = true;\n\telse\n\t\tlist_for_each_entry(dp, &fp->fi_delegations, dl_perfile)\n\t\t\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_break_one_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3421-3432",
    "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&dp->dl_recall"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1105-1108",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dp->dl_stid.sc_count"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3408-3413",
    "snippet": "static void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3384-3406",
    "snippet": "static int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t/*\n\t\t * Race: client probably got cb_recall before open reply\n\t\t * granting delegation.\n\t\t */\n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "2 * HZ"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t/*\n\t\t * Race: client probably got cb_recall before open reply\n\t\t * granting delegation.\n\t\t */\n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3361-3382",
    "snippet": "static void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t/*\n\t * We can't do this in nfsd_break_deleg_cb because it is\n\t * already holding inode->i_lock.\n\t *\n\t * If the dl_time != 0, then we know that it has already been\n\t * queued for a lease break. Don't queue it again.\n\t */\n\tspin_lock(&state_lock);\n\tif (dp->dl_time == 0) {\n\t\tdp->dl_time = get_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dp->dl_recall_lru",
            "&nn->del_recall_lru"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_delegations",
          "args": [
            "&dp->dl_stid.sc_file->fi_fhandle"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "block_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "591-606",
          "snippet": "static void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_delegations_lock);",
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "dp->dl_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t/*\n\t * We can't do this in nfsd_break_deleg_cb because it is\n\t * already holding inode->i_lock.\n\t *\n\t * If the dl_time != 0, then we know that it has already been\n\t * queued for a lease break. Don't queue it again.\n\t */\n\tspin_lock(&state_lock);\n\tif (dp->dl_time == 0) {\n\t\tdp->dl_time = get_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}"
  },
  {
    "function_name": "nfs4_share_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3343-3359",
    "snippet": "static __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_file",
          "args": [
            "&current_fh->fh_handle"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "find_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3304-3314",
          "snippet": "struct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_or_add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3316-3337",
    "snippet": "static struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_file",
          "args": [
            "fh",
            "hashval",
            "new"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3051-3071",
          "snippet": "static void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);",
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fp == NULL"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_file_locked",
          "args": [
            "fh",
            "hashval"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3290-3302",
          "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_hashval",
          "args": [
            "fh"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "file_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "391-394",
          "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}"
  },
  {
    "function_name": "find_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3304-3314",
    "snippet": "struct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_file_locked",
          "args": [
            "fh",
            "hashval"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3290-3302",
          "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_hashval",
          "args": [
            "fh"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "file_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "391-394",
          "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}"
  },
  {
    "function_name": "find_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3290-3302",
    "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&fp->fi_ref"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&fp->fi_fhandle",
            "fh"
          ],
          "line": 3296
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "190-197",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "fp",
            "&file_hashtbl[hashval]",
            "fi_hash"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "move_to_close_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3252-3287",
    "snippet": "static void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&last->st_stid"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&oo->oo_close_lru",
            "&nn->close_lru"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "s->st_stid.sc_file"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_access",
          "args": [
            "s"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "890-904",
          "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "close_wq",
            "atomic_read(&s->st_stid.sc_count) == 2"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->st_stid.sc_count"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: move_to_close_lru nfs4_openowner %p\\n\"",
            "oo"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "s->st_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "s->st_stateowner"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}"
  },
  {
    "function_name": "init_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3227-3245",
    "snippet": "static void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *open) {\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perfile",
            "&fp->fi_stateids"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "605-608",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stp->st_locks"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&stp->st_stid.sc_count"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *open) {\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n}"
  },
  {
    "function_name": "alloc_init_open_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3197-3225",
    "snippet": "static struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_openowner(&oo->oo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_free_openowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3185-3190",
          "snippet": "static void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *openowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\n\nstatic void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_openowner",
          "args": [
            "oo",
            "clp",
            "strhashval"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "hash_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3171-3178",
          "snippet": "static void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str_locked",
          "args": [
            "strhashval",
            "open",
            "clp"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "226-242",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_stateowner",
          "args": [
            "openowner_slab",
            "&open->op_owner",
            "clp"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3149-3169",
          "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_openowner(&oo->oo_owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
  },
  {
    "function_name": "nfs4_free_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3185-3190",
    "snippet": "static void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "openowner_slab",
            "oo"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\n\nstatic void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}"
  },
  {
    "function_name": "nfs4_unhash_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3180-3183",
    "snippet": "static void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_openowner_locked",
          "args": [
            "openowner(so)"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_openowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1085-1093",
          "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}"
  },
  {
    "function_name": "hash_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3171-3178",
    "snippet": "static void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&oo->oo_perclient",
            "&clp->cl_openowners"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}"
  },
  {
    "function_name": "alloc_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3149-3169",
    "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sop->so_count",
            "1"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_nfs4_replay",
          "args": [
            "&sop->so_replay"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "init_nfs4_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3121-3127",
          "snippet": "static void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sop->so_stateids"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "slab",
            "sop"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "owner->data",
            "owner->len",
            "GFP_KERNEL"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "slab",
            "GFP_KERNEL"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
  },
  {
    "function_name": "nfsd4_cstate_clear_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3138-3147",
    "snippet": "void nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "so"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&so->so_replay.rp_mutex"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cstate_assign_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3129-3136",
    "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&so->so_replay.rp_mutex"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
  },
  {
    "function_name": "init_nfs4_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3121-3127",
    "snippet": "static void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&rp->rp_mutex"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}"
  },
  {
    "function_name": "nfsd4_init_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3083-3119",
    "snippet": "int\nnfsd4_init_slabs(void)\n{\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\treturn 0;\n\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout:\n\tdprintk(\"nfsd4: out of memory while initializing nfsv4\\n\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static struct kmem_cache *lockowner_slab;",
      "static struct kmem_cache *file_slab;",
      "static struct kmem_cache *stateid_slab;",
      "static struct kmem_cache *deleg_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4: out of memory while initializing nfsv4\\n\""
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "openowner_slab"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "lockowner_slab"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "file_slab"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "stateid_slab"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_delegations\"",
            "sizeof(struct nfs4_delegation)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_stateids\"",
            "sizeof(struct nfs4_ol_stateid)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_files\"",
            "sizeof(struct nfs4_file)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_lockowners\"",
            "sizeof(struct nfs4_lockowner)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_openowners\"",
            "sizeof(struct nfs4_openowner)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\n\nint\nnfsd4_init_slabs(void)\n{\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\treturn 0;\n\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout:\n\tdprintk(\"nfsd4: out of memory while initializing nfsv4\\n\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfsd4_free_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3073-3081",
    "snippet": "void\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static struct kmem_cache *lockowner_slab;",
      "static struct kmem_cache *file_slab;",
      "static struct kmem_cache *stateid_slab;",
      "static struct kmem_cache *deleg_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "deleg_slab"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "stateid_slab"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "file_slab"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "lockowner_slab"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "openowner_slab"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\n\nvoid\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n}"
  },
  {
    "function_name": "nfsd4_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3051-3071",
    "snippet": "static void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);",
      "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&fp->fi_hash",
            "&file_hashtbl[hashval]"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fp->fi_lo_recalls",
            "0"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_lo_states"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fp->fi_access",
            "0",
            "sizeof(fp->fi_access)"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fp->fi_fds",
            "0",
            "sizeof(fp->fi_fds)"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_copy_shallow",
          "args": [
            "&fp->fi_fhandle",
            "fh"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_delegations"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_stateids"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fp->fi_ref",
            "1"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}"
  },
  {
    "function_name": "nfsd4_alloc_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "3045-3048",
    "snippet": "static struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "file_slab",
            "GFP_KERNEL"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}"
  },
  {
    "function_name": "nfsd4_setclientid_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2979-3043",
    "snippet": "__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\t struct nfsd4_compound_state *cstate,\n\t\t\t struct nfsd4_setclientid_confirm *setclientid_confirm)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t/*\n\t * We try hard to give out unique clientid's, so if we get an\n\t * attempt to confirm the same clientid with a different cred,\n\t * there's a bug somewhere.  Let's charitably assume it's our\n\t * bug.\n\t */\n\tstatus = nfserr_serverfault;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\t/* cases below refer to rfc 3530 section 14.2.34: */\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && !unconf) /* case 2: probable retransmit */\n\t\t\tstatus = nfs_ok;\n\t\telse /* case 4: client hasn't noticed we rebooted yet? */\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) { /* case 1: callback update */\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else { /* case 3: normal case; new or rebooted client */\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "old"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_client_renew_locked",
          "args": [
            "conf"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "154-164",
          "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "conf"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_client_locked",
          "args": [
            "conf"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "120-130",
          "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_confirmed",
          "args": [
            "unconf"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1930-1944",
          "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "old"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&unconf->cl_name",
            "nn"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1986-1991",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_change_callback",
          "args": [
            "conf",
            "&unconf->cl_cb_conn"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_change_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "859-865",
          "snippet": "void nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "old"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&confirm",
            "&unconf->cl_confirm"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1718-1722",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&conf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1758-1771",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1972-1979",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1970",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "clid",
            "nn"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1495-1508",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\t struct nfsd4_compound_state *cstate,\n\t\t\t struct nfsd4_setclientid_confirm *setclientid_confirm)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t/*\n\t * We try hard to give out unique clientid's, so if we get an\n\t * attempt to confirm the same clientid with a different cred,\n\t * there's a bug somewhere.  Let's charitably assume it's our\n\t * bug.\n\t */\n\tstatus = nfserr_serverfault;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\t/* cases below refer to rfc 3530 section 14.2.34: */\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && !unconf) /* case 2: probable retransmit */\n\t\t\tstatus = nfs_ok;\n\t\telse /* case 4: client hasn't noticed we rebooted yet? */\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) { /* case 1: callback update */\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else { /* case 3: normal case; new or rebooted client */\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2922-2976",
    "snippet": "__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier))\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\telse /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "unconf"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "new"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1556-1573",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "setclid->se_confirm.data",
            "new->cl_confirm.data",
            "sizeof(setclid->se_confirm.data)"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_unconfirmed",
          "args": [
            "new"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_unconfirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1915-1928",
          "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_callback",
          "args": [
            "new",
            "setclid",
            "rqstp"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "gen_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2000-2041",
          "snippet": "static void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_clid",
          "args": [
            "new",
            "nn"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "gen_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1813-1818",
          "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_clid",
          "args": [
            "new",
            "conf"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "copy_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1677-1681",
          "snippet": "static void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&conf->cl_verifier",
            "&clverifier"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1718-1722",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "unconf"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client_by_name",
          "args": [
            "&clname",
            "nn"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1993-1998",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\"",
            "addr_str"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *) &conf->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&conf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1758-1771",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clp_used_exchangeid",
          "args": [
            "conf"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "clp_used_exchangeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1981-1984",
          "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&clname",
            "nn"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1986-1991",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_client",
          "args": [
            "clname",
            "rqstp",
            "&clverifier"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "create_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1848-1873",
          "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier))\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\telse /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_reclaim_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2885-2920",
    "snippet": "__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_reclaim_complete *rc)\n{\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t/*\n\t\t * We don't take advantage of the rca_one_fs case.\n\t\t * That's OK, it's optional, we can safely ignore it.\n\t\t */\n\t\t return nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t\t     &cstate->session->se_client->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(cstate->session->se_client))\n\t\t/*\n\t\t * The following error isn't really legal.\n\t\t * But we only get here if the client just explicitly\n\t\t * destroyed the client.  Surely it no longer cares what\n\t\t * error it gets back on an operation for the dead\n\t\t * client.\n\t\t */\n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\tnfsd4_client_record_create(cstate->session->se_client);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_record_create",
          "args": [
            "cstate->session->se_client"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1462-1469",
          "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "cstate->session->se_client"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "115-118",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFSD4_CLIENT_RECLAIM_COMPLETE",
            "&cstate->session->se_client->cl_flags"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_reclaim_complete *rc)\n{\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t/*\n\t\t * We don't take advantage of the rca_one_fs case.\n\t\t * That's OK, it's optional, we can safely ignore it.\n\t\t */\n\t\t return nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t\t     &cstate->session->se_client->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(cstate->session->se_client))\n\t\t/*\n\t\t * The following error isn't really legal.\n\t\t * But we only get here if the client just explicitly\n\t\t * destroyed the client.  Surely it no longer cares what\n\t\t * error it gets back on an operation for the dead\n\t\t * client.\n\t\t */\n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\tnfsd4_client_record_create(cstate->session->se_client);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_destroy_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2844-2883",
    "snippet": "__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_destroy_clientid *dc)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "clp",
            "rqstp"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1785-1798",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "conf"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "conf"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2147-2158",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "conf && unconf"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "&dc->clientid",
            "true",
            "nn"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1970",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "&dc->clientid",
            "true",
            "nn"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1972-1979",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_destroy_clientid *dc)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_sequence_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2828-2842",
    "snippet": "void\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client_renew",
          "args": [
            "cs->clp"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "166-175",
          "snippet": "static void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "cs->session"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "202-210",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_store_cache_entry",
          "args": [
            "resp"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_store_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2046-2068",
          "snippet": "static void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(\"%s: sessions DRC could not cache compound\\n\", __func__);\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(\"%s: sessions DRC could not cache compound\\n\", __func__);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cs"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}"
  },
  {
    "function_name": "nfsd4_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2707-2826",
    "snippet": "__be32\nnfsd4_sequence(struct svc_rqst *rqstp,\n\t       struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t/*\n\t * Will be either used or freed by nfsd4_sequence_check_conn\n\t * below.\n\t */\n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t/* We do not negotiate the number of slots yet, so set the\n\t * maxslots to the session maxreqs which is used to encode\n\t * sr_highest_slotid and the sr_target_slot id to maxslots */\n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t/* Return the cached reply status and set cstate->status\n\t\t * for nfsd4_proc_compound processing */\n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t/* Success! bump slot seqid */\n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "session"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "190-200",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "conn"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1292-1296",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_revoked"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_reserve",
          "args": [
            "rqstp",
            "buflen"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_restrict_buflen",
          "args": [
            "xdr",
            "buflen - rqstp->rq_auth_slack"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_sequence_check_conn",
          "args": [
            "conn",
            "session"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_sequence_check_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2665-2690",
          "snippet": "static __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_replay_cache_entry",
          "args": [
            "resp",
            "seq"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_replay_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2101-2126",
          "snippet": "static __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slot_seqid",
          "args": [
            "seq->seqid",
            "slot->sl_seqid",
            "slot->sl_flags & NFSD4_SLOT_INUSE"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "check_slot_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2285-2304",
          "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: slotid %d\\n\"",
            "__func__",
            "seq->slotid"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_request_too_big",
          "args": [
            "rqstp",
            "session"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_request_too_big",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2699-2705",
          "snippet": "static bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_session_too_many_ops",
          "args": [
            "rqstp",
            "session"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_session_too_many_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2692-2697",
          "snippet": "static bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&seq->sessionid",
            "net",
            "&status"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1461-1477",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "NFS4_CDFC4_FORE"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1360-1367",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\n__be32\nnfsd4_sequence(struct svc_rqst *rqstp,\n\t       struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t/*\n\t * Will be either used or freed by nfsd4_sequence_check_conn\n\t * below.\n\t */\n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t/* We do not negotiate the number of slots yet, so set the\n\t * maxslots to the session maxreqs which is used to encode\n\t * sr_highest_slotid and the sr_target_slot id to maxslots */\n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t/* Return the cached reply status and set cstate->status\n\t\t * for nfsd4_proc_compound processing */\n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t/* Success! bump slot seqid */\n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}"
  },
  {
    "function_name": "nfsd4_request_too_big",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2699-2705",
    "snippet": "static bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}"
  },
  {
    "function_name": "nfsd4_session_too_many_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2692-2697",
    "snippet": "static bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}"
  },
  {
    "function_name": "nfsd4_sequence_check_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2665-2690",
    "snippet": "static __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "new"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1292-1296",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_conn_lost",
          "args": [
            "&new->cn_xpt_user"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_conn_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1298-1310",
          "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_register_conn",
          "args": [
            "new"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_register_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1341-1345",
          "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfsd4_hash_conn",
          "args": [
            "new",
            "ses"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1326-1330",
          "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfsd4_find_conn",
          "args": [
            "new->cn_xprt",
            "ses"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_find_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2653-2663",
          "snippet": "static struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}"
  },
  {
    "function_name": "__nfsd4_find_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2653-2663",
    "snippet": "static struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&s->se_conns",
            "cn_persession"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_destroy_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2610-2651",
    "snippet": "__be32\nnfsd4_destroy_session(struct svc_rqst *r,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_destroy_session *sessionid)\n{\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate->session, &sessionid->sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, &sessionid->sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(&sessionid->sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "ses"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "190-200",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback_sync",
          "args": [
            "ses->se_client"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_session",
          "args": [
            "ses"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1480-1492",
          "snippet": "static void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_session_dead_locked",
          "args": [
            "ses",
            "1 + ref_held_by_me"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "mark_session_dead_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "107-113",
          "snippet": "static __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "ses->se_client",
            "r"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1785-1798",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&sessionid->sessionid",
            "net",
            "&status"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1461-1477",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_sessionid",
          "args": [
            "__func__",
            "&sessionid->sessionid"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "dump_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1150-1153",
          "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "r"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "617-623",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_compound_in_session",
          "args": [
            "cstate->session",
            "&sessionid->sessionid"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_compound_in_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2603-2608",
          "snippet": "static bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "r"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32\nnfsd4_destroy_session(struct svc_rqst *r,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_destroy_session *sessionid)\n{\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate->session, &sessionid->sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, &sessionid->sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(&sessionid->sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_compound_in_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2603-2608",
    "snippet": "static bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sid",
            "&session->se_sessionid",
            "sizeof(*sid)"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}"
  },
  {
    "function_name": "nfsd4_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2568-2601",
    "snippet": "__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_bind_conn_to_session *bcts)\n{\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "session"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "202-210",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_conn",
          "args": [
            "rqstp",
            "conn",
            "session"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1347-1358",
          "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "bcts->dir"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1360-1367",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_map_bcts_dir",
          "args": [
            "&bcts->dir"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_map_bcts_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2535-2547",
          "snippet": "static __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "session->se_client",
            "rqstp"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1785-1798",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&bcts->sessionid",
            "net",
            "&status"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1461-1477",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "rqstp"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "617-623",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_bind_conn_to_session *bcts)\n{\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_backchannel_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2549-2566",
    "snippet": "__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_backchannel_ctl *bc)\n{\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "session->se_client"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_cb_sec",
          "args": [
            "&bc->bc_cb_sec"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2400-2416",
          "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_backchannel_ctl *bc)\n{\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_map_bcts_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2535-2547",
    "snippet": "static __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}"
  },
  {
    "function_name": "nfsd4_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2418-2533",
    "snippet": "__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_create_session *cr_ses)\n{\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status == nfserr_replay_cache) {\n\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t} else if (cr_ses->seqid != cs_slot->sl_seqid + 1) {\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t/* an unconfirmed replay returns misordered */\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t/*\n\t * We do not support RDMA or persistent sessions\n\t */\n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t/* cache solo and embedded create sessions under the client_lock */\n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\t/* init connection and backchannel */\n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_drc_mem",
          "args": [
            "&cr_ses->fore_channel"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1250-1257",
          "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_session",
          "args": [
            "new"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "__free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1389-1393",
          "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "old"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "conn"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1292-1296",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "new"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "202-210",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_conn",
          "args": [
            "rqstp",
            "conn",
            "new"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1347-1358",
          "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cache_create_session",
          "args": [
            "cr_ses",
            "cs_slot",
            "status"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cache_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2311-2317",
          "snippet": "static void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cr_ses->sessionid.data",
            "new->se_sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_get_session_locked",
          "args": [
            "new"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "177-188",
          "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_session",
          "args": [
            "rqstp",
            "new",
            "conf",
            "cr_ses"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "init_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1402-1435",
          "snippet": "static void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_confirmed",
          "args": [
            "unconf"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1930-1944",
          "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "old"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&unconf->cl_name",
            "nn"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1986-1991",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slot_seqid",
          "args": [
            "cr_ses->seqid",
            "cs_slot->sl_seqid",
            "0"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "check_slot_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2285-2304",
          "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "unconf",
            "rqstp"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1785-1798",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "sa",
            "(struct sockaddr *) &unconf->cl_addr"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&unconf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1758-1771",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_replay_create_session",
          "args": [
            "cr_ses",
            "cs_slot"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_replay_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2319-2325",
          "snippet": "static __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "conf && unconf"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "&cr_ses->clientid",
            "true",
            "nn"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1970",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "&cr_ses->clientid",
            "true",
            "nn"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1972-1979",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_conn_from_crses",
          "args": [
            "rqstp",
            "cr_ses"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1360-1367",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_session",
          "args": [
            "&cr_ses->fore_channel",
            "&cr_ses->back_channel"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1259-1290",
          "snippet": "static struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_backchannel_attrs",
          "args": [
            "&cr_ses->back_channel"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "check_backchannel_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2379-2398",
          "snippet": "static __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\t/*\n\t * These RPC_MAX_HEADER macros are overkill, especially since we\n\t * don't even do gss on the backchannel yet.  But this is still\n\t * less than 1k.  Tighten up this estimate in the unlikely event\n\t * it turns out to be a problem for some client:\n\t */\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH) * sizeof(__be32))",
            "#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH) * sizeof(__be32))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH) * sizeof(__be32))\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH) * sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\t/*\n\t * These RPC_MAX_HEADER macros are overkill, especially since we\n\t * don't even do gss on the backchannel yet.  But this is still\n\t * less than 1k.  Tighten up this estimate in the unlikely event\n\t * it turns out to be a problem for some client:\n\t */\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_forechannel_attrs",
          "args": [
            "&cr_ses->fore_channel",
            "nn"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "check_forechannel_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2344-2372",
          "snippet": "static __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */",
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_cb_sec",
          "args": [
            "&cr_ses->cb_sec"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2400-2416",
          "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_create_session *cr_ses)\n{\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status == nfserr_replay_cache) {\n\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t} else if (cr_ses->seqid != cs_slot->sl_seqid + 1) {\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t/* an unconfirmed replay returns misordered */\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t/*\n\t * We do not support RDMA or persistent sessions\n\t */\n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t/* cache solo and embedded create sessions under the client_lock */\n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\t/* init connection and backchannel */\n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_check_cb_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2400-2416",
    "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
  },
  {
    "function_name": "check_backchannel_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2379-2398",
    "snippet": "static __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\t/*\n\t * These RPC_MAX_HEADER macros are overkill, especially since we\n\t * don't even do gss on the backchannel yet.  But this is still\n\t * less than 1k.  Tighten up this estimate in the unlikely event\n\t * it turns out to be a problem for some client:\n\t */\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH) * sizeof(__be32))",
      "#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH) * sizeof(__be32))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH) * sizeof(__be32))\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH) * sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\t/*\n\t * These RPC_MAX_HEADER macros are overkill, especially since we\n\t * don't even do gss on the backchannel yet.  But this is still\n\t * less than 1k.  Tighten up this estimate in the unlikely event\n\t * it turns out to be a problem for some client:\n\t */\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "check_forechannel_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2344-2372",
    "snippet": "static __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */",
      "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_get_drc_mem",
          "args": [
            "ca"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1234-1248",
          "snippet": "static u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxreqs",
            "NFSD_MAX_SLOTS_PER_SESSION"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxresp_cached",
            "NFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxops",
            "NFSD_MAX_OPS_PER_COMPOUND"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxresp_sz",
            "maxrpc"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxreq_sz",
            "maxrpc"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_replay_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2319-2325",
    "snippet": "static __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cr_ses",
            "&slot->sl_cr_ses",
            "sizeof(*cr_ses)"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}"
  },
  {
    "function_name": "nfsd4_cache_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2311-2317",
    "snippet": "static void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&slot->sl_cr_ses",
            "cr_ses",
            "sizeof(*cr_ses)"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}"
  },
  {
    "function_name": "check_slot_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2285-2304",
    "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "seqid == slot_seqid + 1"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter. seqid %d slot_seqid %d\\n\"",
            "__func__",
            "seqid",
            "slot_seqid"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
  },
  {
    "function_name": "nfsd4_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2160-2283",
    "snippet": "__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp,\n\t\t  struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_exchange_id *exid)\n{\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\tif (!svc_rqst_integrity_protected(rqstp))\n\t\t\treturn nfserr_inval;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t/* checked by xdr code */\n\t\tWARN_ON_ONCE(1);\n\tcase SP4_SSV:\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\n\t/* Cases below refer to rfc 5661 section 18.35.4: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) { /* buggy client */\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) { /* case 9 */\n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) { /* case 8 */\n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* case 6 */\n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) { /* case 3 */\n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) { /* case 2 */\n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\t/* case 5, client reboot */\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) { /* case 7 */\n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf  = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf) /* case 4, possible retry or client restart */\n\t\tunhash_client_locked(unconf);\n\n\t/* case 1 (normal case) */\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\tnew->cl_mach_cred = (exid->spa_how == SP4_MACH_CRED);\n\n\tgen_clid(new, nn);\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "unconf"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1664-1669",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_exchange_id seqid %d flags %x\\n\"",
            "conf->cl_cs_slot.sl_seqid",
            "conf->cl_exchange_flags"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_set_ex_flags",
          "args": [
            "conf",
            "exid"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_ex_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2131-2145",
          "snippet": "static void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "new",
            "conf"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_unconfirmed",
          "args": [
            "new"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_unconfirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1915-1928",
          "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_clid",
          "args": [
            "new",
            "nn"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "gen_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1813-1818",
          "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "conf"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1611-1617",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "unconf"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client_by_name",
          "args": [
            "&exid->clname",
            "nn"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1993-1998",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "conf"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2147-2158",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "conf",
            "rqstp"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1785-1798",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clp_used_exchangeid",
          "args": [
            "conf"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "clp_used_exchangeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1981-1984",
          "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&verf",
            "&conf->cl_verifier"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1718-1722",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&conf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1758-1771",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&exid->clname",
            "nn"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1986-1991",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_client",
          "args": [
            "exid->clname",
            "rqstp",
            "&verf"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "create_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1848-1873",
          "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_rqst_integrity_protected",
          "args": [
            "rqstp"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "svc_rqst_integrity_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1773-1783",
          "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\"",
            "__func__",
            "rqstp",
            "exid",
            "exid->clname.len",
            "exid->clname.data",
            "addr_str",
            "exid->flags",
            "exid->spa_how"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "sa",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp,\n\t\t  struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_exchange_id *exid)\n{\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\tif (!svc_rqst_integrity_protected(rqstp))\n\t\t\treturn nfserr_inval;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t/* checked by xdr code */\n\t\tWARN_ON_ONCE(1);\n\tcase SP4_SSV:\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\n\t/* Cases below refer to rfc 5661 section 18.35.4: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) { /* buggy client */\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) { /* case 9 */\n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) { /* case 8 */\n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* case 6 */\n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) { /* case 3 */\n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) { /* case 2 */\n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\t/* case 5, client reboot */\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) { /* case 7 */\n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf  = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf) /* case 4, possible retry or client restart */\n\t\tunhash_client_locked(unconf);\n\n\t/* case 1 (normal case) */\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\tnew->cl_mach_cred = (exid->spa_how == SP4_MACH_CRED);\n\n\tgen_clid(new, nn);\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}"
  },
  {
    "function_name": "client_has_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2147-2158",
    "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\t/*\n\t * Note clp->cl_openowners check isn't quite right: there's no\n\t * need to count owners without stateid's.\n\t *\n\t * Also note we should probably be using this in 4.0 case too.\n\t */\n\treturn !list_empty(&clp->cl_openowners)\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
  },
  {
    "function_name": "nfsd4_set_ex_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2131-2145",
    "snippet": "static void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}"
  },
  {
    "function_name": "nfsd4_replay_cache_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2101-2126",
    "snippet": "static __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "slot->sl_data",
            "slot->sl_datalen"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "slot->sl_datalen"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_enc_sequence_replay",
          "args": [
            "resp->rqstp->rq_argp",
            "resp"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_enc_sequence_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "2077-2095",
          "snippet": "static __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s slot %p\\n\"",
            "__func__",
            "slot"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}"
  },
  {
    "function_name": "nfsd4_enc_sequence_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2077-2095",
    "snippet": "static __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_operation",
          "args": [
            "resp",
            "op"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4272-4337",
          "snippet": "void\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}"
  },
  {
    "function_name": "nfsd4_store_cache_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2046-2068",
    "snippet": "static void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(\"%s: sessions DRC could not cache compound\\n\", __func__);\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"%s: sessions DRC could not cache compound\\n\"",
            "__func__"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_bytes_from_xdr_buf",
          "args": [
            "buf",
            "base",
            "slot->sl_data",
            "slot->sl_datalen"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_not_cached",
          "args": [
            "resp"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_not_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "611-615",
          "snippet": "static inline bool nfsd4_not_cached(struct nfsd4_compoundres *resp)\n{\n\treturn !(resp->cstate.slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t|| nfsd4_is_solo_sequence(resp);\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_not_cached(struct nfsd4_compoundres *resp)\n{\n\treturn !(resp->cstate.slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t|| nfsd4_is_solo_sequence(resp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s slot %p\\n\"",
            "__func__",
            "slot"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(\"%s: sessions DRC could not cache compound\\n\", __func__);\n\treturn;\n}"
  },
  {
    "function_name": "gen_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "2000-2041",
    "snippet": "static void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\"",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&conn->cb_saddr",
            "&rqstp->rq_daddr",
            "rqstp->rq_daddrlen"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_uaddr2sockaddr",
          "args": [
            "clp->net",
            "se->se_callback_addr_val",
            "se->se_callback_addr_len",
            "(struct sockaddr *)&conn->cb_addr",
            "sizeof(conn->cb_addr)"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "se->se_callback_netid_val",
            "\"tcp6\"",
            "4"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "se->se_callback_netid_val",
            "\"tcp\"",
            "3"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_scope_id",
          "args": [
            "sa"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}"
  },
  {
    "function_name": "find_unconfirmed_client_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1993-1998",
    "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_clp_in_name_tree",
          "args": [
            "name",
            "&nn->unconf_name_tree"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "find_clp_in_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1895-1913",
          "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
  },
  {
    "function_name": "find_confirmed_client_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1986-1991",
    "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_clp_in_name_tree",
          "args": [
            "name",
            "&nn->conf_name_tree"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "find_clp_in_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1895-1913",
          "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
  },
  {
    "function_name": "clp_used_exchangeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1981-1984",
    "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
  },
  {
    "function_name": "find_unconfirmed_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1972-1979",
    "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_client_in_id_table",
          "args": [
            "tbl",
            "clid",
            "sessions"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_id_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1946-1961",
          "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
  },
  {
    "function_name": "find_confirmed_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1963-1970",
    "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_client_in_id_table",
          "args": [
            "tbl",
            "clid",
            "sessions"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_id_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1946-1961",
          "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
  },
  {
    "function_name": "find_client_in_id_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1946-1961",
    "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "133-152",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&clp->cl_clientid",
            "clid"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1724-1728",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&tbl[idhashval]",
            "cl_idhash"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clid->cl_id"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "743-746",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "move_to_confirmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1930-1944",
    "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "133-152",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_clp_to_name_tree",
          "args": [
            "clp",
            "&nn->conf_name_tree"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "add_clp_to_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1875-1893",
          "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->unconf_name_tree"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&clp->cl_idhash",
            "&nn->conf_id_hashtbl[idhashval]"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: move_to_confirm nfs4_client %p\\n\"",
            "clp"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clp->cl_clientid.cl_id"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "743-746",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "add_to_unconfirmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1915-1928",
    "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "133-152",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&clp->cl_idhash",
            "&nn->unconf_id_hashtbl[idhashval]"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clp->cl_clientid.cl_id"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "743-746",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_clp_to_name_tree",
          "args": [
            "clp",
            "&nn->unconf_name_tree"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "add_clp_to_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1875-1893",
          "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "find_clp_in_name_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1895-1913",
    "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_blob",
          "args": [
            "&clp->cl_name",
            "name"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "compare_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1703-1711",
          "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structnfs4_client",
            "cl_namenode"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_clp_to_name_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1875-1893",
    "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_clp->cl_namenode",
            "root"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_clp->cl_namenode",
            "parent",
            "new"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_blob",
          "args": [
            "&clp->cl_name",
            "&new_clp->cl_name"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "compare_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1703-1711",
          "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structnfs4_client",
            "cl_namenode"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
  },
  {
    "function_name": "create_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1848-1873",
    "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *) &clp->cl_addr",
            "sa"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_verf",
          "args": [
            "clp",
            "verf"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "copy_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1671-1675",
          "snippet": "static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "&clp->cl_cb_slot_busy"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&clp->cl_cb_null",
            "clp",
            "NULL",
            "NFSPROC4_CLNT_CB_NULL"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1092-1103",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "clp"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1556-1573",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_cred",
          "args": [
            "&clp->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "copy_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1683-1701",
          "snippet": "static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tif (source->cr_principal) {\n\t\ttarget->cr_principal =\n\t\t\t\tkstrdup(source->cr_principal, GFP_KERNEL);\n\t\tif (target->cr_principal == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\ttarget->cr_principal = NULL;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tif (source->cr_principal) {\n\t\ttarget->cr_principal =\n\t\t\t\tkstrdup(source->cr_principal, GFP_KERNEL);\n\t\tif (target->cr_principal == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\ttarget->cr_principal = NULL;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_client",
          "args": [
            "name"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1515-1554",
          "snippet": "static struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_callbacks);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n\nstatic struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_callbacks);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
  },
  {
    "function_name": "find_stateid_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1831-1846",
    "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&s->sc_count"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "t"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1820-1829",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
  },
  {
    "function_name": "find_stateid_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1820-1829",
    "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&cl->cl_stateids",
            "t->si_opaque.so_id"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "343-351",
          "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "gen_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1813-1818",
    "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gen_confirm",
          "args": [
            "clp",
            "nn"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "gen_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1800-1811",
          "snippet": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clientid_counter;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clientid_counter;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
  },
  {
    "function_name": "gen_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1800-1811",
    "snippet": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clientid_counter;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "clp->cl_confirm.data",
            "verf",
            "sizeof(clp->cl_confirm.data)"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clientid_counter;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}"
  },
  {
    "function_name": "mach_creds_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1785-1798",
    "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cl->cl_cred.cr_principal",
            "cr->cr_principal"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_rqst_integrity_protected",
          "args": [
            "rqstp"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "svc_rqst_integrity_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1773-1783",
          "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
  },
  {
    "function_name": "svc_rqst_integrity_protected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1773-1783",
    "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_pseudoflavor_to_service",
          "args": [
            "cr->cr_gss_mech",
            "cr->cr_flavor"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
  },
  {
    "function_name": "same_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1758-1771",
    "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cr1->cr_principal",
            "cr2->cr_principal"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "groups_equal",
          "args": [
            "cr1->cr_group_info",
            "cr2->cr_group_info"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "groups_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1730-1740",
          "snippet": "static bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "cr1->cr_gid",
            "cr2->cr_gid"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cr1->cr_uid",
            "cr2->cr_uid"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_gss_cred",
          "args": [
            "cr2"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "is_gss_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1751-1755",
          "snippet": "static bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
  },
  {
    "function_name": "is_gss_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1751-1755",
    "snippet": "static bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}"
  },
  {
    "function_name": "groups_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1730-1740",
    "snippet": "static bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "GROUP_AT(g1, i)",
            "GROUP_AT(g2, i)"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GROUP_AT",
          "args": [
            "g2",
            "i"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GROUP_AT",
          "args": [
            "g1",
            "i"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "same_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1724-1728",
    "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
  },
  {
    "function_name": "same_verf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1718-1722",
    "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "v1->data",
            "v2->data",
            "sizeof(v1->data)"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
  },
  {
    "function_name": "same_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1713-1716",
    "snippet": "static int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "n1",
            "n2",
            "HEXDIR_LEN"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}"
  },
  {
    "function_name": "compare_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1703-1711",
    "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "o1->data",
            "o2->data",
            "o1->len"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
  },
  {
    "function_name": "copy_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1683-1701",
    "snippet": "static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tif (source->cr_principal) {\n\t\ttarget->cr_principal =\n\t\t\t\tkstrdup(source->cr_principal, GFP_KERNEL);\n\t\tif (target->cr_principal == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\ttarget->cr_principal = NULL;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_mech_get",
          "args": [
            "source->cr_gss_mech"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "target->cr_group_info"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "source->cr_principal",
            "GFP_KERNEL"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tif (source->cr_principal) {\n\t\ttarget->cr_principal =\n\t\t\t\tkstrdup(source->cr_principal, GFP_KERNEL);\n\t\tif (target->cr_principal == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\ttarget->cr_principal = NULL;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1677-1681",
    "snippet": "static void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}"
  },
  {
    "function_name": "copy_verf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1671-1675",
    "snippet": "static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target->cl_verifier.data",
            "source->data",
            "sizeof(target->cl_verifier.data)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}"
  },
  {
    "function_name": "expire_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1664-1669",
    "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_client",
          "args": [
            "clp"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1619-1655",
          "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_record_remove",
          "args": [
            "clp"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1471-1478",
          "snippet": "void\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client",
          "args": [
            "clp"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1601-1609",
          "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
  },
  {
    "function_name": "destroy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1657-1662",
    "snippet": "static void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_client",
          "args": [
            "clp"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1619-1655",
          "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client",
          "args": [
            "clp"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1601-1609",
          "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}"
  },
  {
    "function_name": "__destroy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1619-1655",
    "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "clp"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1556-1573",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "clp->cl_cb_conn.cb_xprt"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_shutdown_callback",
          "args": [
            "clp"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "989-999",
          "snippet": "void nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_client_layouts",
          "args": [
            "clp"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oo"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1112-1132",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_openowners.next",
            "structnfs4_openowner",
            "oo_perclient"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_openowners"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_revoked.next",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "663-676",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reaplist.next",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_delegations.next",
            "structnfs4_delegation",
            "dl_perclnt"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tunhash_delegation_locked(dp);\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
  },
  {
    "function_name": "mark_client_expired_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1611-1617",
    "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "unhash_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1601-1609",
    "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1576-1599",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "unhash_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1576-1599",
    "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ses->se_hash"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ses",
            "&clp->cl_sessions",
            "se_perclnt"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->unconf_name_tree"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->conf_name_tree"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "free_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1556-1573",
    "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&clp->cl_stateids"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_name.data"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_ownerstr_hashtbl"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_svc_cred",
          "args": [
            "&clp->cl_cred"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_wait_queue",
          "args": [
            "&clp->cl_cb_waitq"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_session",
          "args": [
            "ses"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1395-1400",
          "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&ses->se_ref)"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ses->se_ref"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->se_perclnt"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_sessions.next",
            "structnfsd4_session",
            "se_perclnt"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
  },
  {
    "function_name": "alloc_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1515-1554",
    "snippet": "static struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_callbacks);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_name.data"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_init_wait_queue",
          "args": [
            "&clp->cl_cb_waitq",
            "\"Backchannel slot table\""
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_lo_states"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_revoked"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_callbacks"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_openowners"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&clp->cl_refcount",
            "0"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&clp->cl_stateids"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_ownerstr_hashtbl[i]"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "name.data",
            "name.len",
            "GFP_KERNEL"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct nfs4_client)",
            "GFP_KERNEL"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n\nstatic struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_callbacks);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "STALE_CLIENTID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1495-1508",
    "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\"",
            "clid->cl_boot",
            "clid->cl_id",
            "nn->boot_time"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
  },
  {
    "function_name": "unhash_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1480-1492",
    "snippet": "static void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ses->se_client->cl_lock"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->se_perclnt"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ses->se_client->cl_lock"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}"
  },
  {
    "function_name": "find_in_sessionid_hashtbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1461-1477",
    "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_get_session_locked",
          "args": [
            "session"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "177-188",
          "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_in_sessionid_hashtbl",
          "args": [
            "sessionid",
            "net"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "__find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1438-1459",
          "snippet": "static struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
  },
  {
    "function_name": "__find_in_sessionid_hashtbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1438-1459",
    "snippet": "static struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: session not found\\n\"",
            "__func__"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "elem->se_sessionid.data",
            "sessionid->data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "elem",
            "&nn->sessionid_hashtbl[idx]",
            "se_hash"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_sessionid",
          "args": [
            "sessionid"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "hash_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1134-1140",
          "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_sessionid",
          "args": [
            "__func__",
            "sessionid"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "dump_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1150-1153",
          "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1402-1435",
    "snippet": "static void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_addr_len",
          "args": [
            "sa"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *)&clp->cl_cb_conn.cb_addr",
            "sa"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->se_perclnt",
            "&clp->cl_sessions"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_sessionid",
          "args": [
            "&new->se_sessionid"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "hash_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1134-1140",
          "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->se_ref",
            "0"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->se_conns"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_sessionid",
          "args": [
            "new"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "gen_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1179-1189",
          "snippet": "static void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 current_sessionid = 1;",
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 current_sessionid = 1;\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}"
  },
  {
    "function_name": "free_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1395-1400",
    "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_session",
          "args": [
            "ses"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "__free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1389-1393",
          "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_drc_mem",
          "args": [
            "&ses->se_fchannel"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1250-1257",
          "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_del_conns",
          "args": [
            "ses"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_del_conns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1370-1387",
          "snippet": "static void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
  },
  {
    "function_name": "__free_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1389-1393",
    "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_session_slots",
          "args": [
            "ses"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "free_session_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1205-1212",
          "snippet": "static void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
  },
  {
    "function_name": "nfsd4_del_conns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1370-1387",
    "snippet": "static void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "c"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1292-1296",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_xpt_user",
          "args": [
            "c->cn_xprt",
            "&c->cn_xpt_user"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&s->se_conns",
            "structnfsd4_conn",
            "cn_persession"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&s->se_conns"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "alloc_conn_from_crses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1360-1367",
    "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "dir"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1360-1367",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
  },
  {
    "function_name": "nfsd4_init_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1347-1358",
    "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_probe_callback_sync",
          "args": [
            "ses->se_client"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_conn_lost",
          "args": [
            "&conn->cn_xpt_user"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_conn_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1298-1310",
          "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_register_conn",
          "args": [
            "conn"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_register_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1341-1345",
          "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_hash_conn",
          "args": [
            "conn",
            "ses"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1332-1339",
          "snippet": "static void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
  },
  {
    "function_name": "nfsd4_register_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1341-1345",
    "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_xpt_user",
          "args": [
            "conn->cn_xprt",
            "&conn->cn_xpt_user"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
  },
  {
    "function_name": "nfsd4_hash_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1332-1339",
    "snippet": "static void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfsd4_hash_conn",
          "args": [
            "conn",
            "ses"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1326-1330",
          "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "__nfsd4_hash_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1326-1330",
    "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&conn->cn_persession",
            "&ses->se_conns"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
  },
  {
    "function_name": "alloc_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1312-1324",
    "snippet": "static struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&conn->cn_xpt_user.list"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_xprt_get",
          "args": [
            "rqstp->rq_xprt"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfsd4_conn)",
            "GFP_KERNEL"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}"
  },
  {
    "function_name": "nfsd4_conn_lost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1298-1310",
    "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "clp"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "c"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1292-1296",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "u",
            "structnfsd4_conn",
            "cn_xpt_user"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "free_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1292-1296",
    "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "c->cn_xprt"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
  },
  {
    "function_name": "alloc_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1259-1290",
    "snippet": "static struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new->se_slots[i]"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->se_bchannel",
            "battrs",
            "sizeof(struct nfsd4_channel_attrs)"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->se_fchannel",
            "fattrs",
            "sizeof(struct nfsd4_channel_attrs)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "slotsize",
            "GFP_KERNEL"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new) + mem",
            "GFP_KERNEL"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "fattrs"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1218-1227",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_put_drc_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1250-1257",
    "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "ca"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1218-1227",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
  },
  {
    "function_name": "nfsd4_get_drc_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1234-1248",
    "snippet": "static u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "num",
            "avail / slotsize"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(unsigned long)NFSD_MAX_MEM_PER_SESSION",
            "nfsd_drc_max_mem - nfsd_drc_mem_used"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "ca"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1218-1227",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}"
  },
  {
    "function_name": "slot_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1218-1227",
    "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
  },
  {
    "function_name": "free_session_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1205-1212",
    "snippet": "static void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->se_slots[i]"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}"
  },
  {
    "function_name": "gen_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1179-1189",
    "snippet": "static void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 current_sessionid = 1;",
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 current_sessionid = 1;\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}"
  },
  {
    "function_name": "nfsd4_bump_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1160-1177",
    "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_last_closed_stateid",
          "args": [
            "openowner(so)"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "release_last_closed_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1095-1110",
          "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_clear_replay",
          "args": [
            "cstate"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_clear_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3138-3147",
          "snippet": "void nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seqid_mutating_err",
          "args": [
            "ntohl(nfserr)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "nfserr"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
  },
  {
    "function_name": "dump_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1150-1153",
    "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
  },
  {
    "function_name": "dump_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1143-1148",
    "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: %u:%u:%u:%u\\n\"",
            "fn",
            "ptr[0]",
            "ptr[1]",
            "ptr[2]",
            "ptr[3]"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}"
  },
  {
    "function_name": "hash_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1134-1140",
    "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
  },
  {
    "function_name": "release_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1112-1132",
    "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_last_closed_stateid",
          "args": [
            "oo"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "release_last_closed_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1095-1110",
          "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1012-1029",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "959-976",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1065-1072",
          "snippet": "static void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&oo->oo_owner.so_stateids",
            "structnfs4_ol_stateid",
            "st_perstateowner"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&oo->oo_owner.so_stateids"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_openowner_locked",
          "args": [
            "oo"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_openowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1085-1093",
          "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_open_stateid(stp, &reaplist);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
  },
  {
    "function_name": "release_last_closed_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1095-1110",
    "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&s->st_stid"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "oo->oo_owner.so_client->net",
            "nfsd_net_id"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
  },
  {
    "function_name": "unhash_openowner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1085-1093",
    "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_perclient"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_owner.so_strhash"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
  },
  {
    "function_name": "release_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1074-1083",
    "snippet": "static void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tunhash_open_stateid(stp, &reaplist);\n\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1012-1029",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "959-976",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1065-1072",
          "snippet": "static void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tunhash_open_stateid(stp, &reaplist);\n\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}"
  },
  {
    "function_name": "unhash_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1065-1072",
    "snippet": "static void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_open_stateid_locks",
          "args": [
            "stp",
            "reaplist"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "release_open_stateid_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1052-1063",
          "snippet": "static void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_ol_stateid",
          "args": [
            "stp"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "920-930",
          "snippet": "static void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n}"
  },
  {
    "function_name": "release_open_stateid_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1052-1063",
    "snippet": "static void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "reaplist"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "959-976",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "978-987",
          "snippet": "static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "open_stp->st_locks.next",
            "structnfs4_ol_stateid",
            "st_locks"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&open_stp->st_locks"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}"
  },
  {
    "function_name": "release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1031-1050",
    "snippet": "static void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1012-1029",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "959-976",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "978-987",
          "snippet": "static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&lo->lo_owner.so_stateids",
            "structnfs4_ol_stateid",
            "st_perstateowner"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->lo_owner.so_stateids"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_lockowner_locked",
          "args": [
            "lo"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lockowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "999-1006",
          "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tunhash_lock_stateid(stp);\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}"
  },
  {
    "function_name": "free_ol_stateid_reaplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "1012-1029",
    "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stp->st_stid.sc_free",
          "args": [
            "&stp->st_stid"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&stp->st_locks"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "reaplist",
            "structnfs4_ol_stateid",
            "st_locks"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "reaplist"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
  },
  {
    "function_name": "unhash_lockowner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "999-1006",
    "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lo->lo_owner.so_strhash"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
  },
  {
    "function_name": "release_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "989-997",
    "snippet": "static void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tnfs4_put_stid(&stp->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "978-987",
          "snippet": "static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_openstp->st_stateowner"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tnfs4_put_stid(&stp->st_stid);\n}"
  },
  {
    "function_name": "unhash_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "978-987",
    "snippet": "static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_unhash_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_unhash_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "678-681",
          "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_ol_stateid",
          "args": [
            "stp"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "920-930",
          "snippet": "static void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&stp->st_locks"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_openstp->st_stateowner"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tunhash_ol_stateid(stp);\n\tnfs4_unhash_stid(&stp->st_stid);\n}"
  },
  {
    "function_name": "put_ol_stateid_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "959-976",
    "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_locks",
            "reaplist"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&clp->cl_stateids",
            "s->sc_stateid.si_opaque.so_id"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&close_wq"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&s->sc_count"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&stp->st_locks)"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stp->st_locks"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
  },
  {
    "function_name": "nfs4_free_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "942-952",
    "snippet": "static void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct file *file;\n\n\tfile = find_any_file(stp->st_stid.sc_file);\n\tif (file)\n\t\tfilp_close(file, (fl_owner_t)lo);\n\tnfs4_free_ol_stateid(stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_ol_stateid",
          "args": [
            "stid"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "932-940",
          "snippet": "static void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "(fl_owner_t)lo"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1060-1078",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "346-360",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5022-5027",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstatic void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct file *file;\n\n\tfile = find_any_file(stp->st_stid.sc_file);\n\tif (file)\n\t\tfilp_close(file, (fl_owner_t)lo);\n\tnfs4_free_ol_stateid(stid);\n}"
  },
  {
    "function_name": "nfs4_free_ol_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "932-940",
    "snippet": "static void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "stateid_slab",
            "stid"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "906-918",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_access",
          "args": [
            "stp"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "890-904",
          "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}"
  },
  {
    "function_name": "unhash_ol_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "920-930",
    "snippet": "static void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&stp->st_perstateowner"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&stp->st_stateowner->so_client->cl_lock"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n}"
  },
  {
    "function_name": "nfs4_put_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "906-918",
    "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sop->so_ops->so_free",
          "args": [
            "sop"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sop->so_owner.data"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sop->so_ops->so_unhash",
          "args": [
            "sop"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&sop->so_count",
            "&clp->cl_lock"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
  },
  {
    "function_name": "release_all_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "890-904",
    "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_access",
          "args": [
            "i",
            "stp"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "clear_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "794-801",
          "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "stp->st_stid.sc_file",
            "i"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "464-472",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "i",
            "stp"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "804-810",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalculate_deny_mode",
          "args": [
            "fp"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_deny_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "859-869",
          "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
  },
  {
    "function_name": "reset_union_bmap_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "871-887",
    "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalculate_deny_mode",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_deny_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "859-869",
          "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_deny",
          "args": [
            "i",
            "stp"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "clear_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "823-830",
          "snippet": "static inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
  },
  {
    "function_name": "recalculate_deny_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "859-869",
    "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap_to_share_mode",
          "args": [
            "stp->st_deny_bmap"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_to_share_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "771-781",
          "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stp",
            "&fp->fi_stateids",
            "st_perfile"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
  },
  {
    "function_name": "nfs4_access_to_omode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "841-853",
    "snippet": "static int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}"
  },
  {
    "function_name": "test_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "833-839",
    "snippet": "static inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}"
  },
  {
    "function_name": "clear_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "823-830",
    "snippet": "static inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "deny > NFS4_SHARE_DENY_BOTH"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}"
  },
  {
    "function_name": "set_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "813-820",
    "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "deny > NFS4_SHARE_DENY_BOTH"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
  },
  {
    "function_name": "test_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "804-810",
    "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
  },
  {
    "function_name": "clear_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "794-801",
    "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access > NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
  },
  {
    "function_name": "set_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "784-791",
    "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access > NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
  },
  {
    "function_name": "bmap_to_share_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "771-781",
    "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "&bmap"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
  },
  {
    "function_name": "clientstr_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "748-751",
    "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opaque_hashval",
          "args": [
            "name",
            "8"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "opaque_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "256-267",
          "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
  },
  {
    "function_name": "clientid_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "743-746",
    "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
  },
  {
    "function_name": "revoke_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "721-737",
    "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&clp->cl_revoked"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "663-676",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&dp->dl_recall_lru)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
  },
  {
    "function_name": "destroy_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "712-719",
    "snippet": "static void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tspin_lock(&state_lock);\n\tunhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\tnfs4_put_stid(&dp->dl_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "663-676",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tspin_lock(&state_lock);\n\tunhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\tnfs4_put_stid(&dp->dl_stid);\n}"
  },
  {
    "function_name": "unhash_delegation_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "695-710",
    "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_perfile"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_perclnt"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
  },
  {
    "function_name": "hash_delegation_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "683-693",
    "snippet": "static void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_perclnt",
            "&dp->dl_stid.sc_client->cl_delegations"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dp->dl_stid.sc_count"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &dp->dl_stid.sc_client->cl_delegations);\n}"
  },
  {
    "function_name": "nfs4_unhash_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "678-681",
    "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
  },
  {
    "function_name": "nfs4_put_deleg_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "663-676",
    "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "F_UNLCK",
            "NULL",
            "(void **)&fp"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "filp",
            "fp->fi_deleg_file"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
  },
  {
    "function_name": "nfs4_put_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "644-661",
    "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->sc_free",
          "args": [
            "s"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&clp->cl_stateids",
            "s->sc_stateid.si_opaque.so_id"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&close_wq"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&s->sc_count",
            "&clp->cl_lock"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
  },
  {
    "function_name": "alloc_init_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "608-642",
    "snippet": "static struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *deleg_slab;",
      "static struct nfsd4_callback_ops nfsd4_cb_recall_ops;",
      "static atomic_long_t num_delegations;",
      "unsigned long max_delegations;",
      "static struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&num_delegations"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&dp->dl_recall",
            "dp->dl_stid.sc_client",
            "&nfsd4_cb_recall_ops",
            "NFSPROC4_CLNT_CB_RECALL"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1092-1103",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_perclnt"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_perfile"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "nfs4_alloc_stid(clp, deleg_slab)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "151-154",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "deleg_slab"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "474-510",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegation_blocked",
          "args": [
            "&current_fh->fh_handle"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "delegation_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "558-589",
          "snippet": "static int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_delegations_lock);",
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&num_delegations"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD alloc_init_deleg\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *deleg_slab;\nstatic struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\nstatic struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}"
  },
  {
    "function_name": "block_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "591-606",
    "snippet": "static void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_delegations_lock);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "(hash>>16)&255",
            "bd->set[bd->new]"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "(hash>>8)&255",
            "bd->set[bd->new]"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "hash&255",
            "bd->set[bd->new]"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&fh->fh_base",
            "fh->fh_size",
            "0"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}"
  },
  {
    "function_name": "delegation_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "558-589",
    "snippet": "static int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_delegations_lock);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(hash>>16)&255",
            "bd->set[1]"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&fh->fh_base",
            "fh->fh_size",
            "0"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bd->set[bd->new]",
            "0",
            "sizeof(bd->set[0])"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_free_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "526-530",
    "snippet": "static void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *deleg_slab;",
      "static atomic_long_t num_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&num_delegations"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "deleg_slab",
            "stid"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *deleg_slab;\nstatic atomic_long_t num_delegations;\n\nstatic void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}"
  },
  {
    "function_name": "nfs4_alloc_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "512-524",
    "snippet": "static struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "534-537",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "stateid_slab"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "474-510",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}"
  },
  {
    "function_name": "nfs4_alloc_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "474-510",
    "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "slab",
            "stid"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&stid->sc_count",
            "1"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&cl->cl_stateids",
            "stid",
            "0",
            "0",
            "GFP_NOWAIT"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "slab",
            "GFP_KERNEL"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_file_put_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "464-472",
    "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_file_put_access",
          "args": [
            "fp",
            "O_RDONLY"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "445-462",
          "snippet": "static void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access & ~NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
  },
  {
    "function_name": "__nfs4_file_put_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "445-462",
    "snippet": "static void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f2"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "f2",
            "fp->fi_fds[O_RDWR]"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[1 - oflag]"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&fp->fi_access[oflag]",
            "&fp->fi_lock"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}"
  },
  {
    "function_name": "nfs4_file_check_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "426-443",
    "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[O_WRONLY]"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[O_RDONLY]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_file_get_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "409-424",
    "snippet": "static __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_file_get_access",
          "args": [
            "fp",
            "access"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "398-407",
          "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "__nfs4_file_get_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "398-407",
    "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fp->fi_access[O_RDONLY]"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fp->fi_access[O_WRONLY]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
  },
  {
    "function_name": "file_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "391-394",
    "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_fh_hashval",
          "args": [
            "fh"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_fh_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "386-389",
          "snippet": "static unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
  },
  {
    "function_name": "nfsd_fh_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "386-389",
    "snippet": "static unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "fh->fh_base.fh_pad",
            "XDR_QUADLEN(fh->fh_size)",
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "fh->fh_size"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}"
  },
  {
    "function_name": "ownerstr_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "374-380",
    "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opaque_hashval",
          "args": [
            "ownername->data",
            "ownername->len"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "opaque_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "256-267",
          "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
  },
  {
    "function_name": "find_any_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "346-360",
    "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDONLY"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "289-295",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_readable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "334-344",
    "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_readable_file_locked",
          "args": [
            "f"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "322-332",
          "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_readable_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "322-332",
    "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDWR"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "289-295",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&f->fi_lock"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_writeable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "310-320",
    "snippet": "static struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writeable_file_locked",
          "args": [
            "f"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "297-308",
          "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_writeable_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "297-308",
    "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDWR"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "289-295",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&f->fi_lock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
  },
  {
    "function_name": "__nfs4_get_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "289-295",
    "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "f->fi_fds[oflag]"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_nfs4_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "276-287",
    "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&fi->fi_rcu",
            "nfsd4_free_file_rcu"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&fi->fi_delegations)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->fi_delegations"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&fi->fi_hash"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&fi->fi_ref",
            "&state_lock"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&state_lock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_free_file_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "269-274",
    "snippet": "static void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_slab",
            "fp"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structnfs4_file",
            "fi_rcu"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}"
  },
  {
    "function_name": "opaque_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "256-267",
    "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
  },
  {
    "function_name": "find_openstateowner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "244-254",
    "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str_locked",
          "args": [
            "hashval",
            "open",
            "clp"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "226-242",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
  },
  {
    "function_name": "find_openstateowner_str_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "226-242",
    "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "nfs4_get_stateowner(so)"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6106-6128",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "212-217",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "so",
            "&open->op_owner"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "219-224",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "so",
            "&clp->cl_ownerstr_hashtbl[hashval]",
            "so_strhash"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "same_owner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "219-224",
    "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sop->so_owner.data",
            "owner->data",
            "owner->len"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
  },
  {
    "function_name": "nfs4_get_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "212-217",
    "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sop->so_count"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
  },
  {
    "function_name": "nfsd4_put_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "202-210",
    "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "ses"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "190-200",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "nfsd4_put_session_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "190-200",
    "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client_renew_locked",
          "args": [
            "clp"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "154-164",
          "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_session",
          "args": [
            "ses"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1395-1400",
          "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_session_dead",
          "args": [
            "ses"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "is_session_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "102-105",
          "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ses->se_ref"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
  },
  {
    "function_name": "nfsd4_get_session_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "177-188",
    "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ses->se_ref"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_client_locked",
          "args": [
            "ses->se_client"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "120-130",
          "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_session_dead",
          "args": [
            "ses"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "is_session_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "102-105",
          "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "put_client_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "166-175",
    "snippet": "static void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "133-152",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "115-118",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&clp->cl_refcount",
            "&nn->client_lock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "put_client_renew_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "154-164",
    "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "133-152",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "115-118",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "renew_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "133-152",
    "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&clp->cl_lru",
            "&nn->client_lru"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"renewing client (clientid %08x/%08x)\\n\"",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s: client (clientid %08x/%08x) already expired\\n\"",
            "__func__",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "115-118",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
  },
  {
    "function_name": "get_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "120-130",
    "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "115-118",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "is_client_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "115-118",
    "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
  },
  {
    "function_name": "mark_session_dead_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "107-113",
    "snippet": "static __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ses->se_ref"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "is_session_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
    "lines": "102-105",
    "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
  }
]