[
  {
    "function_name": "exit_vfat_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "1081-1084",
    "snippet": "static void __exit exit_vfat_fs(void)\n{\n\tunregister_filesystem(&vfat_fs_type);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&vfat_fs_type"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_vfat_fs(void)\n{\n\tunregister_filesystem(&vfat_fs_type);\n}"
  },
  {
    "function_name": "init_vfat_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "1076-1079",
    "snippet": "static int __init init_vfat_fs(void)\n{\n\treturn register_filesystem(&vfat_fs_type);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&vfat_fs_type"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic struct file_system_type vfat_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vfat\",\n\t.mount\t\t= vfat_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_vfat_fs(void)\n{\n\treturn register_filesystem(&vfat_fs_type);\n}"
  },
  {
    "function_name": "vfat_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "1060-1065",
    "snippet": "static struct dentry *vfat_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vfat_fill_super);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "vfat_fill_super"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic struct dentry *vfat_mount(struct file_system_type *fs_type,\n\t\t       int flags, const char *dev_name,\n\t\t       void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vfat_fill_super);\n}"
  },
  {
    "function_name": "vfat_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "1055-1058",
    "snippet": "static int vfat_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 1, setup);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_fill_super",
          "args": [
            "sb",
            "data",
            "silent",
            "1",
            "setup"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "fat_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1496-1783",
          "snippet": "int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;",
            "static int fat_show_options(struct seq_file *m, struct dentry *root);",
            "static const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\nstatic const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};\n\nint fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 1, setup);\n}"
  },
  {
    "function_name": "setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "1046-1053",
    "snippet": "static void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};",
      "static const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};",
      "static const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic const struct dentry_operations vfat_ci_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate_ci,\n\t.d_hash\t\t= vfat_hashi,\n\t.d_compare\t= vfat_cmpi,\n};\nstatic const struct dentry_operations vfat_dentry_ops = {\n\t.d_revalidate\t= vfat_revalidate,\n\t.d_hash\t\t= vfat_hash,\n\t.d_compare\t= vfat_cmp,\n};\nstatic const struct inode_operations vfat_dir_inode_operations = {\n\t.create\t\t= vfat_create,\n\t.lookup\t\t= vfat_lookup,\n\t.unlink\t\t= vfat_unlink,\n\t.mkdir\t\t= vfat_mkdir,\n\t.rmdir\t\t= vfat_rmdir,\n\t.rename\t\t= vfat_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\n\tif (MSDOS_SB(sb)->options.name_check != 's')\n\t\tsb->s_d_op = &vfat_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &vfat_dentry_ops;\n}"
  },
  {
    "function_name": "vfat_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "907-1033",
    "snippet": "static int vfat_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, is_dir, update_dotdot, corrupt = 0;\n\tstruct super_block *sb = old_dir->i_sb;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);\n\tif (err)\n\t\tgoto out;\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,\n\t\t\t\t     &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n \t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "new_dir->i_sb",
            "\"%s: Filesystem corrupted (i_pos %lld)\"",
            "__func__",
            "sinfo.i_pos"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "new_dir",
            "&sinfo"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "new_inode"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_attach",
          "args": [
            "new_inode",
            "new_i_pos"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "fat_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "369-395",
          "snippet": "void fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fat_show_options(struct seq_file *m, struct dentry *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "old_inode"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "dotdot_bh"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "dotdot_bh",
            "old_inode"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "dotdot_de",
            "MSDOS_I(old_dir)->i_logstart"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "old_dir"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "old_sinfo.bh"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_dir"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfat_add_entry",
          "args": [
            "new_dir",
            "&new_dentry->d_name",
            "is_dir",
            "0",
            "&ts",
            "&sinfo"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "657-691",
          "snippet": "static int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_empty",
          "args": [
            "new_inode"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "906-924",
          "snippet": "int fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_dotdot_entry",
          "args": [
            "old_inode",
            "&dotdot_bh",
            "&dotdot_de"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_dotdot_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "891-902",
          "snippet": "int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfat_find",
          "args": [
            "old_dir",
            "&old_dentry->d_name",
            "&old_sinfo"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "693-700",
          "snippet": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, is_dir, update_dotdot, corrupt = 0;\n\tstruct super_block *sb = old_dir->i_sb;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);\n\tif (err)\n\t\tgoto out;\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,\n\t\t\t\t     &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n \t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "vfat_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "861-905",
    "snippet": "static int vfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tint err, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = CURRENT_TIME_SEC;\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tdir->i_version++;\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t/* the directory was completed, just return a error */\n\t\tgoto out;\n\t}\n\tinode->i_version++;\n\tset_nlink(inode, 2);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "dir",
            "cluster"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_add_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "1",
            "cluster",
            "&ts",
            "&sinfo"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "657-691",
          "snippet": "static int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_alloc_new_dir",
          "args": [
            "dir",
            "&ts"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "fat_alloc_new_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1131-1190",
          "snippet": "int fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tint err, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = CURRENT_TIME_SEC;\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tdir->i_version++;\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t/* the directory was completed, just return a error */\n\t\tgoto out;\n\t}\n\tinode->i_version++;\n\tset_nlink(inode, 2);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "vfat_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "835-859",
    "snippet": "static int vfat_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\n\tdentry->d_time = dir->i_version;\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "inode"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "dir",
            "&sinfo"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_find",
          "args": [
            "dir",
            "&dentry->d_name",
            "&sinfo"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "693-700",
          "snippet": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\n\tdentry->d_time = dir->i_version;\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "vfat_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "804-833",
    "snippet": "static int vfat_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\n\tdentry->d_time = dir->i_version;\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "dir",
            "&sinfo"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_find",
          "args": [
            "dir",
            "&dentry->d_name",
            "&sinfo"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "693-700",
          "snippet": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_empty",
          "args": [
            "inode"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "906-924",
          "snippet": "int fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\n\tdentry->d_time = dir->i_version;\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "vfat_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "771-802",
    "snippet": "static int vfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = CURRENT_TIME_SEC;\n\terr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tdir->i_version++;\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_add_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "0",
            "0",
            "&ts",
            "&sinfo"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "657-691",
          "snippet": "static int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\tts = CURRENT_TIME_SEC;\n\terr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tdir->i_version++;\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "vfat_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "711-769",
    "snippet": "static struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tstruct dentry *alias;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto error;\n\t}\n\n\talias = d_find_alias(inode);\n\t/*\n\t * Checking \"alias->d_parent == dentry->d_parent\" to make sure\n\t * FS is not corrupted (especially double linked dir).\n\t */\n\tif (alias && alias->d_parent == dentry->d_parent &&\n\t    !vfat_d_anon_disconn(alias)) {\n\t\t/*\n\t\t * This inode has non anonymous-DCACHE_DISCONNECTED\n\t\t * dentry. This means, the user did ->lookup() by an\n\t\t * another name (longname vs 8.3 alias of it) in past.\n\t\t *\n\t\t * Switch to new one for reason of locality if possible.\n\t\t */\n\t\tBUG_ON(d_unhashed(alias));\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\td_move(alias, dentry);\n\t\tiput(inode);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t\treturn alias;\n\t} else\n\t\tdput(alias);\n\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!inode)\n\t\tdentry->d_time = dir->i_version;\n\treturn d_splice_alias(inode, dentry);\nerror:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "alias"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "alias",
            "dentry"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "d_unhashed(alias)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "alias"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfat_d_anon_disconn",
          "args": [
            "alias"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_d_anon_disconn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "706-709",
          "snippet": "static int vfat_d_anon_disconn(struct dentry *dentry)\n{\n\treturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_d_anon_disconn(struct dentry *dentry)\n{\n\treturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_find",
          "args": [
            "dir",
            "&dentry->d_name",
            "&sinfo"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "693-700",
          "snippet": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tstruct dentry *alias;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = vfat_find(dir, &dentry->d_name, &sinfo);\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto error;\n\t}\n\n\talias = d_find_alias(inode);\n\t/*\n\t * Checking \"alias->d_parent == dentry->d_parent\" to make sure\n\t * FS is not corrupted (especially double linked dir).\n\t */\n\tif (alias && alias->d_parent == dentry->d_parent &&\n\t    !vfat_d_anon_disconn(alias)) {\n\t\t/*\n\t\t * This inode has non anonymous-DCACHE_DISCONNECTED\n\t\t * dentry. This means, the user did ->lookup() by an\n\t\t * another name (longname vs 8.3 alias of it) in past.\n\t\t *\n\t\t * Switch to new one for reason of locality if possible.\n\t\t */\n\t\tBUG_ON(d_unhashed(alias));\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\td_move(alias, dentry);\n\t\tiput(inode);\n\t\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\t\treturn alias;\n\t} else\n\t\tdput(alias);\n\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!inode)\n\t\tdentry->d_time = dir->i_version;\n\treturn d_splice_alias(inode, dentry);\nerror:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "vfat_d_anon_disconn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "706-709",
    "snippet": "static int vfat_d_anon_disconn(struct dentry *dentry)\n{\n\treturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_d_anon_disconn(struct dentry *dentry)\n{\n\treturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\n}"
  },
  {
    "function_name": "vfat_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "693-700",
    "snippet": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_search_long",
          "args": [
            "dir",
            "qname->name",
            "len",
            "sinfo"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "fat_search_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "466-542",
          "snippet": "int fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t    int name_len, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tloff_t cpos = 0;\n\tint err, len;\n\n\terr = -ENOENT;\n\twhile (1) {\n\t\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\t\tgoto end_of_dir;\nparse_record:\n\t\tnr_slots = 0;\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tcontinue;\n\t\tif (de->attr == ATTR_EXT) {\n\t\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t\t    &unicode, &nr_slots);\n\t\t\tif (status < 0) {\n\t\t\t\terr = status;\n\t\t\t\tgoto end_of_dir;\n\t\t\t} else if (status == PARSE_INVALID)\n\t\t\t\tcontinue;\n\t\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\t\tgoto parse_record;\n\t\t\telse if (status == PARSE_EOF)\n\t\t\t\tgoto end_of_dir;\n\t\t}\n\n\t\t/* Never prepend '.' to hidden files here.\n\t\t * That is done only for msdos mounts (and only when\n\t\t * 'dotsOK=yes'); if we are executing here, it is in the\n\t\t * context of a vfat mount.\n\t\t */\n\t\tlen = fat_parse_short(sb, de, bufname, 0);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Compare shortname */\n\t\tif (fat_name_match(sbi, name, name_len, bufname, len))\n\t\t\tgoto found;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\n\t\t\t/* Compare longname */\n\t\t\tlen = fat_uni_to_x8(sb, unicode, longname, size);\n\t\t\tif (fat_name_match(sbi, name, name_len, longname, len))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tnr_slots++;\t/* include the de */\n\tsinfo->slot_off = cpos - nr_slots * sizeof(*de);\n\tsinfo->nr_slots = nr_slots;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\terr = 0;\nend_of_dir:\n\tif (unicode)\n\t\t__putname(unicode);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))",
            "#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)",
            "#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define FAT_MAX_UNI_SIZE\t(FAT_MAX_UNI_CHARS * sizeof(wchar_t))\n#define FAT_MAX_UNI_CHARS\t((MSDOS_SLOTS - 1) * 13 + 1)\n#define FAT_MAX_SHORT_SIZE\t((MSDOS_NAME + 1) * NLS_MAX_CHARSET_SIZE + 1)\n\nint fat_search_long(struct inode *inode, const unsigned char *name,\n\t\t    int name_len, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tunsigned char nr_slots;\n\twchar_t *unicode = NULL;\n\tunsigned char bufname[FAT_MAX_SHORT_SIZE];\n\tloff_t cpos = 0;\n\tint err, len;\n\n\terr = -ENOENT;\n\twhile (1) {\n\t\tif (fat_get_entry(inode, &cpos, &bh, &de) == -1)\n\t\t\tgoto end_of_dir;\nparse_record:\n\t\tnr_slots = 0;\n\t\tif (de->name[0] == DELETED_FLAG)\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && (de->attr & ATTR_VOLUME))\n\t\t\tcontinue;\n\t\tif (de->attr != ATTR_EXT && IS_FREE(de->name))\n\t\t\tcontinue;\n\t\tif (de->attr == ATTR_EXT) {\n\t\t\tint status = fat_parse_long(inode, &cpos, &bh, &de,\n\t\t\t\t\t\t    &unicode, &nr_slots);\n\t\t\tif (status < 0) {\n\t\t\t\terr = status;\n\t\t\t\tgoto end_of_dir;\n\t\t\t} else if (status == PARSE_INVALID)\n\t\t\t\tcontinue;\n\t\t\telse if (status == PARSE_NOT_LONGNAME)\n\t\t\t\tgoto parse_record;\n\t\t\telse if (status == PARSE_EOF)\n\t\t\t\tgoto end_of_dir;\n\t\t}\n\n\t\t/* Never prepend '.' to hidden files here.\n\t\t * That is done only for msdos mounts (and only when\n\t\t * 'dotsOK=yes'); if we are executing here, it is in the\n\t\t * context of a vfat mount.\n\t\t */\n\t\tlen = fat_parse_short(sb, de, bufname, 0);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Compare shortname */\n\t\tif (fat_name_match(sbi, name, name_len, bufname, len))\n\t\t\tgoto found;\n\n\t\tif (nr_slots) {\n\t\t\tvoid *longname = unicode + FAT_MAX_UNI_CHARS;\n\t\t\tint size = PATH_MAX - FAT_MAX_UNI_SIZE;\n\n\t\t\t/* Compare longname */\n\t\t\tlen = fat_uni_to_x8(sb, unicode, longname, size);\n\t\t\tif (fat_name_match(sbi, name, name_len, longname, len))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\nfound:\n\tnr_slots++;\t/* include the de */\n\tsinfo->slot_off = cpos - nr_slots * sizeof(*de);\n\tsinfo->nr_slots = nr_slots;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\terr = 0;\nend_of_dir:\n\tif (unicode)\n\t\t__putname(unicode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "qname"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}"
  },
  {
    "function_name": "vfat_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "657-691",
    "snippet": "static int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "slots"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "dir"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_add_entries",
          "args": [
            "dir",
            "slots",
            "nr_slots",
            "sinfo"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "fat_add_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1273-1405",
          "snippet": "int fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_build_slots",
          "args": [
            "dir",
            "qname->name",
            "len",
            "is_dir",
            "cluster",
            "ts",
            "slots",
            "&nr_slots"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_build_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "580-655",
          "snippet": "static int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t/* build the entry of long file name */\n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t/* build the entry of 8.3 alias name */\n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t/* build the entry of long file name */\n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t/* build the entry of 8.3 alias name */\n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*slots) * MSDOS_SLOTS",
            "GFP_NOFS"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "qname"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\n\t\t\t  int cluster, struct timespec *ts,\n\t\t\t  struct fat_slot_info *sinfo)\n{\n\tstruct msdos_dir_slot *slots;\n\tunsigned int len;\n\tint err, nr_slots;\n\n\tlen = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\n\tslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\n\tif (slots == NULL)\n\t\treturn -ENOMEM;\n\n\terr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\n\t\t\t       slots, &nr_slots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = fat_add_entries(dir, slots, nr_slots, sinfo);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* update timestamp */\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\ncleanup:\n\tkfree(slots);\n\treturn err;\n}"
  },
  {
    "function_name": "vfat_build_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "580-655",
    "snippet": "static int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t/* build the entry of long file name */\n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t/* build the entry of 8.3 alias name */\n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "uname"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "de",
            "cluster"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_time_unix2fat",
          "args": [
            "sbi",
            "ts",
            "&time",
            "&date",
            "&time_cs"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "fat_time_unix2fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "231-266",
          "snippet": "void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SECS_PER_MIN\t60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define SECS_PER_MIN\t60\n\nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "msdos_name",
            "MSDOS_NAME"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatwchar_to16",
          "args": [
            "ps->name11_12",
            "uname + offset + 11",
            "2"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "fatwchar_to16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "273-285",
          "snippet": "static inline void fatwchar_to16(__u8 *dst, const wchar_t *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\tdst[0] = *src & 0x00FF;\n\t\tdst[1] = (*src & 0xFF00) >> 8;\n\t\tdst += 2;\n\t\tsrc++;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatwchar_to16(__u8 *dst, const wchar_t *src, size_t len)\n{\n#ifdef __BIG_ENDIAN\n\twhile (len--) {\n\t\tdst[0] = *src & 0x00FF;\n\t\tdst[1] = (*src & 0xFF00) >> 8;\n\t\tdst += 2;\n\t\tsrc++;\n\t}\n#else\n\tmemcpy(dst, src, len * 2);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_checksum",
          "args": [
            "msdos_name"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "fat_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "208-217",
          "snippet": "static inline unsigned char fat_checksum(const __u8 *name)\n{\n\tunsigned char s = name[0];\n\ts = (s<<7) + (s>>1) + name[1];\ts = (s<<7) + (s>>1) + name[2];\n\ts = (s<<7) + (s>>1) + name[3];\ts = (s<<7) + (s>>1) + name[4];\n\ts = (s<<7) + (s>>1) + name[5];\ts = (s<<7) + (s>>1) + name[6];\n\ts = (s<<7) + (s>>1) + name[7];\ts = (s<<7) + (s>>1) + name[8];\n\ts = (s<<7) + (s>>1) + name[9];\ts = (s<<7) + (s>>1) + name[10];\n\treturn s;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline unsigned char fat_checksum(const __u8 *name)\n{\n\tunsigned char s = name[0];\n\ts = (s<<7) + (s>>1) + name[1];\ts = (s<<7) + (s>>1) + name[2];\n\ts = (s<<7) + (s>>1) + name[3];\ts = (s<<7) + (s>>1) + name[4];\n\ts = (s<<7) + (s>>1) + name[5];\ts = (s<<7) + (s>>1) + name[6];\n\ts = (s<<7) + (s>>1) + name[7];\ts = (s<<7) + (s>>1) + name[8];\n\ts = (s<<7) + (s>>1) + name[9];\ts = (s<<7) + (s>>1) + name[10];\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_create_shortname",
          "args": [
            "dir",
            "sbi->nls_disk",
            "uname",
            "ulen",
            "msdos_name",
            "&lcase"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_create_shortname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "315-495",
          "snippet": "static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t/* Now, we need to create a shortname from the long name */\n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t/* is `.' */\n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t/*\n\t\t * Names which start with a dot could be just\n\t\t * an extension eg. \"...test\".  In this case Win95\n\t\t * uses the extension as the name and sets no extension.\n\t\t */\n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t/* Yes, it can happen. \".\\xe5\" would do it. */\n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t/* OK, at this point we know that base is not longer than 8 symbols,\n\t * ext is not longer than 3, base is nonempty, both don't contain\n\t * any bad symbols (lowercase transformed to uppercase).\n\t */\n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t/*\n\t * Try to find a unique extension.  This used to\n\t * iterate through all possibilities sequentially,\n\t * but that gave extremely bad performance.  Windows\n\t * only tries a few cases before using random\n\t * values for part of the base.\n\t */\n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t/* Now, we need to create a shortname from the long name */\n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t/* is `.' */\n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t/*\n\t\t * Names which start with a dot could be just\n\t\t * an extension eg. \"...test\".  In this case Win95\n\t\t * uses the extension as the name and sets no extension.\n\t\t */\n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t/* Yes, it can happen. \".\\xe5\" would do it. */\n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t/* OK, at this point we know that base is not longer than 8 symbols,\n\t * ext is not longer than 3, base is nonempty, both don't contain\n\t * any bad symbols (lowercase transformed to uppercase).\n\t */\n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t/*\n\t * Try to find a unique extension.  This used to\n\t * iterate through all possibilities sequentially,\n\t * but that gave extremely bad performance.  Windows\n\t * only tries a few cases before using random\n\t * values for part of the base.\n\t */\n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_is_used_badchars",
          "args": [
            "uname",
            "ulen"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_is_used_badchars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "210-222",
          "snippet": "static inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ') /* last character cannot be space */\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ') /* last character cannot be space */\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlate_to_uni",
          "args": [
            "name",
            "len",
            "(unsigned char *)uname",
            "&ulen",
            "&usize",
            "opts->unicode_xlate",
            "opts->utf8",
            "sbi->nls_io"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "xlate_to_uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "498-578",
          "snippet": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tec = 0;\n\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\tnc = ip[k];\n\t\t\t\t\tec <<= 4;\n\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t*op++ = ec >> 8;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tec = 0;\n\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\tnc = ip[k];\n\t\t\t\t\tec <<= 4;\n\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t*op++ = ec >> 8;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_build_slots(struct inode *dir, const unsigned char *name,\n\t\t\t    int len, int is_dir, int cluster,\n\t\t\t    struct timespec *ts,\n\t\t\t    struct msdos_dir_slot *slots, int *nr_slots)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct fat_mount_options *opts = &sbi->options;\n\tstruct msdos_dir_slot *ps;\n\tstruct msdos_dir_entry *de;\n\tunsigned char cksum, lcase;\n\tunsigned char msdos_name[MSDOS_NAME];\n\twchar_t *uname;\n\t__le16 time, date;\n\tu8 time_cs;\n\tint err, ulen, usize, i;\n\tloff_t offset;\n\n\t*nr_slots = 0;\n\n\tuname = __getname();\n\tif (!uname)\n\t\treturn -ENOMEM;\n\n\terr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\n\t\t\t   opts->unicode_xlate, opts->utf8, sbi->nls_io);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_is_used_badchars(uname, ulen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\n\t\t\t\t    msdos_name, &lcase);\n\tif (err < 0)\n\t\tgoto out_free;\n\telse if (err == 1) {\n\t\tde = (struct msdos_dir_entry *)slots;\n\t\terr = 0;\n\t\tgoto shortname;\n\t}\n\n\t/* build the entry of long file name */\n\tcksum = fat_checksum(msdos_name);\n\n\t*nr_slots = usize / 13;\n\tfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\n\t\tps->id = i;\n\t\tps->attr = ATTR_EXT;\n\t\tps->reserved = 0;\n\t\tps->alias_checksum = cksum;\n\t\tps->start = 0;\n\t\toffset = (i - 1) * 13;\n\t\tfatwchar_to16(ps->name0_4, uname + offset, 5);\n\t\tfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\n\t\tfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\n\t}\n\tslots[0].id |= 0x40;\n\tde = (struct msdos_dir_entry *)ps;\n\nshortname:\n\t/* build the entry of 8.3 alias name */\n\t(*nr_slots)++;\n\tmemcpy(de->name, msdos_name, MSDOS_NAME);\n\tde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tde->lcase = lcase;\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\tde->time = de->ctime = time;\n\tde->date = de->cdate = de->adate = date;\n\tde->ctime_cs = time_cs;\n\tfat_set_start(de, cluster);\n\tde->size = 0;\nout_free:\n\t__putname(uname);\n\treturn err;\n}"
  },
  {
    "function_name": "xlate_to_uni",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "498-578",
    "snippet": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tec = 0;\n\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\tnc = ip[k];\n\t\t\t\t\tec <<= 4;\n\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t*op++ = ec >> 8;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nls->char2uni",
          "args": [
            "ip",
            "len - i",
            "(wchar_t *)op"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utf8s_to_utf16s",
          "args": [
            "name",
            "len",
            "UTF16_HOST_ENDIAN",
            "(wchar_t *) outname",
            "FAT_LFN_LEN + 2"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "utf8s_to_utf16s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "132-171",
          "snippet": "int utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxout)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (inlen > 0 && maxout > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, inlen, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tinlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxout < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxout -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxout--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tinlen--;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SURROGATE_BITS\t0x000003ff",
            "#define SURROGATE_LOW\t0x00000400",
            "#define SURROGATE_PAIR\t0x0000d800",
            "#define PLANE_SIZE\t0x00010000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define SURROGATE_BITS\t0x000003ff\n#define SURROGATE_LOW\t0x00000400\n#define SURROGATE_PAIR\t0x0000d800\n#define PLANE_SIZE\t0x00010000\n\nint utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxout)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (inlen > 0 && maxout > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, inlen, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tinlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxout < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxout -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxout--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tinlen--;\n\t\t\tmaxout--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t i < len && *outlen < FAT_LFN_LEN;\n\t\t\t *outlen += 1) {\n\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\tif (i > len - 5)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tec = 0;\n\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\tnc = ip[k];\n\t\t\t\t\tec <<= 4;\n\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t*op++ = ec >> 8;\n\t\t\t\tip += 5;\n\t\t\t\ti += 5;\n\t\t\t} else {\n\t\t\t\tcharlen = nls->char2uni(ip, len - i,\n\t\t\t\t\t\t\t\t\t(wchar_t *)op);\n\t\t\t\tif (charlen < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tip += charlen;\n\t\t\t\ti += charlen;\n\t\t\t\top += 2;\n\t\t\t}\n\t\t}\n\t\tif (i < len)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vfat_create_shortname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "315-495",
    "snippet": "static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t/* Now, we need to create a shortname from the long name */\n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t/* is `.' */\n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t/*\n\t\t * Names which start with a dot could be just\n\t\t * an extension eg. \"...test\".  In this case Win95\n\t\t * uses the extension as the name and sets no extension.\n\t\t */\n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t/* Yes, it can happen. \".\\xe5\" would do it. */\n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t/* OK, at this point we know that base is not longer than 8 symbols,\n\t * ext is not longer than 3, base is nonempty, both don't contain\n\t * any bad symbols (lowercase transformed to uppercase).\n\t */\n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t/*\n\t * Try to find a unique extension.  This used to\n\t * iterate through all possibilities sequentially,\n\t * but that gave extremely bad performance.  Windows\n\t * only tries a few cases before using random\n\t * values for part of the base.\n\t */\n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfat_find_form",
          "args": [
            "dir",
            "name_res"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_find_form",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "224-232",
          "snippet": "static int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&name_res[baselen]",
            "buf",
            "4"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%04X\"",
            "i & 0xffff"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name_res + 8",
            "ext",
            "extlen"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name_res",
            "base",
            "baselen"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name_res",
            "' '",
            "MSDOS_NAME"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_shortname_char",
          "args": [
            "nls",
            "charbuf",
            "sizeof(charbuf)",
            "ip",
            "&ext_info"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "to_shortname_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "265-307",
          "snippet": "static inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_skip_char",
          "args": [
            "*name_start"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_skip_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "205-208",
          "snippet": "static wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_SHORTNAME_INFO",
          "args": [
            "&ext_info"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_SHORTNAME_INFO",
          "args": [
            "&base_info"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\n\t\t\t\t wchar_t *uname, int ulen,\n\t\t\t\t unsigned char *name_res, unsigned char *lcase)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\n\twchar_t *ip, *ext_start, *end, *name_start;\n\tunsigned char base[9], ext[4], buf[5], *p;\n\tunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\n\tint chl, chi;\n\tint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\n\tint is_shortname;\n\tstruct shortname_info base_info, ext_info;\n\n\tis_shortname = 1;\n\tINIT_SHORTNAME_INFO(&base_info);\n\tINIT_SHORTNAME_INFO(&ext_info);\n\n\t/* Now, we need to create a shortname from the long name */\n\text_start = end = &uname[ulen];\n\twhile (--ext_start >= uname) {\n\t\tif (*ext_start == 0x002E) {\t/* is `.' */\n\t\t\tif (ext_start == end - 1) {\n\t\t\t\tsz = ulen;\n\t\t\t\text_start = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ext_start == uname - 1) {\n\t\tsz = ulen;\n\t\text_start = NULL;\n\t} else if (ext_start) {\n\t\t/*\n\t\t * Names which start with a dot could be just\n\t\t * an extension eg. \"...test\".  In this case Win95\n\t\t * uses the extension as the name and sets no extension.\n\t\t */\n\t\tname_start = &uname[0];\n\t\twhile (name_start < ext_start) {\n\t\t\tif (!vfat_skip_char(*name_start))\n\t\t\t\tbreak;\n\t\t\tname_start++;\n\t\t}\n\t\tif (name_start != ext_start) {\n\t\t\tsz = ext_start - uname;\n\t\t\text_start++;\n\t\t} else {\n\t\t\tsz = ulen;\n\t\t\text_start = NULL;\n\t\t}\n\t}\n\n\tnumtail_baselen = 6;\n\tnumtail2_baselen = 2;\n\tfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\n\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\tip, &base_info);\n\t\tif (chl == 0)\n\t\t\tcontinue;\n\n\t\tif (baselen < 2 && (baselen + chl) > 2)\n\t\t\tnumtail2_baselen = baselen;\n\t\tif (baselen < 6 && (baselen + chl) > 6)\n\t\t\tnumtail_baselen = baselen;\n\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t*p++ = charbuf[chi];\n\t\t\tbaselen++;\n\t\t\tif (baselen >= 8)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (baselen >= 8) {\n\t\t\tif ((chi < chl - 1) || (ip + 1) - uname < sz)\n\t\t\t\tis_shortname = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (baselen == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\textlen = 0;\n\tif (ext_start) {\n\t\tfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\n\t\t\tchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\n\t\t\t\t\t\tip, &ext_info);\n\t\t\tif (chl == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((extlen + chl) > 3) {\n\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (chi = 0; chi < chl; chi++) {\n\t\t\t\t*p++ = charbuf[chi];\n\t\t\t\textlen++;\n\t\t\t}\n\t\t\tif (extlen >= 3) {\n\t\t\t\tif (ip + 1 != end)\n\t\t\t\t\tis_shortname = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\text[extlen] = '\\0';\n\tbase[baselen] = '\\0';\n\n\t/* Yes, it can happen. \".\\xe5\" would do it. */\n\tif (base[0] == DELETED_FLAG)\n\t\tbase[0] = 0x05;\n\n\t/* OK, at this point we know that base is not longer than 8 symbols,\n\t * ext is not longer than 3, base is nonempty, both don't contain\n\t * any bad symbols (lowercase transformed to uppercase).\n\t */\n\n\tmemset(name_res, ' ', MSDOS_NAME);\n\tmemcpy(name_res, base, baselen);\n\tmemcpy(name_res + 8, ext, extlen);\n\t*lcase = 0;\n\tif (is_shortname && base_info.valid && ext_info.valid) {\n\t\tif (vfat_find_form(dir, name_res) == 0)\n\t\t\treturn -EEXIST;\n\n\t\tif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\n\t\t\treturn (base_info.upper && ext_info.upper);\n\t\t} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\n\t\t\tif ((base_info.upper || base_info.lower) &&\n\t\t\t    (ext_info.upper || ext_info.lower)) {\n\t\t\t\tif (!base_info.upper && base_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_BASE;\n\t\t\t\tif (!ext_info.upper && ext_info.lower)\n\t\t\t\t\t*lcase |= CASE_LOWER_EXT;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (opts->numtail == 0)\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\n\t/*\n\t * Try to find a unique extension.  This used to\n\t * iterate through all possibilities sequentially,\n\t * but that gave extremely bad performance.  Windows\n\t * only tries a few cases before using random\n\t * values for part of the base.\n\t */\n\n\tif (baselen > 6) {\n\t\tbaselen = numtail_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen] = '~';\n\tfor (i = 1; i < 10; i++) {\n\t\tname_res[baselen + 1] = i + '0';\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\treturn 0;\n\t}\n\n\ti = jiffies;\n\tsz = (jiffies >> 16) & 0x7;\n\tif (baselen > 2) {\n\t\tbaselen = numtail2_baselen;\n\t\tname_res[7] = ' ';\n\t}\n\tname_res[baselen + 4] = '~';\n\tname_res[baselen + 5] = '1' + sz;\n\twhile (1) {\n\t\tsnprintf(buf, sizeof(buf), \"%04X\", i & 0xffff);\n\t\tmemcpy(&name_res[baselen], buf, 4);\n\t\tif (vfat_find_form(dir, name_res) < 0)\n\t\t\tbreak;\n\t\ti -= 11;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "to_shortname_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "265-307",
    "snippet": "static inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "buf[0]"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls_toupper",
          "args": [
            "nls",
            "buf[0]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls->uni2char",
          "args": [
            "*src",
            "buf",
            "buf_size"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_replace_char",
          "args": [
            "*src"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_replace_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "199-203",
          "snippet": "static inline wchar_t vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline wchar_t vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_skip_char",
          "args": [
            "*src"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_skip_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "205-208",
          "snippet": "static wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline int to_shortname_char(struct nls_table *nls,\n\t\t\t\t    unsigned char *buf, int buf_size,\n\t\t\t\t    wchar_t *src, struct shortname_info *info)\n{\n\tint len;\n\n\tif (vfat_skip_char(*src)) {\n\t\tinfo->valid = 0;\n\t\treturn 0;\n\t}\n\tif (vfat_replace_char(*src)) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\treturn 1;\n\t}\n\n\tlen = nls->uni2char(*src, buf, buf_size);\n\tif (len <= 0) {\n\t\tinfo->valid = 0;\n\t\tbuf[0] = '_';\n\t\tlen = 1;\n\t} else if (len == 1) {\n\t\tunsigned char prev = buf[0];\n\n\t\tif (buf[0] >= 0x7F) {\n\t\t\tinfo->lower = 0;\n\t\t\tinfo->upper = 0;\n\t\t}\n\n\t\tbuf[0] = nls_toupper(nls, buf[0]);\n\t\tif (isalpha(buf[0])) {\n\t\t\tif (buf[0] == prev)\n\t\t\t\tinfo->lower = 0;\n\t\t\telse\n\t\t\t\tinfo->upper = 0;\n\t\t}\n\t} else {\n\t\tinfo->lower = 0;\n\t\tinfo->upper = 0;\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "vfat_find_form",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "224-232",
    "snippet": "static int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_scan",
          "args": [
            "dir",
            "name",
            "&sinfo"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_find_form(struct inode *dir, unsigned char *name)\n{\n\tstruct fat_slot_info sinfo;\n\tint err = fat_scan(dir, name, &sinfo);\n\tif (err)\n\t\treturn -ENOENT;\n\tbrelse(sinfo.bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "vfat_is_used_badchars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "210-222",
    "snippet": "static inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ') /* last character cannot be space */\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfat_bad_char",
          "args": [
            "s[i]"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_bad_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "191-197",
          "snippet": "static inline wchar_t vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline wchar_t vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline int vfat_is_used_badchars(const wchar_t *s, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vfat_bad_char(s[i]))\n\t\t\treturn -EINVAL;\n\n\tif (s[i - 1] == ' ') /* last character cannot be space */\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vfat_skip_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "205-208",
    "snippet": "static wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic wchar_t vfat_skip_char(wchar_t w)\n{\n\treturn (w == '.') || (w == ' ');\n}"
  },
  {
    "function_name": "vfat_replace_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "199-203",
    "snippet": "static inline wchar_t vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline wchar_t vfat_replace_char(wchar_t w)\n{\n\treturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\n\t    || (w == '+') || (w == '=');\n}"
  },
  {
    "function_name": "vfat_bad_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "191-197",
    "snippet": "static inline wchar_t vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic inline wchar_t vfat_bad_char(wchar_t w)\n{\n\treturn (w < 0x0020)\n\t    || (w == '*') || (w == '?') || (w == '<') || (w == '>')\n\t    || (w == '|') || (w == '\"') || (w == ':') || (w == '/')\n\t    || (w == '\\\\');\n}"
  },
  {
    "function_name": "vfat_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "162-175",
    "snippet": "static int vfat_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name->name",
            "str",
            "alen"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfat_striptail_len",
          "args": [
            "len",
            "str"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "92-97",
          "snippet": "static unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "name"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "vfat_cmpi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "143-157",
    "snippet": "static int vfat_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *t = MSDOS_SB(parent->d_sb)->nls_io;\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (nls_strnicmp(t, name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nls_strnicmp",
          "args": [
            "t",
            "name->name",
            "str",
            "alen"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfat_striptail_len",
          "args": [
            "len",
            "str"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "92-97",
          "snippet": "static unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "name"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "parent->d_sb"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *t = MSDOS_SB(parent->d_sb)->nls_io;\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (nls_strnicmp(t, name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "vfat_hashi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "122-138",
    "snippet": "static int vfat_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tconst unsigned char *name;\n\tunsigned int len;\n\tunsigned long hash;\n\n\tname = qstr->name;\n\tlen = vfat_striptail_len(qstr);\n\n\thash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(nls_tolower(t, *name++), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "nls_tolower(t, *name++)",
            "hash"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls_tolower",
          "args": [
            "t",
            "*name++"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "qstr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\n\tconst unsigned char *name;\n\tunsigned int len;\n\tunsigned long hash;\n\n\tname = qstr->name;\n\tlen = vfat_striptail_len(qstr);\n\n\thash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(nls_tolower(t, *name++), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vfat_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "110-114",
    "snippet": "static int vfat_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tqstr->hash = full_name_hash(qstr->name, vfat_striptail_len(qstr));\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "qstr->name",
            "vfat_striptail_len(qstr)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfat_striptail_len",
          "args": [
            "qstr"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "99-102",
          "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tqstr->hash = full_name_hash(qstr->name, vfat_striptail_len(qstr));\n\treturn 0;\n}"
  },
  {
    "function_name": "vfat_striptail_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "99-102",
    "snippet": "static unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfat_striptail_len",
          "args": [
            "qstr->len",
            "qstr->name"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__vfat_striptail_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "92-97",
          "snippet": "static unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\n{\n\treturn __vfat_striptail_len(qstr->len, qstr->name);\n}"
  },
  {
    "function_name": "__vfat_striptail_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "92-97",
    "snippet": "static unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\n{\n\twhile (len && name[len - 1] == '.')\n\t\tlen--;\n\treturn len;\n}"
  },
  {
    "function_name": "vfat_revalidate_ci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "55-89",
    "snippet": "static int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/*\n\t * This is not negative dentry. Always valid.\n\t *\n\t * Note, rename() to existing directory entry will have ->d_inode,\n\t * and will use existing name which isn't specified name by user.\n\t *\n\t * We may be able to drop this positive dentry here. But dropping\n\t * positive dentry isn't good idea. So it's unsupported like\n\t * rename(\"filename\", \"FILENAME\") for now.\n\t */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\treturn vfat_revalidate_shortname(dentry);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfat_revalidate_shortname",
          "args": [
            "dentry"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_revalidate_shortname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "34-42",
          "snippet": "static int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/*\n\t * This is not negative dentry. Always valid.\n\t *\n\t * Note, rename() to existing directory entry will have ->d_inode,\n\t * and will use existing name which isn't specified name by user.\n\t *\n\t * We may be able to drop this positive dentry here. But dropping\n\t * positive dentry isn't good idea. So it's unsupported like\n\t * rename(\"filename\", \"FILENAME\") for now.\n\t */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\treturn vfat_revalidate_shortname(dentry);\n}"
  },
  {
    "function_name": "vfat_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "44-53",
    "snippet": "static int vfat_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/* This is not negative dentry. Always valid. */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\treturn vfat_revalidate_shortname(dentry);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfat_revalidate_shortname",
          "args": [
            "dentry"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "vfat_revalidate_shortname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
          "lines": "34-42",
          "snippet": "static int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\t/* This is not negative dentry. Always valid. */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\treturn vfat_revalidate_shortname(dentry);\n}"
  },
  {
    "function_name": "vfat_revalidate_shortname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_vfat.c",
    "lines": "34-42",
    "snippet": "static int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/namei.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\nstatic int vfat_revalidate_shortname(struct dentry *dentry)\n{\n\tint ret = 1;\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_time != dentry->d_parent->d_inode->i_version)\n\t\tret = 0;\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
  }
]