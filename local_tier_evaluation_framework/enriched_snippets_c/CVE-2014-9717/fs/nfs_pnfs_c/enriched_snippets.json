[
  {
    "function_name": "pnfs_mdsthreshold_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2261-2271",
    "snippet": "struct nfs4_threshold *pnfs_mdsthreshold_alloc(void)\n{\n\tstruct nfs4_threshold *thp;\n\n\tthp = kzalloc(sizeof(*thp), GFP_NOFS);\n\tif (!thp) {\n\t\tdprintk(\"%s mdsthreshold allocation failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\treturn thp;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s mdsthreshold allocation failed\\n\"",
            "__func__"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*thp)",
            "GFP_NOFS"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_threshold *pnfs_mdsthreshold_alloc(void)\n{\n\tstruct nfs4_threshold *thp;\n\n\tthp = kzalloc(sizeof(*thp), GFP_NOFS);\n\tif (!thp) {\n\t\tdprintk(\"%s mdsthreshold allocation failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\treturn thp;\n}"
  },
  {
    "function_name": "pnfs_layoutcommit_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2178-2258",
    "snippet": "int\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_clear_layoutcommitting",
          "args": [
            "inode"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_layoutcommitting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2059-2066",
          "snippet": "static void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s status %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_layoutcommit",
          "args": [
            "data",
            "sync"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "8037-8080",
          "snippet": "int\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: %4d initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\",\n\t\tdata->task.tk_pid, sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tif (!sync) {\n\t\tdata->inode = nfs_igrab_and_active(data->args.inode);\n\t\tif (data->inode == NULL) {\n\t\t\tnfs4_layoutcommit_release(data);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags = RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutcommit(data->args.inode, status);\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _nfs4_proc_open(struct nfs4_opendata *data);",
            "static int _nfs4_recover_proc_open(struct nfs4_opendata *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\n\nint\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: %4d initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\",\n\t\tdata->task.tk_pid, sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tif (!sync) {\n\t\tdata->inode = nfs_igrab_and_active(data->args.inode);\n\t\tif (data->inode == NULL) {\n\t\t\tnfs4_layoutcommit_release(data);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags = RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutcommit(data->args.inode, status);\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_INO_LAYOUTCOMMIT",
            "&nfsi->flags"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "data->cred"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ld->prepare_layoutcommit",
          "args": [
            "&data->args"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fattr_init",
          "args": [
            "&data->fattr"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1286-1293",
          "snippet": "void nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "nfsi->layout->plh_lc_cred"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "&data->args.stateid",
            "&nfsi->layout->plh_stateid"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_list_write_lseg",
          "args": [
            "inode",
            "&data->lseg_list"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_list_write_lseg_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2082-2093",
          "snippet": "static void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&data->lseg_list"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_INO_LAYOUTCOMMIT",
            "&nfsi->flags"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_NOFS"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit_lock_action",
          "args": [
            "&nfsi->flags",
            "NFS_INO_LAYOUTCOMMITTING",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_INO_LAYOUTCOMMITTING",
            "&nfsi->flags"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s inode %lu\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_outstanding",
          "args": [
            "inode"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_outstanding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "654-658",
          "snippet": "static inline bool\npnfs_layoutcommit_outstanding(struct inode *inode)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline bool\npnfs_layoutcommit_outstanding(struct inode *inode)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nint\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "pnfs_cleanup_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2161-2168",
    "snippet": "void pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(data->args.inode);\n\n\tif (nfss->pnfs_curr_ld->cleanup_layoutcommit)\n\t\tnfss->pnfs_curr_ld->cleanup_layoutcommit(data);\n\tpnfs_list_write_lseg_done(data->args.inode, &data->lseg_list);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_list_write_lseg_done",
          "args": [
            "data->args.inode",
            "&data->lseg_list"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_list_write_lseg_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2082-2093",
          "snippet": "static void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfss->pnfs_curr_ld->cleanup_layoutcommit",
          "args": [
            "data"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "data->args.inode"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(data->args.inode);\n\n\tif (nfss->pnfs_curr_ld->cleanup_layoutcommit)\n\t\tnfss->pnfs_curr_ld->cleanup_layoutcommit(data);\n\tpnfs_list_write_lseg_done(data->args.inode, &data->lseg_list);\n}"
  },
  {
    "function_name": "pnfs_commit_set_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2132-2158",
    "snippet": "void pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lseg %p end_pos %llu\\n\"",
            "__func__",
            "data->lseg",
            "nfsi->layout->plh_lwb"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "data->lseg"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_LSEG_LAYOUTCOMMIT",
            "&data->lseg->pls_flags"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Set layoutcommit for inode %lu \"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
  },
  {
    "function_name": "pnfs_set_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2101-2129",
    "snippet": "void\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lseg %p end_pos %llu\\n\"",
            "__func__",
            "hdr->lseg",
            "nfsi->layout->plh_lwb"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "hdr->lseg"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_LSEG_LAYOUTCOMMIT",
            "&hdr->lseg->pls_flags"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Set layoutcommit for inode %lu \"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
  },
  {
    "function_name": "pnfs_set_lo_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2095-2098",
    "snippet": "void pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_io_set_failed",
          "args": [
            "lseg->pls_layout",
            "lseg->pls_range.iomode"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_io_set_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "276-294",
          "snippet": "static void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}"
  },
  {
    "function_name": "pnfs_list_write_lseg_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2082-2093",
    "snippet": "static void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_clear_layoutcommitting",
          "args": [
            "inode"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_layoutcommitting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2059-2066",
          "snippet": "static void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "lseg"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "440-457",
          "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lseg->pls_lc_list"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "tmp",
            "listp",
            "pls_lc_list"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tpnfs_clear_layoutcommitting(inode);\n}"
  },
  {
    "function_name": "pnfs_list_write_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2071-2080",
    "snippet": "static void pnfs_list_write_lseg(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &NFS_I(inode)->layout->plh_segs, pls_list) {\n\t\tif (lseg->pls_range.iomode == IOMODE_RW &&\n\t\t    test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tlist_add(&lseg->pls_lc_list, listp);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lseg->pls_lc_list",
            "listp"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_LSEG_LAYOUTCOMMIT",
            "&lseg->pls_flags"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lseg",
            "&NFS_I(inode)->layout->plh_segs",
            "pls_list"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_list_write_lseg(struct inode *inode, struct list_head *listp)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &NFS_I(inode)->layout->plh_segs, pls_list) {\n\t\tif (lseg->pls_range.iomode == IOMODE_RW &&\n\t\t    test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tlist_add(&lseg->pls_lc_list, listp);\n\t}\n}"
  },
  {
    "function_name": "pnfs_clear_layoutcommitting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2059-2066",
    "snippet": "static void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "bitlock",
            "NFS_INO_LAYOUTCOMMITTING"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "NFS_INO_LAYOUTCOMMITTING",
            "bitlock"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_layoutcommitting(struct inode *inode)\n{\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n}"
  },
  {
    "function_name": "pnfs_generic_pg_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2037-2056",
    "snippet": "int\npnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_pgio_header *hdr;\n\tint ret;\n\n\thdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\n\tif (!hdr) {\n\t\tdesc->pg_completion_ops->error_cleanup(&mirror->pg_list);\n\t\treturn -ENOMEM;\n\t}\n\tnfs_pgheader_init(desc, hdr, pnfs_readhdr_free);\n\thdr->lseg = pnfs_get_lseg(desc->pg_lseg);\n\tret = nfs_generic_pgio(desc, hdr);\n\tif (!ret)\n\t\tpnfs_do_read(desc, hdr);\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_do_read",
          "args": [
            "desc",
            "hdr"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2015-2028",
          "snippet": "static void\npnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\tint err = 0;\n\n\ttrypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);\n\tif (trypnfs == PNFS_TRY_AGAIN)\n\t\terr = pnfs_read_resend_pnfs(hdr);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED || err)\n\t\tpnfs_read_through_mds(desc, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\tint err = 0;\n\n\ttrypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);\n\tif (trypnfs == PNFS_TRY_AGAIN)\n\t\terr = pnfs_read_resend_pnfs(hdr);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED || err)\n\t\tpnfs_read_through_mds(desc, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_generic_pgio",
          "args": [
            "desc",
            "hdr"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_generic_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "791-834",
          "snippet": "int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,\n\t\t     struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_page\t\t*req;\n\tstruct page\t\t**pages,\n\t\t\t\t*last_page;\n\tstruct list_head *head = &mirror->pg_list;\n\tstruct nfs_commit_info cinfo;\n\tunsigned int pagecount, pageused;\n\n\tpagecount = nfs_page_array_len(mirror->pg_base, mirror->pg_count);\n\tif (!nfs_pgarray_set(&hdr->page_array, pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tnfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);\n\tpages = hdr->page_array.pagevec;\n\tlast_page = NULL;\n\tpageused = 0;\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_list_add_request(req, &hdr->pages);\n\n\t\tif (!last_page || last_page != req->wb_page) {\n\t\t\tpageused++;\n\t\t\tif (pageused > pagecount)\n\t\t\t\tbreak;\n\t\t\t*pages++ = last_page = req->wb_page;\n\t\t}\n\t}\n\tif (WARN_ON_ONCE(pageused != pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tif ((desc->pg_ioflags & FLUSH_COND_STABLE) &&\n\t    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))\n\t\tdesc->pg_ioflags &= ~FLUSH_COND_STABLE;\n\n\t/* Set up the argument struct */\n\tnfs_pgio_rpcsetup(hdr, mirror->pg_count, 0, desc->pg_ioflags, &cinfo);\n\tdesc->pg_rpc_callops = &nfs_pgio_common_ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_pgio_common_ops;",
            "static const struct rpc_call_ops nfs_pgio_common_ops = {\n\t.rpc_call_prepare = nfs_pgio_prepare,\n\t.rpc_call_done = nfs_pgio_result,\n\t.rpc_release = nfs_pgio_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_pgio_common_ops;\nstatic const struct rpc_call_ops nfs_pgio_common_ops = {\n\t.rpc_call_prepare = nfs_pgio_prepare,\n\t.rpc_call_done = nfs_pgio_result,\n\t.rpc_release = nfs_pgio_release,\n};\n\nint nfs_generic_pgio(struct nfs_pageio_descriptor *desc,\n\t\t     struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_page\t\t*req;\n\tstruct page\t\t**pages,\n\t\t\t\t*last_page;\n\tstruct list_head *head = &mirror->pg_list;\n\tstruct nfs_commit_info cinfo;\n\tunsigned int pagecount, pageused;\n\n\tpagecount = nfs_page_array_len(mirror->pg_base, mirror->pg_count);\n\tif (!nfs_pgarray_set(&hdr->page_array, pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tnfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);\n\tpages = hdr->page_array.pagevec;\n\tlast_page = NULL;\n\tpageused = 0;\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_list_add_request(req, &hdr->pages);\n\n\t\tif (!last_page || last_page != req->wb_page) {\n\t\t\tpageused++;\n\t\t\tif (pageused > pagecount)\n\t\t\t\tbreak;\n\t\t\t*pages++ = last_page = req->wb_page;\n\t\t}\n\t}\n\tif (WARN_ON_ONCE(pageused != pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tif ((desc->pg_ioflags & FLUSH_COND_STABLE) &&\n\t    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))\n\t\tdesc->pg_ioflags &= ~FLUSH_COND_STABLE;\n\n\t/* Set up the argument struct */\n\tnfs_pgio_rpcsetup(hdr, mirror->pg_count, 0, desc->pg_ioflags, &cinfo);\n\tdesc->pg_rpc_callops = &nfs_pgio_common_ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "desc->pg_lseg"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgheader_init",
          "args": [
            "desc",
            "hdr",
            "pnfs_readhdr_free"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgheader_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "54-74",
          "snippet": "void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,\n\t\t       struct nfs_pgio_header *hdr,\n\t\t       void (*release)(struct nfs_pgio_header *hdr))\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\n\thdr->req = nfs_list_entry(mirror->pg_list.next);\n\thdr->inode = desc->pg_inode;\n\thdr->cred = hdr->req->wb_context->cred;\n\thdr->io_start = req_offset(hdr->req);\n\thdr->good_bytes = mirror->pg_count;\n\thdr->dreq = desc->pg_dreq;\n\thdr->layout_private = desc->pg_layout_private;\n\thdr->release = release;\n\thdr->completion_ops = desc->pg_completion_ops;\n\tif (hdr->completion_ops->init_hdr)\n\t\thdr->completion_ops->init_hdr(hdr);\n\n\thdr->pgio_mirror_idx = desc->pg_mirror_idx;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgheader_init(struct nfs_pageio_descriptor *desc,\n\t\t       struct nfs_pgio_header *hdr,\n\t\t       void (*release)(struct nfs_pgio_header *hdr))\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\n\thdr->req = nfs_list_entry(mirror->pg_list.next);\n\thdr->inode = desc->pg_inode;\n\thdr->cred = hdr->req->wb_context->cred;\n\thdr->io_start = req_offset(hdr->req);\n\thdr->good_bytes = mirror->pg_count;\n\thdr->dreq = desc->pg_dreq;\n\thdr->layout_private = desc->pg_layout_private;\n\thdr->release = release;\n\thdr->completion_ops = desc->pg_completion_ops;\n\tif (hdr->completion_ops->init_hdr)\n\t\thdr->completion_ops->init_hdr(hdr);\n\n\thdr->pgio_mirror_idx = desc->pg_mirror_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->pg_completion_ops->error_cleanup",
          "args": [
            "&mirror->pg_list"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pgio_header_alloc",
          "args": [
            "desc->pg_rw_ops"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_header_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "518-528",
          "snippet": "struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)\n{\n\tstruct nfs_pgio_header *hdr = ops->rw_alloc_header();\n\n\tif (hdr) {\n\t\tINIT_LIST_HEAD(&hdr->pages);\n\t\tspin_lock_init(&hdr->lock);\n\t\thdr->rw_ops = ops;\n\t}\n\treturn hdr;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)\n{\n\tstruct nfs_pgio_header *hdr = ops->rw_alloc_header();\n\n\tif (hdr) {\n\t\tINIT_LIST_HEAD(&hdr->pages);\n\t\tspin_lock_init(&hdr->lock);\n\t\thdr->rw_ops = ops;\n\t}\n\treturn hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgio_current_mirror",
          "args": [
            "desc"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_current_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "45-51",
          "snippet": "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_pgio_header *hdr;\n\tint ret;\n\n\thdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\n\tif (!hdr) {\n\t\tdesc->pg_completion_ops->error_cleanup(&mirror->pg_list);\n\t\treturn -ENOMEM;\n\t}\n\tnfs_pgheader_init(desc, hdr, pnfs_readhdr_free);\n\thdr->lseg = pnfs_get_lseg(desc->pg_lseg);\n\tret = nfs_generic_pgio(desc, hdr);\n\tif (!ret)\n\t\tpnfs_do_read(desc, hdr);\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_readhdr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2030-2034",
    "snippet": "static void pnfs_readhdr_free(struct nfs_pgio_header *hdr)\n{\n\tpnfs_put_lseg(hdr->lseg);\n\tnfs_pgio_header_free(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pgio_header_free",
          "args": [
            "hdr"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_header_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "535-538",
          "snippet": "void nfs_pgio_header_free(struct nfs_pgio_header *hdr)\n{\n\thdr->rw_ops->rw_free_header(hdr);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgio_header_free(struct nfs_pgio_header *hdr)\n{\n\thdr->rw_ops->rw_free_header(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "hdr->lseg"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "440-457",
          "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_readhdr_free(struct nfs_pgio_header *hdr)\n{\n\tpnfs_put_lseg(hdr->lseg);\n\tnfs_pgio_header_free(hdr);\n}"
  },
  {
    "function_name": "pnfs_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2015-2028",
    "snippet": "static void\npnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\tint err = 0;\n\n\ttrypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);\n\tif (trypnfs == PNFS_TRY_AGAIN)\n\t\terr = pnfs_read_resend_pnfs(hdr);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED || err)\n\t\tpnfs_read_through_mds(desc, hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_read_through_mds",
          "args": [
            "desc",
            "hdr"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_through_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1967-1979",
          "snippet": "static void\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_read_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_read_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_read_resend_pnfs",
          "args": [
            "hdr"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_resend_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2006-2012",
          "snippet": "int pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_try_to_read_data",
          "args": [
            "hdr",
            "call_ops",
            "lseg"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_try_to_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1984-2003",
          "snippet": "static enum pnfs_try_status\npnfs_try_to_read_data(struct nfs_pgio_header *hdr,\n\t\t       const struct rpc_call_ops *call_ops,\n\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tenum pnfs_try_status trypnfs;\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Reading ino:%lu %u@%llu\\n\",\n\t\t__func__, inode->i_ino, hdr->args.count, hdr->args.offset);\n\n\ttrypnfs = nfss->pnfs_curr_ld->read_pagelist(hdr);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_READ);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic enum pnfs_try_status\npnfs_try_to_read_data(struct nfs_pgio_header *hdr,\n\t\t       const struct rpc_call_ops *call_ops,\n\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tenum pnfs_try_status trypnfs;\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Reading ino:%lu %u@%llu\\n\",\n\t\t__func__, inode->i_ino, hdr->args.count, hdr->args.offset);\n\n\ttrypnfs = nfss->pnfs_curr_ld->read_pagelist(hdr);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_READ);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\tint err = 0;\n\n\ttrypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);\n\tif (trypnfs == PNFS_TRY_AGAIN)\n\t\terr = pnfs_read_resend_pnfs(hdr);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED || err)\n\t\tpnfs_read_through_mds(desc, hdr);\n}"
  },
  {
    "function_name": "pnfs_read_resend_pnfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "2006-2012",
    "snippet": "int pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_resend",
          "args": [
            "&pgio",
            "hdr"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_resend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1218-1237",
          "snippet": "int nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_read",
          "args": [
            "&pgio",
            "hdr->inode",
            "false",
            "hdr->completion_ops"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "55-68",
          "snippet": "void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_read_ops;",
            "static const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_rw_ops nfs_rw_read_ops;\nstatic const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};\n\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
  },
  {
    "function_name": "pnfs_try_to_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1984-2003",
    "snippet": "static enum pnfs_try_status\npnfs_try_to_read_data(struct nfs_pgio_header *hdr,\n\t\t       const struct rpc_call_ops *call_ops,\n\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tenum pnfs_try_status trypnfs;\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Reading ino:%lu %u@%llu\\n\",\n\t\t__func__, inode->i_ino, hdr->args.count, hdr->args.offset);\n\n\ttrypnfs = nfss->pnfs_curr_ld->read_pagelist(hdr);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_READ);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s End (trypnfs:%d)\\n\"",
            "__func__",
            "trypnfs"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_PNFS_READ"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfss->pnfs_curr_ld->read_pagelist",
          "args": [
            "hdr"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Reading ino:%lu %u@%llu\\n\"",
            "__func__",
            "inode->i_ino",
            "hdr->args.count",
            "hdr->args.offset"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic enum pnfs_try_status\npnfs_try_to_read_data(struct nfs_pgio_header *hdr,\n\t\t       const struct rpc_call_ops *call_ops,\n\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tenum pnfs_try_status trypnfs;\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Reading ino:%lu %u@%llu\\n\",\n\t\t__func__, inode->i_ino, hdr->args.count, hdr->args.offset);\n\n\ttrypnfs = nfss->pnfs_curr_ld->read_pagelist(hdr);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_READ);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}"
  },
  {
    "function_name": "pnfs_read_through_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1967-1979",
    "snippet": "static void\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_read_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pgio_data_destroy",
          "args": [
            "hdr"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_data_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "549-555",
          "snippet": "void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->args.context)\n\t\tput_nfs_open_context(hdr->args.context);\n\tif (hdr->page_array.pagevec != hdr->page_array.page_array)\n\t\tkfree(hdr->page_array.pagevec);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->args.context)\n\t\tput_nfs_open_context(hdr->args.context);\n\tif (hdr->page_array.pagevec != hdr->page_array.page_array)\n\t\tkfree(hdr->page_array.pagevec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_reset_read_mds",
          "args": [
            "desc"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_read_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "71-82",
          "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&hdr->pages",
            "&mirror->pg_list"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgio_current_mirror",
          "args": [
            "desc"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_current_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "45-51",
          "snippet": "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_read_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}"
  },
  {
    "function_name": "pnfs_ld_read_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1955-1964",
    "snippet": "void pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_release",
          "args": [
            "hdr"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_ld_handle_read_error",
          "args": [
            "hdr"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_handle_read_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1941-1950",
          "snippet": "static void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)\n{\n\tdprintk(\"pnfs read error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_read_done_resend_to_mds(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)\n{\n\tdprintk(\"pnfs read error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_read_done_resend_to_mds(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "&hdr->task",
            "hdr"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs4_read_done_cb",
          "args": [
            "hdr"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_read_done_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4151-4154",
          "snippet": "void __nfs4_read_done_cb(struct nfs_pgio_header *hdr)\n{\n\tnfs_invalidate_atime(hdr->inode);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nvoid __nfs4_read_done_cb(struct nfs_pgio_header *hdr)\n{\n\tnfs_invalidate_atime(hdr->inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!hdr->pnfs_error"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_read",
          "args": [
            "hdr",
            "hdr->pnfs_error"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
  },
  {
    "function_name": "pnfs_ld_handle_read_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1941-1950",
    "snippet": "static void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)\n{\n\tdprintk(\"pnfs read error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_read_done_resend_to_mds(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_read_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1931-1938",
          "snippet": "int pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_return_layout",
          "args": [
            "hdr->inode"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "_pnfs_return_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "972-1023",
          "snippet": "int\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "hdr->inode"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfs read error = %d\\n\"",
            "hdr->pnfs_error"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)\n{\n\tdprintk(\"pnfs read error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_read_done_resend_to_mds(hdr);\n}"
  },
  {
    "function_name": "pnfs_read_done_resend_to_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1931-1938",
    "snippet": "int pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_resend",
          "args": [
            "&pgio",
            "hdr"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_resend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1218-1237",
          "snippet": "int nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_read",
          "args": [
            "&pgio",
            "hdr->inode",
            "true",
            "hdr->completion_ops"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "55-68",
          "snippet": "void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_read_ops;",
            "static const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_rw_ops nfs_rw_read_ops;\nstatic const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};\n\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
  },
  {
    "function_name": "pnfs_generic_pg_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1907-1928",
    "snippet": "int\npnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_pgio_header *hdr;\n\tint ret;\n\n\thdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\n\tif (!hdr) {\n\t\tdesc->pg_completion_ops->error_cleanup(&mirror->pg_list);\n\t\treturn -ENOMEM;\n\t}\n\tnfs_pgheader_init(desc, hdr, pnfs_writehdr_free);\n\n\thdr->lseg = pnfs_get_lseg(desc->pg_lseg);\n\tret = nfs_generic_pgio(desc, hdr);\n\tif (!ret)\n\t\tpnfs_do_write(desc, hdr, desc->pg_ioflags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_do_write",
          "args": [
            "desc",
            "hdr",
            "desc->pg_ioflags"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1887-1898",
          "snippet": "static void\npnfs_do_write(struct nfs_pageio_descriptor *desc,\n\t      struct nfs_pgio_header *hdr, int how)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\n\ttrypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED)\n\t\tpnfs_write_through_mds(desc, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_do_write(struct nfs_pageio_descriptor *desc,\n\t      struct nfs_pgio_header *hdr, int how)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\n\ttrypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED)\n\t\tpnfs_write_through_mds(desc, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_generic_pgio",
          "args": [
            "desc",
            "hdr"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_generic_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "791-834",
          "snippet": "int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,\n\t\t     struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_page\t\t*req;\n\tstruct page\t\t**pages,\n\t\t\t\t*last_page;\n\tstruct list_head *head = &mirror->pg_list;\n\tstruct nfs_commit_info cinfo;\n\tunsigned int pagecount, pageused;\n\n\tpagecount = nfs_page_array_len(mirror->pg_base, mirror->pg_count);\n\tif (!nfs_pgarray_set(&hdr->page_array, pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tnfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);\n\tpages = hdr->page_array.pagevec;\n\tlast_page = NULL;\n\tpageused = 0;\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_list_add_request(req, &hdr->pages);\n\n\t\tif (!last_page || last_page != req->wb_page) {\n\t\t\tpageused++;\n\t\t\tif (pageused > pagecount)\n\t\t\t\tbreak;\n\t\t\t*pages++ = last_page = req->wb_page;\n\t\t}\n\t}\n\tif (WARN_ON_ONCE(pageused != pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tif ((desc->pg_ioflags & FLUSH_COND_STABLE) &&\n\t    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))\n\t\tdesc->pg_ioflags &= ~FLUSH_COND_STABLE;\n\n\t/* Set up the argument struct */\n\tnfs_pgio_rpcsetup(hdr, mirror->pg_count, 0, desc->pg_ioflags, &cinfo);\n\tdesc->pg_rpc_callops = &nfs_pgio_common_ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_pgio_common_ops;",
            "static const struct rpc_call_ops nfs_pgio_common_ops = {\n\t.rpc_call_prepare = nfs_pgio_prepare,\n\t.rpc_call_done = nfs_pgio_result,\n\t.rpc_release = nfs_pgio_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_pgio_common_ops;\nstatic const struct rpc_call_ops nfs_pgio_common_ops = {\n\t.rpc_call_prepare = nfs_pgio_prepare,\n\t.rpc_call_done = nfs_pgio_result,\n\t.rpc_release = nfs_pgio_release,\n};\n\nint nfs_generic_pgio(struct nfs_pageio_descriptor *desc,\n\t\t     struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_page\t\t*req;\n\tstruct page\t\t**pages,\n\t\t\t\t*last_page;\n\tstruct list_head *head = &mirror->pg_list;\n\tstruct nfs_commit_info cinfo;\n\tunsigned int pagecount, pageused;\n\n\tpagecount = nfs_page_array_len(mirror->pg_base, mirror->pg_count);\n\tif (!nfs_pgarray_set(&hdr->page_array, pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tnfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);\n\tpages = hdr->page_array.pagevec;\n\tlast_page = NULL;\n\tpageused = 0;\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_list_add_request(req, &hdr->pages);\n\n\t\tif (!last_page || last_page != req->wb_page) {\n\t\t\tpageused++;\n\t\t\tif (pageused > pagecount)\n\t\t\t\tbreak;\n\t\t\t*pages++ = last_page = req->wb_page;\n\t\t}\n\t}\n\tif (WARN_ON_ONCE(pageused != pagecount))\n\t\treturn nfs_pgio_error(desc, hdr);\n\n\tif ((desc->pg_ioflags & FLUSH_COND_STABLE) &&\n\t    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))\n\t\tdesc->pg_ioflags &= ~FLUSH_COND_STABLE;\n\n\t/* Set up the argument struct */\n\tnfs_pgio_rpcsetup(hdr, mirror->pg_count, 0, desc->pg_ioflags, &cinfo);\n\tdesc->pg_rpc_callops = &nfs_pgio_common_ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "desc->pg_lseg"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgheader_init",
          "args": [
            "desc",
            "hdr",
            "pnfs_writehdr_free"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgheader_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "54-74",
          "snippet": "void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,\n\t\t       struct nfs_pgio_header *hdr,\n\t\t       void (*release)(struct nfs_pgio_header *hdr))\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\n\thdr->req = nfs_list_entry(mirror->pg_list.next);\n\thdr->inode = desc->pg_inode;\n\thdr->cred = hdr->req->wb_context->cred;\n\thdr->io_start = req_offset(hdr->req);\n\thdr->good_bytes = mirror->pg_count;\n\thdr->dreq = desc->pg_dreq;\n\thdr->layout_private = desc->pg_layout_private;\n\thdr->release = release;\n\thdr->completion_ops = desc->pg_completion_ops;\n\tif (hdr->completion_ops->init_hdr)\n\t\thdr->completion_ops->init_hdr(hdr);\n\n\thdr->pgio_mirror_idx = desc->pg_mirror_idx;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgheader_init(struct nfs_pageio_descriptor *desc,\n\t\t       struct nfs_pgio_header *hdr,\n\t\t       void (*release)(struct nfs_pgio_header *hdr))\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\n\thdr->req = nfs_list_entry(mirror->pg_list.next);\n\thdr->inode = desc->pg_inode;\n\thdr->cred = hdr->req->wb_context->cred;\n\thdr->io_start = req_offset(hdr->req);\n\thdr->good_bytes = mirror->pg_count;\n\thdr->dreq = desc->pg_dreq;\n\thdr->layout_private = desc->pg_layout_private;\n\thdr->release = release;\n\thdr->completion_ops = desc->pg_completion_ops;\n\tif (hdr->completion_ops->init_hdr)\n\t\thdr->completion_ops->init_hdr(hdr);\n\n\thdr->pgio_mirror_idx = desc->pg_mirror_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->pg_completion_ops->error_cleanup",
          "args": [
            "&mirror->pg_list"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pgio_header_alloc",
          "args": [
            "desc->pg_rw_ops"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_header_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "518-528",
          "snippet": "struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)\n{\n\tstruct nfs_pgio_header *hdr = ops->rw_alloc_header();\n\n\tif (hdr) {\n\t\tINIT_LIST_HEAD(&hdr->pages);\n\t\tspin_lock_init(&hdr->lock);\n\t\thdr->rw_ops = ops;\n\t}\n\treturn hdr;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)\n{\n\tstruct nfs_pgio_header *hdr = ops->rw_alloc_header();\n\n\tif (hdr) {\n\t\tINIT_LIST_HEAD(&hdr->pages);\n\t\tspin_lock_init(&hdr->lock);\n\t\thdr->rw_ops = ops;\n\t}\n\treturn hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgio_current_mirror",
          "args": [
            "desc"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_current_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "45-51",
          "snippet": "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tstruct nfs_pgio_header *hdr;\n\tint ret;\n\n\thdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\n\tif (!hdr) {\n\t\tdesc->pg_completion_ops->error_cleanup(&mirror->pg_list);\n\t\treturn -ENOMEM;\n\t}\n\tnfs_pgheader_init(desc, hdr, pnfs_writehdr_free);\n\n\thdr->lseg = pnfs_get_lseg(desc->pg_lseg);\n\tret = nfs_generic_pgio(desc, hdr);\n\tif (!ret)\n\t\tpnfs_do_write(desc, hdr, desc->pg_ioflags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_writehdr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1900-1904",
    "snippet": "static void pnfs_writehdr_free(struct nfs_pgio_header *hdr)\n{\n\tpnfs_put_lseg(hdr->lseg);\n\tnfs_pgio_header_free(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pgio_header_free",
          "args": [
            "hdr"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_header_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "535-538",
          "snippet": "void nfs_pgio_header_free(struct nfs_pgio_header *hdr)\n{\n\thdr->rw_ops->rw_free_header(hdr);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgio_header_free(struct nfs_pgio_header *hdr)\n{\n\thdr->rw_ops->rw_free_header(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "hdr->lseg"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "440-457",
          "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_writehdr_free(struct nfs_pgio_header *hdr)\n{\n\tpnfs_put_lseg(hdr->lseg);\n\tnfs_pgio_header_free(hdr);\n}"
  },
  {
    "function_name": "pnfs_do_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1887-1898",
    "snippet": "static void\npnfs_do_write(struct nfs_pageio_descriptor *desc,\n\t      struct nfs_pgio_header *hdr, int how)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\n\ttrypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED)\n\t\tpnfs_write_through_mds(desc, hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_write_through_mds",
          "args": [
            "desc",
            "hdr"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_write_through_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1852-1864",
          "snippet": "static void\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_write_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_write_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_try_to_write_data",
          "args": [
            "hdr",
            "call_ops",
            "lseg",
            "how"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_try_to_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1866-1885",
          "snippet": "static enum pnfs_try_status\npnfs_try_to_write_data(struct nfs_pgio_header *hdr,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\tint how)\n{\n\tstruct inode *inode = hdr->inode;\n\tenum pnfs_try_status trypnfs;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Writing ino:%lu %u@%llu (how %d)\\n\", __func__,\n\t\tinode->i_ino, hdr->args.count, hdr->args.offset, how);\n\ttrypnfs = nfss->pnfs_curr_ld->write_pagelist(hdr, how);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic enum pnfs_try_status\npnfs_try_to_write_data(struct nfs_pgio_header *hdr,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\tint how)\n{\n\tstruct inode *inode = hdr->inode;\n\tenum pnfs_try_status trypnfs;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Writing ino:%lu %u@%llu (how %d)\\n\", __func__,\n\t\tinode->i_ino, hdr->args.count, hdr->args.offset, how);\n\ttrypnfs = nfss->pnfs_curr_ld->write_pagelist(hdr, how);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_do_write(struct nfs_pageio_descriptor *desc,\n\t      struct nfs_pgio_header *hdr, int how)\n{\n\tconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\n\tstruct pnfs_layout_segment *lseg = desc->pg_lseg;\n\tenum pnfs_try_status trypnfs;\n\n\ttrypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);\n\tif (trypnfs == PNFS_NOT_ATTEMPTED)\n\t\tpnfs_write_through_mds(desc, hdr);\n}"
  },
  {
    "function_name": "pnfs_try_to_write_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1866-1885",
    "snippet": "static enum pnfs_try_status\npnfs_try_to_write_data(struct nfs_pgio_header *hdr,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\tint how)\n{\n\tstruct inode *inode = hdr->inode;\n\tenum pnfs_try_status trypnfs;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Writing ino:%lu %u@%llu (how %d)\\n\", __func__,\n\t\tinode->i_ino, hdr->args.count, hdr->args.offset, how);\n\ttrypnfs = nfss->pnfs_curr_ld->write_pagelist(hdr, how);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s End (trypnfs:%d)\\n\"",
            "__func__",
            "trypnfs"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_PNFS_WRITE"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfss->pnfs_curr_ld->write_pagelist",
          "args": [
            "hdr",
            "how"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Writing ino:%lu %u@%llu (how %d)\\n\"",
            "__func__",
            "inode->i_ino",
            "hdr->args.count",
            "hdr->args.offset",
            "how"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic enum pnfs_try_status\npnfs_try_to_write_data(struct nfs_pgio_header *hdr,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\tint how)\n{\n\tstruct inode *inode = hdr->inode;\n\tenum pnfs_try_status trypnfs;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\thdr->mds_ops = call_ops;\n\n\tdprintk(\"%s: Writing ino:%lu %u@%llu (how %d)\\n\", __func__,\n\t\tinode->i_ino, hdr->args.count, hdr->args.offset, how);\n\ttrypnfs = nfss->pnfs_curr_ld->write_pagelist(hdr, how);\n\tif (trypnfs != PNFS_NOT_ATTEMPTED)\n\t\tnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\n\tdprintk(\"%s End (trypnfs:%d)\\n\", __func__, trypnfs);\n\treturn trypnfs;\n}"
  },
  {
    "function_name": "pnfs_write_through_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1852-1864",
    "snippet": "static void\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_write_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pgio_data_destroy",
          "args": [
            "hdr"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_data_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "549-555",
          "snippet": "void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->args.context)\n\t\tput_nfs_open_context(hdr->args.context);\n\tif (hdr->page_array.pagevec != hdr->page_array.page_array)\n\t\tkfree(hdr->page_array.pagevec);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->args.context)\n\t\tput_nfs_open_context(hdr->args.context);\n\tif (hdr->page_array.pagevec != hdr->page_array.page_array)\n\t\tkfree(hdr->page_array.pagevec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "desc"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&hdr->pages",
            "&mirror->pg_list"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgio_current_mirror",
          "args": [
            "desc"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_current_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "45-51",
          "snippet": "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\n\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\n\t\tnfs_pageio_reset_write_mds(desc);\n\t\tmirror->pg_recoalesce = 1;\n\t}\n\tnfs_pgio_data_destroy(hdr);\n}"
  },
  {
    "function_name": "pnfs_ld_write_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1840-1849",
    "snippet": "void pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_release",
          "args": [
            "hdr"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_ld_handle_write_error",
          "args": [
            "hdr"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_handle_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1825-1835",
          "snippet": "static void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)\n{\n\n\tdprintk(\"pnfs write error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_write_done_resend_to_mds(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)\n{\n\n\tdprintk(\"pnfs write error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_write_done_resend_to_mds(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "&hdr->task",
            "hdr"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_set_layoutcommit",
          "args": [
            "hdr"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2101-2129",
          "snippet": "void\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_write",
          "args": [
            "hdr",
            "hdr->pnfs_error"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
  },
  {
    "function_name": "pnfs_ld_handle_write_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1825-1835",
    "snippet": "static void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)\n{\n\n\tdprintk(\"pnfs write error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_write_done_resend_to_mds(hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_write_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_write_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1814-1822",
          "snippet": "int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_return_layout",
          "args": [
            "hdr->inode"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "_pnfs_return_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "972-1023",
          "snippet": "int\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "hdr->inode"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfs write error = %d\\n\"",
            "hdr->pnfs_error"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)\n{\n\n\tdprintk(\"pnfs write error = %d\\n\", hdr->pnfs_error);\n\tif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\n\t    PNFS_LAYOUTRET_ON_ERROR) {\n\t\tpnfs_return_layout(hdr->inode);\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\thdr->task.tk_status = pnfs_write_done_resend_to_mds(hdr);\n}"
  },
  {
    "function_name": "pnfs_write_done_resend_to_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1814-1822",
    "snippet": "int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_resend",
          "args": [
            "&pgio",
            "hdr"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_resend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1218-1237",
          "snippet": "int nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_resend(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tLIST_HEAD(failed);\n\n\tdesc->pg_dreq = hdr->dreq;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tnfs_list_remove_request(req);\n\t\tif (!nfs_pageio_add_request(desc, req))\n\t\t\tnfs_list_add_request(req, &failed);\n\t}\n\tnfs_pageio_complete(desc);\n\tif (!list_empty(&failed)) {\n\t\tlist_move(&failed, &hdr->pages);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_write",
          "args": [
            "&pgio",
            "hdr->inode",
            "FLUSH_STABLE",
            "true",
            "hdr->completion_ops"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1313-1326",
          "snippet": "void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_write_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_rw_ops nfs_rw_write_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};\n\nvoid nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
  },
  {
    "function_name": "pnfs_generic_pg_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1766-1811",
    "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgio->pg_ops->pg_init",
          "args": [
            "pgio",
            "req"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgio->pg_ops->pg_cleanup",
          "args": [
            "pgio"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req_start >= seg_end"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "pgio->pg_lseg->pls_range.offset",
            "pgio->pg_lseg->pls_range.length"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "460-467",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_generic_pg_test",
          "args": [
            "pgio",
            "prev",
            "req"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1766-1811",
          "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nsize_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "pnfs_generic_pg_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1752-1759",
    "snippet": "void\npnfs_generic_pg_cleanup(struct nfs_pageio_descriptor *desc)\n{\n\tif (desc->pg_lseg) {\n\t\tpnfs_put_lseg(desc->pg_lseg);\n\t\tdesc->pg_lseg = NULL;\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "desc->pg_lseg"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "440-457",
          "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_cleanup(struct nfs_pageio_descriptor *desc)\n{\n\tif (desc->pg_lseg) {\n\t\tpnfs_put_lseg(desc->pg_lseg);\n\t\tdesc->pg_lseg = NULL;\n\t}\n}"
  },
  {
    "function_name": "pnfs_generic_pg_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1735-1749",
    "snippet": "void\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "pgio"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "req_offset(req)",
            "wb_size",
            "IOMODE_RW",
            "GFP_NOFS"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}"
  },
  {
    "function_name": "pnfs_generic_pg_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1710-1732",
    "snippet": "void\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_read_mds",
          "args": [
            "pgio"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_read_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "71-82",
          "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "req_offset(req)",
            "rd_size",
            "IOMODE_READ",
            "GFP_KERNEL"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_dreq_bytes_left",
          "args": [
            "pgio->pg_dreq"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dreq_bytes_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "342-345",
          "snippet": "ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "pgio->pg_inode"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}"
  },
  {
    "function_name": "pnfs_error_mark_layout_for_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1679-1707",
    "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&free_me"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_return",
          "args": [
            "lo",
            "&free_me",
            "&range"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1655-1677",
          "snippet": "static void\npnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tstruct pnfs_layout_range *return_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (should_free_lseg(&lseg->pls_range, return_range)) {\n\t\t\tdprintk(\"%s: marking lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode,\n\t\t\t\tlseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\n\t\t\tmark_lseg_invalid(lseg, tmp_list);\n\t\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tstruct pnfs_layout_range *return_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (should_free_lseg(&lseg->pls_range, return_range)) {\n\t\t\tdprintk(\"%s: marking lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode,\n\t\t\t\tlseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\n\t\t\tmark_lseg_invalid(lseg, tmp_list);\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_RETURN",
            "&lo->plh_flags"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_set_fail_bit",
          "args": [
            "lo",
            "iomode"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_set_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "261-267",
          "snippet": "static void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "free_me"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_iomode_to_fail_bit",
          "args": [
            "lseg->pls_range.iomode"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_iomode_to_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "254-259",
          "snippet": "static int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
  },
  {
    "function_name": "pnfs_mark_matching_lsegs_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1655-1677",
    "snippet": "static void\npnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tstruct pnfs_layout_range *return_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (should_free_lseg(&lseg->pls_range, return_range)) {\n\t\t\tdprintk(\"%s: marking lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode,\n\t\t\t\tlseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\n\t\t\tmark_lseg_invalid(lseg, tmp_list);\n\t\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_lseg_invalid",
          "args": [
            "lseg",
            "tmp_list"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lseg_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "528-544",
          "snippet": "static int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LSEG_LAYOUTRETURN",
            "&lseg->pls_flags"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: marking lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\"",
            "__func__",
            "lseg",
            "lseg->pls_range.iomode",
            "lseg->pls_range.offset",
            "lseg->pls_range.length"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_free_lseg",
          "args": [
            "&lseg->pls_range",
            "return_range"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "should_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "508-515",
          "snippet": "static bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "next",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Begin lo %p\\n\"",
            "__func__",
            "lo"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\n\t\t\t\tstruct list_head *tmp_list,\n\t\t\t\tstruct pnfs_layout_range *return_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (should_free_lseg(&lseg->pls_range, return_range)) {\n\t\t\tdprintk(\"%s: marking lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode,\n\t\t\t\tlseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\n\t\t\tmark_lseg_invalid(lseg, tmp_list);\n\t\t}\n}"
  },
  {
    "function_name": "pnfs_layout_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1577-1653",
    "snippet": "struct pnfs_layout_segment *\npnfs_layout_process(struct nfs4_layoutget *lgp)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(lgp->args.inode)->layout;\n\tstruct nfs4_layoutget_res *res = &lgp->res;\n\tstruct pnfs_layout_segment *lseg;\n\tstruct inode *ino = lo->plh_inode;\n\tLIST_HEAD(free_me);\n\tint status = 0;\n\n\t/* Inject layout blob into I/O device driver */\n\tlseg = NFS_SERVER(ino)->pnfs_curr_ld->alloc_lseg(lo, res, lgp->gfp_flags);\n\tif (!lseg || IS_ERR(lseg)) {\n\t\tif (!lseg)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tstatus = PTR_ERR(lseg);\n\t\tdprintk(\"%s: Could not allocate layout: error %d\\n\",\n\t\t       __func__, status);\n\t\tgoto out;\n\t}\n\n\tinit_lseg(lo, lseg);\n\tlseg->pls_range = res->range;\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s forget reply due to recall\\n\", __func__);\n\t\tgoto out_forget_reply;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &lgp->args.range, 1)) {\n\t\tdprintk(\"%s forget reply due to state\\n\", __func__);\n\t\tgoto out_forget_reply;\n\t}\n\n\tif (nfs4_stateid_match_other(&lo->plh_stateid, &res->stateid)) {\n\t\t/* existing state ID, make sure the sequence number matches. */\n\t\tif (pnfs_layout_stateid_blocked(lo, &res->stateid)) {\n\t\t\tdprintk(\"%s forget reply due to sequence\\n\", __func__);\n\t\t\tgoto out_forget_reply;\n\t\t}\n\t\tpnfs_set_layout_stateid(lo, &res->stateid, false);\n\t} else {\n\t\t/*\n\t\t * We got an entirely new state ID.  Mark all segments for the\n\t\t * inode invalid, and don't bother validating the stateid\n\t\t * sequence number.\n\t\t */\n\t\tpnfs_mark_matching_lsegs_invalid(lo, &free_me, NULL);\n\n\t\tnfs4_stateid_copy(&lo->plh_stateid, &res->stateid);\n\t\tlo->plh_barrier = be32_to_cpu(res->stateid.seqid);\n\t}\n\n\tclear_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\n\tpnfs_get_lseg(lseg);\n\tpnfs_layout_insert_lseg(lo, lseg);\n\n\tif (res->return_on_close) {\n\t\tset_bit(NFS_LSEG_ROC, &lseg->pls_flags);\n\t\tset_bit(NFS_LAYOUT_ROC, &lo->plh_flags);\n\t}\n\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n\treturn lseg;\nout:\n\treturn ERR_PTR(status);\n\nout_forget_reply:\n\tspin_unlock(&ino->i_lock);\n\tlseg->pls_layout = lo;\n\tNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\n\tgoto out;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lseg"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&free_me"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_ROC",
            "&lo->plh_flags"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_insert_lseg",
          "args": [
            "lo",
            "lseg"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_insert_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1205-1235",
          "snippet": "static void\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\n\t\t   struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *lp;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lp, &lo->plh_segs, pls_list) {\n\t\tif (pnfs_lseg_range_cmp(&lseg->pls_range, &lp->pls_range) > 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&lseg->pls_list, &lp->pls_list);\n\t\tdprintk(\"%s: inserted lseg %p \"\n\t\t\t\"iomode %d offset %llu length %llu before \"\n\t\t\t\"lp %p iomode %d offset %llu length %llu\\n\",\n\t\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\t\tlseg->pls_range.offset, lseg->pls_range.length,\n\t\t\tlp, lp->pls_range.iomode, lp->pls_range.offset,\n\t\t\tlp->pls_range.length);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&lseg->pls_list, &lo->plh_segs);\n\tdprintk(\"%s: inserted lseg %p \"\n\t\t\"iomode %d offset %llu length %llu at tail\\n\",\n\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\tlseg->pls_range.offset, lseg->pls_range.length);\nout:\n\tpnfs_get_layout_hdr(lo);\n\n\tdprintk(\"%s:Return\\n\", __func__);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\n\t\t   struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *lp;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lp, &lo->plh_segs, pls_list) {\n\t\tif (pnfs_lseg_range_cmp(&lseg->pls_range, &lp->pls_range) > 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&lseg->pls_list, &lp->pls_list);\n\t\tdprintk(\"%s: inserted lseg %p \"\n\t\t\t\"iomode %d offset %llu length %llu before \"\n\t\t\t\"lp %p iomode %d offset %llu length %llu\\n\",\n\t\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\t\tlseg->pls_range.offset, lseg->pls_range.length,\n\t\t\tlp, lp->pls_range.iomode, lp->pls_range.offset,\n\t\t\tlp->pls_range.length);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&lseg->pls_list, &lo->plh_segs);\n\tdprintk(\"%s: inserted lseg %p \"\n\t\t\"iomode %d offset %llu length %llu at tail\\n\",\n\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\tlseg->pls_range.offset, lseg->pls_range.length);\nout:\n\tpnfs_get_layout_hdr(lo);\n\n\tdprintk(\"%s:Return\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "lseg"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_LAYOUT_INVALID_STID",
            "&lo->plh_flags"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "res->stateid.seqid"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "&lo->plh_stateid",
            "&res->stateid"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&free_me",
            "NULL"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_set_layout_stateid",
          "args": [
            "lo",
            "&res->stateid",
            "false"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "769-791",
          "snippet": "void\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s forget reply due to sequence\\n\"",
            "__func__"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layout_stateid_blocked",
          "args": [
            "lo",
            "&res->stateid"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_stateid_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "793-800",
          "snippet": "static bool\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\n\t\tconst nfs4_stateid *stateid)\n{\n\tu32 seqid = be32_to_cpu(stateid->seqid);\n\n\treturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\n\t\tconst nfs4_stateid *stateid)\n{\n\tu32 seqid = be32_to_cpu(stateid->seqid);\n\n\treturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_match_other",
          "args": [
            "&lo->plh_stateid",
            "&res->stateid"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_match_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "506-509",
          "snippet": "static inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s forget reply due to state\\n\"",
            "__func__"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutgets_blocked",
          "args": [
            "lo",
            "&lgp->args.range",
            "1"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutgets_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "812-821",
          "snippet": "static bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s forget reply due to recall\\n\"",
            "__func__"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_BULK_RECALL",
            "&lo->plh_flags"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_lseg",
          "args": [
            "lo",
            "lseg"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "init_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "314-323",
          "snippet": "static void\ninit_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg)\n{\n\tINIT_LIST_HEAD(&lseg->pls_list);\n\tINIT_LIST_HEAD(&lseg->pls_lc_list);\n\tatomic_set(&lseg->pls_refcount, 1);\n\tsmp_mb();\n\tset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\n\tlseg->pls_layout = lo;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\ninit_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg)\n{\n\tINIT_LIST_HEAD(&lseg->pls_list);\n\tINIT_LIST_HEAD(&lseg->pls_lc_list);\n\tatomic_set(&lseg->pls_refcount, 1);\n\tsmp_mb();\n\tset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\n\tlseg->pls_layout = lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Could not allocate layout: error %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lseg"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lseg"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo",
            "res",
            "lgp->gfp_flags"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "free_me"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "lgp->args.inode"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_layout_process(struct nfs4_layoutget *lgp)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(lgp->args.inode)->layout;\n\tstruct nfs4_layoutget_res *res = &lgp->res;\n\tstruct pnfs_layout_segment *lseg;\n\tstruct inode *ino = lo->plh_inode;\n\tLIST_HEAD(free_me);\n\tint status = 0;\n\n\t/* Inject layout blob into I/O device driver */\n\tlseg = NFS_SERVER(ino)->pnfs_curr_ld->alloc_lseg(lo, res, lgp->gfp_flags);\n\tif (!lseg || IS_ERR(lseg)) {\n\t\tif (!lseg)\n\t\t\tstatus = -ENOMEM;\n\t\telse\n\t\t\tstatus = PTR_ERR(lseg);\n\t\tdprintk(\"%s: Could not allocate layout: error %d\\n\",\n\t\t       __func__, status);\n\t\tgoto out;\n\t}\n\n\tinit_lseg(lo, lseg);\n\tlseg->pls_range = res->range;\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s forget reply due to recall\\n\", __func__);\n\t\tgoto out_forget_reply;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &lgp->args.range, 1)) {\n\t\tdprintk(\"%s forget reply due to state\\n\", __func__);\n\t\tgoto out_forget_reply;\n\t}\n\n\tif (nfs4_stateid_match_other(&lo->plh_stateid, &res->stateid)) {\n\t\t/* existing state ID, make sure the sequence number matches. */\n\t\tif (pnfs_layout_stateid_blocked(lo, &res->stateid)) {\n\t\t\tdprintk(\"%s forget reply due to sequence\\n\", __func__);\n\t\t\tgoto out_forget_reply;\n\t\t}\n\t\tpnfs_set_layout_stateid(lo, &res->stateid, false);\n\t} else {\n\t\t/*\n\t\t * We got an entirely new state ID.  Mark all segments for the\n\t\t * inode invalid, and don't bother validating the stateid\n\t\t * sequence number.\n\t\t */\n\t\tpnfs_mark_matching_lsegs_invalid(lo, &free_me, NULL);\n\n\t\tnfs4_stateid_copy(&lo->plh_stateid, &res->stateid);\n\t\tlo->plh_barrier = be32_to_cpu(res->stateid.seqid);\n\t}\n\n\tclear_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\n\tpnfs_get_lseg(lseg);\n\tpnfs_layout_insert_lseg(lo, lseg);\n\n\tif (res->return_on_close) {\n\t\tset_bit(NFS_LSEG_ROC, &lseg->pls_flags);\n\t\tset_bit(NFS_LAYOUT_ROC, &lo->plh_flags);\n\t}\n\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n\treturn lseg;\nout:\n\treturn ERR_PTR(status);\n\nout_forget_reply:\n\tspin_unlock(&ino->i_lock);\n\tlseg->pls_layout = lo;\n\tNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\n\tgoto out;\n}"
  },
  {
    "function_name": "pnfs_update_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1445-1574",
    "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\"",
            "__func__",
            "ino->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(ino)",
            "lseg == NULL ? \"not found\" : \"found\"",
            "iomode==IOMODE_RW ?  \"read/write\" : \"read-only\"",
            "(unsigned long long)pos",
            "(unsigned long long)count"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "ino"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_first_layoutget",
          "args": [
            "lo"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_first_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1432-1439",
          "snippet": "static void pnfs_clear_first_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tunsigned long *bitlock = &lo->plh_flags;\n\n\tclear_bit_unlock(NFS_LAYOUT_FIRST_LAYOUTGET, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_LAYOUT_FIRST_LAYOUTGET);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_first_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tunsigned long *bitlock = &lo->plh_flags;\n\n\tclear_bit_unlock(NFS_LAYOUT_FIRST_LAYOUTGET, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_LAYOUT_FIRST_LAYOUTGET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&lo->plh_outstanding"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "lo"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_layoutget",
          "args": [
            "lo",
            "ctx",
            "&arg",
            "gfp_flags"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "send_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "857-904",
          "snippet": "static struct pnfs_layout_segment *\nsend_layoutget(struct pnfs_layout_hdr *lo,\n\t   struct nfs_open_context *ctx,\n\t   struct pnfs_layout_range *range,\n\t   gfp_t gfp_flags)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs4_layoutget *lgp;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp = kzalloc(sizeof(*lgp), gfp_flags);\n\tif (lgp == NULL)\n\t\treturn NULL;\n\n\tlgp->args.minlength = PAGE_CACHE_SIZE;\n\tif (lgp->args.minlength > range->length)\n\t\tlgp->args.minlength = range->length;\n\tlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\n\tlgp->args.range = *range;\n\tlgp->args.type = server->pnfs_curr_ld->id;\n\tlgp->args.inode = ino;\n\tlgp->args.ctx = get_nfs_open_context(ctx);\n\tlgp->gfp_flags = gfp_flags;\n\tlgp->cred = lo->plh_lc_cred;\n\n\t/* Synchronously retrieve layout information from server and\n\t * store in lseg.\n\t */\n\tlseg = nfs4_proc_layoutget(lgp, gfp_flags);\n\tif (IS_ERR(lseg)) {\n\t\tswitch (PTR_ERR(lseg)) {\n\t\tcase -ENOMEM:\n\t\tcase -ERESTARTSYS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* remember that LAYOUTGET failed and suspend trying */\n\t\t\tpnfs_layout_io_set_failed(lo, range->iomode);\n\t\t}\n\t\treturn NULL;\n\t} else\n\t\tpnfs_layout_clear_fail_bit(lo,\n\t\t\t\tpnfs_iomode_to_fail_bit(range->iomode));\n\n\treturn lseg;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\nsend_layoutget(struct pnfs_layout_hdr *lo,\n\t   struct nfs_open_context *ctx,\n\t   struct pnfs_layout_range *range,\n\t   gfp_t gfp_flags)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs4_layoutget *lgp;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp = kzalloc(sizeof(*lgp), gfp_flags);\n\tif (lgp == NULL)\n\t\treturn NULL;\n\n\tlgp->args.minlength = PAGE_CACHE_SIZE;\n\tif (lgp->args.minlength > range->length)\n\t\tlgp->args.minlength = range->length;\n\tlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\n\tlgp->args.range = *range;\n\tlgp->args.type = server->pnfs_curr_ld->id;\n\tlgp->args.inode = ino;\n\tlgp->args.ctx = get_nfs_open_context(ctx);\n\tlgp->gfp_flags = gfp_flags;\n\tlgp->cred = lo->plh_lc_cred;\n\n\t/* Synchronously retrieve layout information from server and\n\t * store in lseg.\n\t */\n\tlseg = nfs4_proc_layoutget(lgp, gfp_flags);\n\tif (IS_ERR(lseg)) {\n\t\tswitch (PTR_ERR(lseg)) {\n\t\tcase -ENOMEM:\n\t\tcase -ERESTARTSYS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* remember that LAYOUTGET failed and suspend trying */\n\t\t\tpnfs_layout_io_set_failed(lo, range->iomode);\n\t\t}\n\t\treturn NULL;\n\t} else\n\t\tpnfs_layout_clear_fail_bit(lo,\n\t\t\t\tpnfs_iomode_to_fail_bit(range->iomode));\n\n\treturn lseg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "arg.length"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lo->plh_layouts",
            "&server->layouts"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_layouts"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lo->plh_outstanding"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutgets_blocked",
          "args": [
            "lo",
            "&arg",
            "0"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutgets_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "812-821",
          "snippet": "static bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s retrying\\n\"",
            "__func__"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_prepare_to_retry_layoutget",
          "args": [
            "lo"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_prepare_to_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1420-1430",
          "snippet": "static bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\t/*\n\t * send layoutcommit as it can hold up layoutreturn due to lseg\n\t * reference\n\t */\n\tpnfs_layoutcommit_inode(lo->plh_inode, false);\n\treturn !wait_on_bit_action(&lo->plh_flags, NFS_LAYOUT_RETURN,\n\t\t\t\t   pnfs_layoutget_retry_bit_wait,\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\t/*\n\t * send layoutcommit as it can hold up layoutreturn due to lseg\n\t * reference\n\t */\n\tpnfs_layoutcommit_inode(lo->plh_inode, false);\n\treturn !wait_on_bit_action(&lo->plh_flags, NFS_LAYOUT_RETURN,\n\t\t\t\t   pnfs_layoutget_retry_bit_wait,\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s wait for layoutreturn\\n\"",
            "__func__"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_RETURN",
            "&lo->plh_flags"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_should_retry_layoutget",
          "args": [
            "lo"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_should_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "379-382",
          "snippet": "static inline bool pnfs_should_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\treturn test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline bool pnfs_should_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\treturn test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_find_lseg",
          "args": [
            "lo",
            "&arg"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_find_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1313-1335",
          "snippet": "static struct pnfs_layout_segment *\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_segment *lseg, *ret = NULL;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\n\t\tif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\n\t\t    !test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\n\t\t    pnfs_lseg_range_match(&lseg->pls_range, range)) {\n\t\t\tret = pnfs_get_lseg(lseg);\n\t\t\tbreak;\n\t\t}\n\t\tif (lseg->pls_range.offset > range->offset)\n\t\t\tbreak;\n\t}\n\n\tdprintk(\"%s:Return lseg %p ref %d\\n\",\n\t\t__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_segment *lseg, *ret = NULL;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\n\t\tif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\n\t\t    !test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\n\t\t    pnfs_lseg_range_match(&lseg->pls_range, range)) {\n\t\t\tret = pnfs_get_lseg(lseg);\n\t\t\tbreak;\n\t\t}\n\t\tif (lseg->pls_range.offset > range->offset)\n\t\t\tbreak;\n\t}\n\n\tdprintk(\"%s:Return lseg %p ref %d\\n\",\n\t\t__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&lo->plh_flags",
            "NFS_LAYOUT_FIRST_LAYOUTGET",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_LAYOUT_FIRST_LAYOUTGET",
            "&lo->plh_flags"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_io_test_failed",
          "args": [
            "lo",
            "iomode"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_io_test_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "296-312",
          "snippet": "static bool\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tunsigned long start, end;\n\tint fail_bit = pnfs_iomode_to_fail_bit(iomode);\n\n\tif (test_bit(fail_bit, &lo->plh_flags) == 0)\n\t\treturn false;\n\tend = jiffies;\n\tstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\n\tif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\n\t\t/* It is time to retry the failed layoutgets */\n\t\tpnfs_layout_clear_fail_bit(lo, fail_bit);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [
            "#define PNFS_LAYOUTGET_RETRY_TIMEOUT (120*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define PNFS_LAYOUTGET_RETRY_TIMEOUT (120*HZ)\n\nstatic bool\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tunsigned long start, end;\n\tint fail_bit = pnfs_iomode_to_fail_bit(iomode);\n\n\tif (test_bit(fail_bit, &lo->plh_flags) == 0)\n\t\treturn false;\n\tend = jiffies;\n\tstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\n\tif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\n\t\t/* It is time to retry the failed layoutgets */\n\t\tpnfs_layout_clear_fail_bit(lo, fail_bit);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s matches recall, use MDS\\n\"",
            "__func__"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_find_alloc_layout",
          "args": [
            "ino",
            "ctx",
            "gfp_flags"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_find_alloc_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1256-1280",
          "snippet": "static struct pnfs_layout_hdr *\npnfs_find_alloc_layout(struct inode *ino,\n\t\t       struct nfs_open_context *ctx,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *new = NULL;\n\n\tdprintk(\"%s Begin ino=%p layout=%p\\n\", __func__, ino, nfsi->layout);\n\n\tif (nfsi->layout != NULL)\n\t\tgoto out_existing;\n\tspin_unlock(&ino->i_lock);\n\tnew = alloc_init_layout_hdr(ino, ctx, gfp_flags);\n\tspin_lock(&ino->i_lock);\n\n\tif (likely(nfsi->layout == NULL)) {\t/* Won the race? */\n\t\tnfsi->layout = new;\n\t\treturn new;\n\t} else if (new != NULL)\n\t\tpnfs_free_layout_hdr(new);\nout_existing:\n\tpnfs_get_layout_hdr(nfsi->layout);\n\treturn nfsi->layout;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\npnfs_find_alloc_layout(struct inode *ino,\n\t\t       struct nfs_open_context *ctx,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *new = NULL;\n\n\tdprintk(\"%s Begin ino=%p layout=%p\\n\", __func__, ino, nfsi->layout);\n\n\tif (nfsi->layout != NULL)\n\t\tgoto out_existing;\n\tspin_unlock(&ino->i_lock);\n\tnew = alloc_init_layout_hdr(ino, ctx, gfp_flags);\n\tspin_lock(&ino->i_lock);\n\n\tif (likely(nfsi->layout == NULL)) {\t/* Won the race? */\n\t\tnfsi->layout = new;\n\t\treturn new;\n\t} else if (new != NULL)\n\t\tpnfs_free_layout_hdr(new);\nout_existing:\n\tpnfs_get_layout_hdr(nfsi->layout);\n\treturn nfsi->layout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_within_mdsthreshold",
          "args": [
            "ctx",
            "ino",
            "iomode"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_within_mdsthreshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1356-1410",
          "snippet": "static bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\n\t\t\t\t     struct inode *ino, int iomode)\n{\n\tstruct nfs4_threshold *t = ctx->mdsthreshold;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tloff_t fsize = i_size_read(ino);\n\tbool size = false, size_set = false, io = false, io_set = false, ret = false;\n\n\tif (t == NULL)\n\t\treturn ret;\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\n\n\tswitch (iomode) {\n\tcase IOMODE_READ:\n\t\tif (t->bm & THRESHOLD_RD) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->rd_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_RD_IO) {\n\t\t\tdprintk(\"%s nfsi->read_io %llu\\n\", __func__,\n\t\t\t\tnfsi->read_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->read_io < t->rd_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\tif (t->bm & THRESHOLD_WR) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->wr_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_WR_IO) {\n\t\t\tdprintk(\"%s nfsi->write_io %llu\\n\", __func__,\n\t\t\t\tnfsi->write_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->write_io < t->wr_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\t}\n\tif (size_set && io_set) {\n\t\tif (size && io)\n\t\t\tret = true;\n\t} else if (size || io)\n\t\tret = true;\n\n\tdprintk(\"<-- %s size %d io %d ret %d\\n\", __func__, size, io, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\n\t\t\t\t     struct inode *ino, int iomode)\n{\n\tstruct nfs4_threshold *t = ctx->mdsthreshold;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tloff_t fsize = i_size_read(ino);\n\tbool size = false, size_set = false, io = false, io_set = false, ret = false;\n\n\tif (t == NULL)\n\t\treturn ret;\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\n\n\tswitch (iomode) {\n\tcase IOMODE_READ:\n\t\tif (t->bm & THRESHOLD_RD) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->rd_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_RD_IO) {\n\t\t\tdprintk(\"%s nfsi->read_io %llu\\n\", __func__,\n\t\t\t\tnfsi->read_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->read_io < t->rd_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\tif (t->bm & THRESHOLD_WR) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->wr_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_WR_IO) {\n\t\t\tdprintk(\"%s nfsi->write_io %llu\\n\", __func__,\n\t\t\t\tnfsi->write_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->write_io < t->wr_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\t}\n\tif (size_set && io_set) {\n\t\tif (size && io)\n\t\t\tret = true;\n\t} else if (size || io)\n\t\tret = true;\n\n\tdprintk(\"<-- %s size %d io %d ret %d\\n\", __func__, size, io, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_enabled_sb",
          "args": [
            "NFS_SERVER(ino)"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_enabled_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "395-398",
          "snippet": "static inline int pnfs_enabled_sb(struct nfs_server *nfss)\n{\n\treturn nfss->pnfs_curr_ld != NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int pnfs_enabled_sb(struct nfs_server *nfss)\n{\n\treturn nfss->pnfs_curr_ld != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
  },
  {
    "function_name": "pnfs_clear_first_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1432-1439",
    "snippet": "static void pnfs_clear_first_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tunsigned long *bitlock = &lo->plh_flags;\n\n\tclear_bit_unlock(NFS_LAYOUT_FIRST_LAYOUTGET, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_LAYOUT_FIRST_LAYOUTGET);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "bitlock",
            "NFS_LAYOUT_FIRST_LAYOUTGET"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "NFS_LAYOUT_FIRST_LAYOUTGET",
            "bitlock"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_first_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tunsigned long *bitlock = &lo->plh_flags;\n\n\tclear_bit_unlock(NFS_LAYOUT_FIRST_LAYOUTGET, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_LAYOUT_FIRST_LAYOUTGET);\n}"
  },
  {
    "function_name": "pnfs_prepare_to_retry_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1420-1430",
    "snippet": "static bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\t/*\n\t * send layoutcommit as it can hold up layoutreturn due to lseg\n\t * reference\n\t */\n\tpnfs_layoutcommit_inode(lo->plh_inode, false);\n\treturn !wait_on_bit_action(&lo->plh_flags, NFS_LAYOUT_RETURN,\n\t\t\t\t   pnfs_layoutget_retry_bit_wait,\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_action",
          "args": [
            "&lo->plh_flags",
            "NFS_LAYOUT_RETURN",
            "pnfs_layoutget_retry_bit_wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "lo->plh_inode",
            "false"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2178-2258",
          "snippet": "int\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nint\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\t/*\n\t * send layoutcommit as it can hold up layoutreturn due to lseg\n\t * reference\n\t */\n\tpnfs_layoutcommit_inode(lo->plh_inode, false);\n\treturn !wait_on_bit_action(&lo->plh_flags, NFS_LAYOUT_RETURN,\n\t\t\t\t   pnfs_layoutget_retry_bit_wait,\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "pnfs_layoutget_retry_bit_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1413-1418",
    "snippet": "static int pnfs_layoutget_retry_bit_wait(struct wait_bit_key *key)\n{\n\tif (!test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, key->flags))\n\t\treturn 1;\n\treturn nfs_wait_bit_killable(key);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_wait_bit_killable",
          "args": [
            "key"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wait_bit_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "78-84",
          "snippet": "int nfs_wait_bit_killable(struct wait_bit_key *key)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tfreezable_schedule_unsafe();\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint nfs_wait_bit_killable(struct wait_bit_key *key)\n{\n\tif (fatal_signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\tfreezable_schedule_unsafe();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_RETRY_LAYOUTGET",
            "key->flags"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int pnfs_layoutget_retry_bit_wait(struct wait_bit_key *key)\n{\n\tif (!test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, key->flags))\n\t\treturn 1;\n\treturn nfs_wait_bit_killable(key);\n}"
  },
  {
    "function_name": "pnfs_within_mdsthreshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1356-1410",
    "snippet": "static bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\n\t\t\t\t     struct inode *ino, int iomode)\n{\n\tstruct nfs4_threshold *t = ctx->mdsthreshold;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tloff_t fsize = i_size_read(ino);\n\tbool size = false, size_set = false, io = false, io_set = false, ret = false;\n\n\tif (t == NULL)\n\t\treturn ret;\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\n\n\tswitch (iomode) {\n\tcase IOMODE_READ:\n\t\tif (t->bm & THRESHOLD_RD) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->rd_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_RD_IO) {\n\t\t\tdprintk(\"%s nfsi->read_io %llu\\n\", __func__,\n\t\t\t\tnfsi->read_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->read_io < t->rd_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\tif (t->bm & THRESHOLD_WR) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->wr_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_WR_IO) {\n\t\t\tdprintk(\"%s nfsi->write_io %llu\\n\", __func__,\n\t\t\t\tnfsi->write_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->write_io < t->wr_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\t}\n\tif (size_set && io_set) {\n\t\tif (size && io)\n\t\t\tret = true;\n\t} else if (size || io)\n\t\tret = true;\n\n\tdprintk(\"<-- %s size %d io %d ret %d\\n\", __func__, size, io, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s size %d io %d ret %d\\n\"",
            "__func__",
            "size",
            "io",
            "ret"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s nfsi->write_io %llu\\n\"",
            "__func__",
            "nfsi->write_io"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s fsize %llu\\n\"",
            "__func__",
            "fsize"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s nfsi->read_io %llu\\n\"",
            "__func__",
            "nfsi->read_io"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s fsize %llu\\n\"",
            "__func__",
            "fsize"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\"",
            "__func__",
            "t->bm",
            "t->rd_sz",
            "t->wr_sz",
            "t->rd_io_sz",
            "t->wr_io_sz"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ino"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\n\t\t\t\t     struct inode *ino, int iomode)\n{\n\tstruct nfs4_threshold *t = ctx->mdsthreshold;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tloff_t fsize = i_size_read(ino);\n\tbool size = false, size_set = false, io = false, io_set = false, ret = false;\n\n\tif (t == NULL)\n\t\treturn ret;\n\n\tdprintk(\"%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\\n\",\n\t\t__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\n\n\tswitch (iomode) {\n\tcase IOMODE_READ:\n\t\tif (t->bm & THRESHOLD_RD) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->rd_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_RD_IO) {\n\t\t\tdprintk(\"%s nfsi->read_io %llu\\n\", __func__,\n\t\t\t\tnfsi->read_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->read_io < t->rd_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\tif (t->bm & THRESHOLD_WR) {\n\t\t\tdprintk(\"%s fsize %llu\\n\", __func__, fsize);\n\t\t\tsize_set = true;\n\t\t\tif (fsize < t->wr_sz)\n\t\t\t\tsize = true;\n\t\t}\n\t\tif (t->bm & THRESHOLD_WR_IO) {\n\t\t\tdprintk(\"%s nfsi->write_io %llu\\n\", __func__,\n\t\t\t\tnfsi->write_io);\n\t\t\tio_set = true;\n\t\t\tif (nfsi->write_io < t->wr_io_sz)\n\t\t\t\tio = true;\n\t\t}\n\t\tbreak;\n\t}\n\tif (size_set && io_set) {\n\t\tif (size && io)\n\t\t\tret = true;\n\t} else if (size || io)\n\t\tret = true;\n\n\tdprintk(\"<-- %s size %d io %d ret %d\\n\", __func__, size, io, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_find_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1313-1335",
    "snippet": "static struct pnfs_layout_segment *\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_segment *lseg, *ret = NULL;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\n\t\tif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\n\t\t    !test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\n\t\t    pnfs_lseg_range_match(&lseg->pls_range, range)) {\n\t\t\tret = pnfs_get_lseg(lseg);\n\t\t\tbreak;\n\t\t}\n\t\tif (lseg->pls_range.offset > range->offset)\n\t\t\tbreak;\n\t}\n\n\tdprintk(\"%s:Return lseg %p ref %d\\n\",\n\t\t__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Return lseg %p ref %d\\n\"",
            "__func__",
            "ret",
            "ret ? atomic_read(&ret->pls_refcount) : 0"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ret->pls_refcount"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_get_lseg",
          "args": [
            "lseg"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "539-543",
          "snippet": "static inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_layout_segment *\npnfs_get_lseg(struct pnfs_layout_segment *lseg)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_lseg_range_match",
          "args": [
            "&lseg->pls_range",
            "range"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_range_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1293-1308",
          "snippet": "static bool\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\n\t\t const struct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_range range1;\n\n\tif ((range->iomode == IOMODE_RW &&\n\t     ls_range->iomode != IOMODE_RW) ||\n\t    !pnfs_lseg_range_intersecting(ls_range, range))\n\t\treturn 0;\n\n\t/* range1 covers only the first byte in the range */\n\trange1 = *range;\n\trange1.length = 1;\n\treturn pnfs_lseg_range_contained(ls_range, &range1);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\n\t\t const struct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_range range1;\n\n\tif ((range->iomode == IOMODE_RW &&\n\t     ls_range->iomode != IOMODE_RW) ||\n\t    !pnfs_lseg_range_intersecting(ls_range, range))\n\t\treturn 0;\n\n\t/* range1 covers only the first byte in the range */\n\trange1 = *range;\n\trange1.length = 1;\n\treturn pnfs_lseg_range_contained(ls_range, &range1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_LAYOUTRETURN",
            "&lseg->pls_flags"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lseg",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Begin\\n\"",
            "__func__"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_segment *lseg, *ret = NULL;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\n\t\tif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\n\t\t    !test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\n\t\t    pnfs_lseg_range_match(&lseg->pls_range, range)) {\n\t\t\tret = pnfs_get_lseg(lseg);\n\t\t\tbreak;\n\t\t}\n\t\tif (lseg->pls_range.offset > range->offset)\n\t\t\tbreak;\n\t}\n\n\tdprintk(\"%s:Return lseg %p ref %d\\n\",\n\t\t__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_lseg_range_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1293-1308",
    "snippet": "static bool\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\n\t\t const struct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_range range1;\n\n\tif ((range->iomode == IOMODE_RW &&\n\t     ls_range->iomode != IOMODE_RW) ||\n\t    !pnfs_lseg_range_intersecting(ls_range, range))\n\t\treturn 0;\n\n\t/* range1 covers only the first byte in the range */\n\trange1 = *range;\n\trange1.length = 1;\n\treturn pnfs_lseg_range_contained(ls_range, &range1);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_lseg_range_contained",
          "args": [
            "ls_range",
            "&range1"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_range_contained",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "476-486",
          "snippet": "static bool\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\n\t\t const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (start1 <= start2) && (end1 >= end2);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\n\t\t const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (start1 <= start2) && (end1 >= end2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_lseg_range_intersecting",
          "args": [
            "ls_range",
            "range"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_range_intersecting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "495-506",
          "snippet": "static bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\n\t\t const struct pnfs_layout_range *range)\n{\n\tstruct pnfs_layout_range range1;\n\n\tif ((range->iomode == IOMODE_RW &&\n\t     ls_range->iomode != IOMODE_RW) ||\n\t    !pnfs_lseg_range_intersecting(ls_range, range))\n\t\treturn 0;\n\n\t/* range1 covers only the first byte in the range */\n\trange1 = *range;\n\trange1.length = 1;\n\treturn pnfs_lseg_range_contained(ls_range, &range1);\n}"
  },
  {
    "function_name": "pnfs_find_alloc_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1256-1280",
    "snippet": "static struct pnfs_layout_hdr *\npnfs_find_alloc_layout(struct inode *ino,\n\t\t       struct nfs_open_context *ctx,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *new = NULL;\n\n\tdprintk(\"%s Begin ino=%p layout=%p\\n\", __func__, ino, nfsi->layout);\n\n\tif (nfsi->layout != NULL)\n\t\tgoto out_existing;\n\tspin_unlock(&ino->i_lock);\n\tnew = alloc_init_layout_hdr(ino, ctx, gfp_flags);\n\tspin_lock(&ino->i_lock);\n\n\tif (likely(nfsi->layout == NULL)) {\t/* Won the race? */\n\t\tnfsi->layout = new;\n\t\treturn new;\n\t} else if (new != NULL)\n\t\tpnfs_free_layout_hdr(new);\nout_existing:\n\tpnfs_get_layout_hdr(nfsi->layout);\n\treturn nfsi->layout;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "nfsi->layout"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_layout_hdr",
          "args": [
            "new"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "212-227",
          "snippet": "static void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nfsi->layout == NULL"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_init_layout_hdr",
          "args": [
            "ino",
            "ctx",
            "gfp_flags"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1237-1254",
          "snippet": "static struct pnfs_layout_hdr *\nalloc_init_layout_hdr(struct inode *ino,\n\t\t      struct nfs_open_context *ctx,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\n\tif (!lo)\n\t\treturn NULL;\n\tatomic_set(&lo->plh_refcount, 1);\n\tINIT_LIST_HEAD(&lo->plh_layouts);\n\tINIT_LIST_HEAD(&lo->plh_segs);\n\tINIT_LIST_HEAD(&lo->plh_bulk_destroy);\n\tlo->plh_inode = ino;\n\tlo->plh_lc_cred = get_rpccred(ctx->cred);\n\treturn lo;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\nalloc_init_layout_hdr(struct inode *ino,\n\t\t      struct nfs_open_context *ctx,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\n\tif (!lo)\n\t\treturn NULL;\n\tatomic_set(&lo->plh_refcount, 1);\n\tINIT_LIST_HEAD(&lo->plh_layouts);\n\tINIT_LIST_HEAD(&lo->plh_segs);\n\tINIT_LIST_HEAD(&lo->plh_bulk_destroy);\n\tlo->plh_inode = ino;\n\tlo->plh_lc_cred = get_rpccred(ctx->cred);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Begin ino=%p layout=%p\\n\"",
            "__func__",
            "ino",
            "nfsi->layout"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\npnfs_find_alloc_layout(struct inode *ino,\n\t\t       struct nfs_open_context *ctx,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *new = NULL;\n\n\tdprintk(\"%s Begin ino=%p layout=%p\\n\", __func__, ino, nfsi->layout);\n\n\tif (nfsi->layout != NULL)\n\t\tgoto out_existing;\n\tspin_unlock(&ino->i_lock);\n\tnew = alloc_init_layout_hdr(ino, ctx, gfp_flags);\n\tspin_lock(&ino->i_lock);\n\n\tif (likely(nfsi->layout == NULL)) {\t/* Won the race? */\n\t\tnfsi->layout = new;\n\t\treturn new;\n\t} else if (new != NULL)\n\t\tpnfs_free_layout_hdr(new);\nout_existing:\n\tpnfs_get_layout_hdr(nfsi->layout);\n\treturn nfsi->layout;\n}"
  },
  {
    "function_name": "alloc_init_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1237-1254",
    "snippet": "static struct pnfs_layout_hdr *\nalloc_init_layout_hdr(struct inode *ino,\n\t\t      struct nfs_open_context *ctx,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\n\tif (!lo)\n\t\treturn NULL;\n\tatomic_set(&lo->plh_refcount, 1);\n\tINIT_LIST_HEAD(&lo->plh_layouts);\n\tINIT_LIST_HEAD(&lo->plh_segs);\n\tINIT_LIST_HEAD(&lo->plh_bulk_destroy);\n\tlo->plh_inode = ino;\n\tlo->plh_lc_cred = get_rpccred(ctx->cred);\n\treturn lo;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "ctx->cred"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lo->plh_bulk_destroy"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lo->plh_layouts"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&lo->plh_refcount",
            "1"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_alloc_layout_hdr",
          "args": [
            "ino",
            "gfp_flags"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_alloc_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "205-210",
          "snippet": "static struct pnfs_layout_hdr *\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\n\treturn ld->alloc_layout_hdr(ino, gfp_flags);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\n\treturn ld->alloc_layout_hdr(ino, gfp_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\nalloc_init_layout_hdr(struct inode *ino,\n\t\t      struct nfs_open_context *ctx,\n\t\t      gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\n\tif (!lo)\n\t\treturn NULL;\n\tatomic_set(&lo->plh_refcount, 1);\n\tINIT_LIST_HEAD(&lo->plh_layouts);\n\tINIT_LIST_HEAD(&lo->plh_segs);\n\tINIT_LIST_HEAD(&lo->plh_bulk_destroy);\n\tlo->plh_inode = ino;\n\tlo->plh_lc_cred = get_rpccred(ctx->cred);\n\treturn lo;\n}"
  },
  {
    "function_name": "pnfs_layout_insert_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1205-1235",
    "snippet": "static void\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\n\t\t   struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *lp;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lp, &lo->plh_segs, pls_list) {\n\t\tif (pnfs_lseg_range_cmp(&lseg->pls_range, &lp->pls_range) > 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&lseg->pls_list, &lp->pls_list);\n\t\tdprintk(\"%s: inserted lseg %p \"\n\t\t\t\"iomode %d offset %llu length %llu before \"\n\t\t\t\"lp %p iomode %d offset %llu length %llu\\n\",\n\t\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\t\tlseg->pls_range.offset, lseg->pls_range.length,\n\t\t\tlp, lp->pls_range.iomode, lp->pls_range.offset,\n\t\t\tlp->pls_range.length);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&lseg->pls_list, &lo->plh_segs);\n\tdprintk(\"%s: inserted lseg %p \"\n\t\t\"iomode %d offset %llu length %llu at tail\\n\",\n\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\tlseg->pls_range.offset, lseg->pls_range.length);\nout:\n\tpnfs_get_layout_hdr(lo);\n\n\tdprintk(\"%s:Return\\n\", __func__);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Return\\n\"",
            "__func__"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: inserted lseg %p \"\n\t\t\"iomode %d offset %llu length %llu at tail\\n\"",
            "__func__",
            "lseg",
            "lseg->pls_range.iomode",
            "lseg->pls_range.offset",
            "lseg->pls_range.length"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lseg->pls_list",
            "&lo->plh_segs"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: inserted lseg %p \"\n\t\t\t\"iomode %d offset %llu length %llu before \"\n\t\t\t\"lp %p iomode %d offset %llu length %llu\\n\"",
            "__func__",
            "lseg",
            "lseg->pls_range.iomode",
            "lseg->pls_range.offset",
            "lseg->pls_range.length",
            "lp",
            "lp->pls_range.iomode",
            "lp->pls_range.offset",
            "lp->pls_range.length"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lseg->pls_list",
            "&lp->pls_list"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_lseg_range_cmp",
          "args": [
            "&lseg->pls_range",
            "&lp->pls_range"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_range_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1185-1203",
          "snippet": "static s64\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\n\t   const struct pnfs_layout_range *l2)\n{\n\ts64 d;\n\n\t/* high offset > low offset */\n\td = l1->offset - l2->offset;\n\tif (d)\n\t\treturn d;\n\n\t/* short length > long length */\n\td = l2->length - l1->length;\n\tif (d)\n\t\treturn d;\n\n\t/* read > read/write */\n\treturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic s64\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\n\t   const struct pnfs_layout_range *l2)\n{\n\ts64 d;\n\n\t/* high offset > low offset */\n\td = l1->offset - l2->offset;\n\tif (d)\n\t\treturn d;\n\n\t/* short length > long length */\n\td = l2->length - l1->length;\n\tif (d)\n\t\treturn d;\n\n\t/* read > read/write */\n\treturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Begin\\n\"",
            "__func__"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\n\t\t   struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *lp;\n\n\tdprintk(\"%s:Begin\\n\", __func__);\n\n\tlist_for_each_entry(lp, &lo->plh_segs, pls_list) {\n\t\tif (pnfs_lseg_range_cmp(&lseg->pls_range, &lp->pls_range) > 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&lseg->pls_list, &lp->pls_list);\n\t\tdprintk(\"%s: inserted lseg %p \"\n\t\t\t\"iomode %d offset %llu length %llu before \"\n\t\t\t\"lp %p iomode %d offset %llu length %llu\\n\",\n\t\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\t\tlseg->pls_range.offset, lseg->pls_range.length,\n\t\t\tlp, lp->pls_range.iomode, lp->pls_range.offset,\n\t\t\tlp->pls_range.length);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&lseg->pls_list, &lo->plh_segs);\n\tdprintk(\"%s: inserted lseg %p \"\n\t\t\"iomode %d offset %llu length %llu at tail\\n\",\n\t\t__func__, lseg, lseg->pls_range.iomode,\n\t\tlseg->pls_range.offset, lseg->pls_range.length);\nout:\n\tpnfs_get_layout_hdr(lo);\n\n\tdprintk(\"%s:Return\\n\", __func__);\n}"
  },
  {
    "function_name": "pnfs_lseg_range_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1185-1203",
    "snippet": "static s64\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\n\t   const struct pnfs_layout_range *l2)\n{\n\ts64 d;\n\n\t/* high offset > low offset */\n\td = l1->offset - l2->offset;\n\tif (d)\n\t\treturn d;\n\n\t/* short length > long length */\n\td = l2->length - l1->length;\n\tif (d)\n\t\treturn d;\n\n\t/* read > read/write */\n\treturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic s64\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\n\t   const struct pnfs_layout_range *l2)\n{\n\ts64 d;\n\n\t/* high offset > low offset */\n\td = l1->offset - l2->offset;\n\tif (d)\n\t\treturn d;\n\n\t/* short length > long length */\n\td = l2->length - l1->length;\n\tif (d)\n\t\treturn d;\n\n\t/* read > read/write */\n\treturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\n}"
  },
  {
    "function_name": "pnfs_roc_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1138-1178",
    "snippet": "bool pnfs_roc_drain(struct inode *ino, u32 *barrier, struct rpc_task *task)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg;\n\tnfs4_stateid stateid;\n\tu32 current_seqid;\n\tbool found = false, layoutreturn = false;\n\n\tspin_lock(&ino->i_lock);\n\tlist_for_each_entry(lseg, &nfsi->layout->plh_segs, pls_list)\n\t\tif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\n\t\t\trpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\tlo = nfsi->layout;\n\tcurrent_seqid = be32_to_cpu(lo->plh_stateid.seqid);\n\n\t/* Since close does not return a layout stateid for use as\n\t * a barrier, we choose the worst-case barrier.\n\t */\n\t*barrier = current_seqid + atomic_read(&lo->plh_outstanding);\nout:\n\tif (!found) {\n\t\tstateid = lo->plh_stateid;\n\t\tlayoutreturn =\n\t\t\ttest_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t   &lo->plh_flags);\n\t\tif (layoutreturn) {\n\t\t\tlo->plh_block_lgets++;\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t}\n\t}\n\tspin_unlock(&ino->i_lock);\n\tif (layoutreturn) {\n\t\trpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\n\t\tpnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, false);\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_send_layoutreturn",
          "args": [
            "lo",
            "stateid",
            "IOMODE_ANY",
            "false"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_send_layoutreturn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "928-962",
          "snippet": "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&NFS_SERVER(ino)->roc_rpcwaitq",
            "task",
            "NULL"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_LAYOUT_RETURN_BEFORE_CLOSE",
            "&lo->plh_flags"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lo->plh_outstanding"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lo->plh_stateid.seqid"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&NFS_SERVER(ino)->roc_rpcwaitq",
            "task",
            "NULL"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_ROC",
            "&lseg->pls_flags"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lseg",
            "&nfsi->layout->plh_segs",
            "pls_list"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool pnfs_roc_drain(struct inode *ino, u32 *barrier, struct rpc_task *task)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg;\n\tnfs4_stateid stateid;\n\tu32 current_seqid;\n\tbool found = false, layoutreturn = false;\n\n\tspin_lock(&ino->i_lock);\n\tlist_for_each_entry(lseg, &nfsi->layout->plh_segs, pls_list)\n\t\tif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\n\t\t\trpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\tlo = nfsi->layout;\n\tcurrent_seqid = be32_to_cpu(lo->plh_stateid.seqid);\n\n\t/* Since close does not return a layout stateid for use as\n\t * a barrier, we choose the worst-case barrier.\n\t */\n\t*barrier = current_seqid + atomic_read(&lo->plh_outstanding);\nout:\n\tif (!found) {\n\t\tstateid = lo->plh_stateid;\n\t\tlayoutreturn =\n\t\t\ttest_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t   &lo->plh_flags);\n\t\tif (layoutreturn) {\n\t\t\tlo->plh_block_lgets++;\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t}\n\t}\n\tspin_unlock(&ino->i_lock);\n\tif (layoutreturn) {\n\t\trpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\n\t\tpnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, false);\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "pnfs_roc_set_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1127-1136",
    "snippet": "void pnfs_roc_set_barrier(struct inode *ino, u32 barrier)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&ino->i_lock);\n\tlo = NFS_I(ino)->layout;\n\tif (pnfs_seqid_is_newer(barrier, lo->plh_barrier))\n\t\tlo->plh_barrier = barrier;\n\tspin_unlock(&ino->i_lock);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_seqid_is_newer",
          "args": [
            "barrier",
            "lo->plh_barrier"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_seqid_is_newer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "763-766",
          "snippet": "static bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_roc_set_barrier(struct inode *ino, u32 barrier)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&ino->i_lock);\n\tlo = NFS_I(ino)->layout;\n\tif (pnfs_seqid_is_newer(barrier, lo->plh_barrier))\n\t\tlo->plh_barrier = barrier;\n\tspin_unlock(&ino->i_lock);\n}"
  },
  {
    "function_name": "pnfs_roc_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1112-1125",
    "snippet": "void pnfs_roc_release(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&ino->i_lock);\n\tlo = NFS_I(ino)->layout;\n\tlo->plh_block_lgets--;\n\tif (atomic_dec_and_test(&lo->plh_refcount)) {\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t} else\n\t\tspin_unlock(&ino->i_lock);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "212-227",
          "snippet": "static void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_detach_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_detach_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "229-238",
          "snippet": "static void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&lo->plh_refcount"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_roc_release(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&ino->i_lock);\n\tlo = NFS_I(ino)->layout;\n\tlo->plh_block_lgets--;\n\tif (atomic_dec_and_test(&lo->plh_refcount)) {\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t} else\n\t\tspin_unlock(&ino->i_lock);\n}"
  },
  {
    "function_name": "pnfs_roc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1053-1110",
    "snippet": "bool pnfs_roc(struct inode *ino)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\tnfs4_stateid stateid;\n\tLIST_HEAD(tmp_list);\n\tbool found = false, layoutreturn = false;\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo || !test_and_clear_bit(NFS_LAYOUT_ROC, &lo->plh_flags) ||\n\t    test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))\n\t\tgoto out_noroc;\n\n\t/* Don't return layout if we hold a delegation */\n\tif (nfs4_check_delegation(ino, FMODE_READ))\n\t\tgoto out_noroc;\n\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\t/* Don't return layout if there is open file state */\n\t\tif (state != NULL && state->state != 0)\n\t\t\tgoto out_noroc;\n\t}\n\n\tpnfs_clear_retry_layoutget(lo);\n\tlist_for_each_entry_safe(lseg, tmp, &lo->plh_segs, pls_list)\n\t\tif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\n\t\t\tmark_lseg_invalid(lseg, &tmp_list);\n\t\t\tfound = true;\n\t\t}\n\tif (!found)\n\t\tgoto out_noroc;\n\tlo->plh_block_lgets++;\n\tpnfs_get_layout_hdr(lo); /* matched in pnfs_roc_release */\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\treturn true;\n\nout_noroc:\n\tif (lo) {\n\t\tstateid = lo->plh_stateid;\n\t\tlayoutreturn =\n\t\t\ttest_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t   &lo->plh_flags);\n\t\tif (layoutreturn) {\n\t\t\tlo->plh_block_lgets++;\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t}\n\t}\n\tspin_unlock(&ino->i_lock);\n\tif (layoutreturn)\n\t\tpnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\n\treturn false;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_send_layoutreturn",
          "args": [
            "lo",
            "stateid",
            "IOMODE_ANY",
            "true"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_send_layoutreturn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "928-962",
          "snippet": "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_LAYOUT_RETURN_BEFORE_CLOSE",
            "&lo->plh_flags"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&tmp_list"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_lseg_invalid",
          "args": [
            "lseg",
            "&tmp_list"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lseg_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "528-544",
          "snippet": "static int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_ROC",
            "&lseg->pls_flags"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "tmp",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "lo"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ctx",
            "&nfsi->open_files",
            "list"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_check_delegation",
          "args": [
            "ino",
            "FMODE_READ"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "79-82",
          "snippet": "int nfs4_check_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn nfs4_do_check_delegation(inode, flags, false);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nint nfs4_check_delegation(struct inode *inode, fmode_t flags)\n{\n\treturn nfs4_do_check_delegation(inode, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nbool pnfs_roc(struct inode *ino)\n{\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\tnfs4_stateid stateid;\n\tLIST_HEAD(tmp_list);\n\tbool found = false, layoutreturn = false;\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo || !test_and_clear_bit(NFS_LAYOUT_ROC, &lo->plh_flags) ||\n\t    test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))\n\t\tgoto out_noroc;\n\n\t/* Don't return layout if we hold a delegation */\n\tif (nfs4_check_delegation(ino, FMODE_READ))\n\t\tgoto out_noroc;\n\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\t/* Don't return layout if there is open file state */\n\t\tif (state != NULL && state->state != 0)\n\t\t\tgoto out_noroc;\n\t}\n\n\tpnfs_clear_retry_layoutget(lo);\n\tlist_for_each_entry_safe(lseg, tmp, &lo->plh_segs, pls_list)\n\t\tif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\n\t\t\tmark_lseg_invalid(lseg, &tmp_list);\n\t\t\tfound = true;\n\t\t}\n\tif (!found)\n\t\tgoto out_noroc;\n\tlo->plh_block_lgets++;\n\tpnfs_get_layout_hdr(lo); /* matched in pnfs_roc_release */\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\treturn true;\n\nout_noroc:\n\tif (lo) {\n\t\tstateid = lo->plh_stateid;\n\t\tlayoutreturn =\n\t\t\ttest_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t   &lo->plh_flags);\n\t\tif (layoutreturn) {\n\t\t\tlo->plh_block_lgets++;\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t}\n\t}\n\tspin_unlock(&ino->i_lock);\n\tif (layoutreturn)\n\t\tpnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\n\treturn false;\n}"
  },
  {
    "function_name": "pnfs_commit_and_return_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "1026-1051",
    "snippet": "int\npnfs_commit_and_return_layout(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn 0;\n\t}\n\tpnfs_get_layout_hdr(lo);\n\t/* Block new layoutgets and read/write to ds */\n\tlo->plh_block_lgets++;\n\tspin_unlock(&inode->i_lock);\n\tfilemap_fdatawait(inode->i_mapping);\n\tret = pnfs_layoutcommit_inode(inode, true);\n\tif (ret == 0)\n\t\tret = _pnfs_return_layout(inode);\n\tspin_lock(&inode->i_lock);\n\tlo->plh_block_lgets--;\n\tspin_unlock(&inode->i_lock);\n\tpnfs_put_layout_hdr(lo);\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_pnfs_return_layout",
          "args": [
            "inode"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "_pnfs_return_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "972-1023",
          "snippet": "int\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "inode",
            "true"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2178-2258",
          "snippet": "int\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nint\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_commit_and_return_layout(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn 0;\n\t}\n\tpnfs_get_layout_hdr(lo);\n\t/* Block new layoutgets and read/write to ds */\n\tlo->plh_block_lgets++;\n\tspin_unlock(&inode->i_lock);\n\tfilemap_fdatawait(inode->i_mapping);\n\tret = pnfs_layoutcommit_inode(inode, true);\n\tif (ret == 0)\n\t\tret = _pnfs_return_layout(inode);\n\tspin_lock(&inode->i_lock);\n\tlo->plh_block_lgets--;\n\tspin_unlock(&inode->i_lock);\n\tpnfs_put_layout_hdr(lo);\n\treturn ret;\n}"
  },
  {
    "function_name": "_pnfs_return_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "972-1023",
    "snippet": "int\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s status: %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_send_layoutreturn",
          "args": [
            "lo",
            "stateid",
            "IOMODE_ANY",
            "true"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_send_layoutreturn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "928-962",
          "snippet": "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&tmp_list"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_INVALID_STID",
            "&lo->plh_flags"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s no layout segments to return\\n\"",
            "__func__"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo",
            "&range"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&tmp_list",
            "NULL"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_layoutcommit",
          "args": [
            "ino",
            "&tmp_list"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "906-919",
          "snippet": "static void pnfs_clear_layoutcommit(struct inode *inode,\n\t\tstruct list_head *head)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\treturn;\n\tlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\n\t\tif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tcontinue;\n\t\tpnfs_lseg_dec_and_remove_zero(lseg, head);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_layoutcommit(struct inode *inode,\n\t\tstruct list_head *head)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\treturn;\n\tlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\n\t\tif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tcontinue;\n\t\tpnfs_lseg_dec_and_remove_zero(lseg, head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s no layout to return\\n\"",
            "__func__"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s for inode %lu\\n\"",
            "__func__",
            "ino->i_ino"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\n_pnfs_return_layout(struct inode *ino)\n{\n\tstruct pnfs_layout_hdr *lo = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(ino);\n\tLIST_HEAD(tmp_list);\n\tnfs4_stateid stateid;\n\tint status = 0, empty;\n\n\tdprintk(\"NFS: %s for inode %lu\\n\", __func__, ino->i_ino);\n\n\tspin_lock(&ino->i_lock);\n\tlo = nfsi->layout;\n\tif (!lo) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"NFS: %s no layout to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\tstateid = nfsi->layout->plh_stateid;\n\t/* Reference matched in nfs4_layoutreturn_release */\n\tpnfs_get_layout_hdr(lo);\n\tempty = list_empty(&lo->plh_segs);\n\tpnfs_clear_layoutcommit(ino, &tmp_list);\n\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tstruct pnfs_layout_range range = {\n\t\t\t.iomode\t\t= IOMODE_ANY,\n\t\t\t.offset\t\t= 0,\n\t\t\t.length\t\t= NFS4_MAX_UINT64,\n\t\t};\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\n\t}\n\n\t/* Don't send a LAYOUTRETURN if list was initially empty */\n\tif (empty) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tdprintk(\"NFS: %s no layout segments to return\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\n\tlo->plh_block_lgets++;\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&tmp_list);\n\n\tstatus = pnfs_send_layoutreturn(lo, stateid, IOMODE_ANY, true);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
  },
  {
    "function_name": "pnfs_send_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "928-962",
    "snippet": "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s status: %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_layoutreturn",
          "args": [
            "lrp",
            "sync"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_layoutreturn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7902-7938",
          "snippet": "int nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t\t.rpc_cred = lrp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_SERVER(lrp->args.inode)->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!sync) {\n\t\tlrp->inode = nfs_igrab_and_active(lrp->args.inode);\n\t\tif (!lrp->inode) {\n\t\t\tnfs4_layoutreturn_release(lrp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags |= RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutreturn(lrp->args.inode, status);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t\t.rpc_cred = lrp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_SERVER(lrp->args.inode)->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!sync) {\n\t\tlrp->inode = nfs_igrab_and_active(lrp->args.inode);\n\t\tif (!lrp->inode) {\n\t\t\tnfs4_layoutreturn_release(lrp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags |= RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutreturn(lrp->args.inode, status);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&NFS_SERVER(ino)->roc_rpcwaitq"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_clear_layoutreturn_waitbit",
          "args": [
            "lo"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_layoutreturn_waitbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "921-926",
          "snippet": "void pnfs_clear_layoutreturn_waitbit(struct pnfs_layout_hdr *lo)\n{\n\tclear_bit_unlock(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_clear_layoutreturn_waitbit(struct pnfs_layout_hdr *lo)\n{\n\tclear_bit_unlock(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lrp == NULL"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*lrp)",
            "GFP_NOFS"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
  },
  {
    "function_name": "pnfs_clear_layoutreturn_waitbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "921-926",
    "snippet": "void pnfs_clear_layoutreturn_waitbit(struct pnfs_layout_hdr *lo)\n{\n\tclear_bit_unlock(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&lo->plh_flags",
            "NFS_LAYOUT_RETURN"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "NFS_LAYOUT_RETURN",
            "&lo->plh_flags"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_clear_layoutreturn_waitbit(struct pnfs_layout_hdr *lo)\n{\n\tclear_bit_unlock(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n}"
  },
  {
    "function_name": "pnfs_clear_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "906-919",
    "snippet": "static void pnfs_clear_layoutcommit(struct inode *inode,\n\t\tstruct list_head *head)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\treturn;\n\tlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\n\t\tif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tcontinue;\n\t\tpnfs_lseg_dec_and_remove_zero(lseg, head);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_lseg_dec_and_remove_zero",
          "args": [
            "lseg",
            "head"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_dec_and_remove_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "517-525",
          "snippet": "static bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_LSEG_LAYOUTCOMMIT",
            "&lseg->pls_flags"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "tmp",
            "&nfsi->layout->plh_segs",
            "pls_list"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_clear_layoutcommit(struct inode *inode,\n\t\tstruct list_head *head)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\treturn;\n\tlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\n\t\tif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\n\t\t\tcontinue;\n\t\tpnfs_lseg_dec_and_remove_zero(lseg, head);\n\t}\n}"
  },
  {
    "function_name": "send_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "857-904",
    "snippet": "static struct pnfs_layout_segment *\nsend_layoutget(struct pnfs_layout_hdr *lo,\n\t   struct nfs_open_context *ctx,\n\t   struct pnfs_layout_range *range,\n\t   gfp_t gfp_flags)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs4_layoutget *lgp;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp = kzalloc(sizeof(*lgp), gfp_flags);\n\tif (lgp == NULL)\n\t\treturn NULL;\n\n\tlgp->args.minlength = PAGE_CACHE_SIZE;\n\tif (lgp->args.minlength > range->length)\n\t\tlgp->args.minlength = range->length;\n\tlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\n\tlgp->args.range = *range;\n\tlgp->args.type = server->pnfs_curr_ld->id;\n\tlgp->args.inode = ino;\n\tlgp->args.ctx = get_nfs_open_context(ctx);\n\tlgp->gfp_flags = gfp_flags;\n\tlgp->cred = lo->plh_lc_cred;\n\n\t/* Synchronously retrieve layout information from server and\n\t * store in lseg.\n\t */\n\tlseg = nfs4_proc_layoutget(lgp, gfp_flags);\n\tif (IS_ERR(lseg)) {\n\t\tswitch (PTR_ERR(lseg)) {\n\t\tcase -ENOMEM:\n\t\tcase -ERESTARTSYS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* remember that LAYOUTGET failed and suspend trying */\n\t\t\tpnfs_layout_io_set_failed(lo, range->iomode);\n\t\t}\n\t\treturn NULL;\n\t} else\n\t\tpnfs_layout_clear_fail_bit(lo,\n\t\t\t\tpnfs_iomode_to_fail_bit(range->iomode));\n\n\treturn lseg;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_clear_fail_bit",
          "args": [
            "lo",
            "pnfs_iomode_to_fail_bit(range->iomode)"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_clear_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "269-274",
          "snippet": "static void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_iomode_to_fail_bit",
          "args": [
            "range->iomode"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_iomode_to_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "254-259",
          "snippet": "static int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_io_set_failed",
          "args": [
            "lo",
            "range->iomode"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_io_set_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "276-294",
          "snippet": "static void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lseg"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lseg"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_layoutget",
          "args": [
            "lgp",
            "gfp_flags"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7779-7837",
          "snippet": "struct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t\t.rpc_cred = lgp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* nfs4_layoutget_release calls pnfs_put_layout_hdr */\n\tpnfs_get_layout_hdr(NFS_I(inode)->layout);\n\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->args.timestamp = jiffies;\n\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs4_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutget(lgp->args.ctx,\n\t\t\t&lgp->args.range,\n\t\t\t&lgp->res.range,\n\t\t\tstatus);\n\t/* if layoutp->len is 0, nfs4_layoutget_prepare called rpc_exit */\n\tif (status == 0 && lgp->res.layoutp->len)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstruct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t\t.rpc_cred = lgp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* nfs4_layoutget_release calls pnfs_put_layout_hdr */\n\tpnfs_get_layout_hdr(NFS_I(inode)->layout);\n\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->args.timestamp = jiffies;\n\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs4_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutget(lgp->args.ctx,\n\t\t\t&lgp->args.range,\n\t\t\t&lgp->res.range,\n\t\t\tstatus);\n\t/* if layoutp->len is 0, nfs4_layoutget_prepare called rpc_exit */\n\tif (status == 0 && lgp->res.layoutp->len)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs_open_context",
          "args": [
            "ctx"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "803-808",
          "snippet": "struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*lgp)",
            "gfp_flags"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\nsend_layoutget(struct pnfs_layout_hdr *lo,\n\t   struct nfs_open_context *ctx,\n\t   struct pnfs_layout_range *range,\n\t   gfp_t gfp_flags)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs4_layoutget *lgp;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp = kzalloc(sizeof(*lgp), gfp_flags);\n\tif (lgp == NULL)\n\t\treturn NULL;\n\n\tlgp->args.minlength = PAGE_CACHE_SIZE;\n\tif (lgp->args.minlength > range->length)\n\t\tlgp->args.minlength = range->length;\n\tlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\n\tlgp->args.range = *range;\n\tlgp->args.type = server->pnfs_curr_ld->id;\n\tlgp->args.inode = ino;\n\tlgp->args.ctx = get_nfs_open_context(ctx);\n\tlgp->gfp_flags = gfp_flags;\n\tlgp->cred = lo->plh_lc_cred;\n\n\t/* Synchronously retrieve layout information from server and\n\t * store in lseg.\n\t */\n\tlseg = nfs4_proc_layoutget(lgp, gfp_flags);\n\tif (IS_ERR(lseg)) {\n\t\tswitch (PTR_ERR(lseg)) {\n\t\tcase -ENOMEM:\n\t\tcase -ERESTARTSYS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* remember that LAYOUTGET failed and suspend trying */\n\t\t\tpnfs_layout_io_set_failed(lo, range->iomode);\n\t\t}\n\t\treturn NULL;\n\t} else\n\t\tpnfs_layout_clear_fail_bit(lo,\n\t\t\t\tpnfs_iomode_to_fail_bit(range->iomode));\n\n\treturn lseg;\n}"
  },
  {
    "function_name": "pnfs_choose_layoutget_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "823-849",
    "snippet": "int\npnfs_choose_layoutget_stateid(nfs4_stateid *dst, struct pnfs_layout_hdr *lo,\n\t\t\t      struct pnfs_layout_range *range,\n\t\t\t      struct nfs4_state *open_state)\n{\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tspin_lock(&lo->plh_inode->i_lock);\n\tif (pnfs_layoutgets_blocked(lo, range, 1)) {\n\t\tstatus = -EAGAIN;\n\t} else if (!nfs4_valid_open_stateid(open_state)) {\n\t\tstatus = -EBADF;\n\t} else if (list_empty(&lo->plh_segs) ||\n\t\t   test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags)) {\n\t\tint seq;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&open_state->seqlock);\n\t\t\tnfs4_stateid_copy(dst, &open_state->stateid);\n\t\t} while (read_seqretry(&open_state->seqlock, seq));\n\t} else\n\t\tnfs4_stateid_copy(dst, &lo->plh_stateid);\n\tspin_unlock(&lo->plh_inode->i_lock);\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s\\n\"",
            "__func__"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lo->plh_inode->i_lock"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "dst",
            "&lo->plh_stateid"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&open_state->seqlock",
            "seq"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&open_state->seqlock"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_INVALID_STID",
            "&lo->plh_flags"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_valid_open_stateid",
          "args": [
            "open_state"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_valid_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "516-519",
          "snippet": "static inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layoutgets_blocked",
          "args": [
            "lo",
            "range",
            "1"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutgets_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "812-821",
          "snippet": "static bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lo->plh_inode->i_lock"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_choose_layoutget_stateid(nfs4_stateid *dst, struct pnfs_layout_hdr *lo,\n\t\t\t      struct pnfs_layout_range *range,\n\t\t\t      struct nfs4_state *open_state)\n{\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tspin_lock(&lo->plh_inode->i_lock);\n\tif (pnfs_layoutgets_blocked(lo, range, 1)) {\n\t\tstatus = -EAGAIN;\n\t} else if (!nfs4_valid_open_stateid(open_state)) {\n\t\tstatus = -EBADF;\n\t} else if (list_empty(&lo->plh_segs) ||\n\t\t   test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags)) {\n\t\tint seq;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&open_state->seqlock);\n\t\t\tnfs4_stateid_copy(dst, &open_state->stateid);\n\t\t} while (read_seqretry(&open_state->seqlock, seq));\n\t} else\n\t\tnfs4_stateid_copy(dst, &lo->plh_stateid);\n\tspin_unlock(&lo->plh_inode->i_lock);\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}"
  },
  {
    "function_name": "pnfs_layoutgets_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "812-821",
    "snippet": "static bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_returning",
          "args": [
            "lo",
            "range"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_returning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "802-809",
          "snippet": "static bool\npnfs_layout_returning(const struct pnfs_layout_hdr *lo,\n\t\t      struct pnfs_layout_range *range)\n{\n\treturn test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags) &&\n\t\t(lo->plh_return_iomode == IOMODE_ANY ||\n\t\t lo->plh_return_iomode == range->iomode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_returning(const struct pnfs_layout_hdr *lo,\n\t\t      struct pnfs_layout_range *range)\n{\n\treturn test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags) &&\n\t\t(lo->plh_return_iomode == IOMODE_ANY ||\n\t\t lo->plh_return_iomode == range->iomode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lo->plh_outstanding"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_BULK_RECALL",
            "&lo->plh_flags"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_range *range, int lget)\n{\n\treturn lo->plh_block_lgets ||\n\t\ttest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t\t(list_empty(&lo->plh_segs) &&\n\t\t (atomic_read(&lo->plh_outstanding) > lget)) ||\n\t\tpnfs_layout_returning(lo, range);\n}"
  },
  {
    "function_name": "pnfs_layout_returning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "802-809",
    "snippet": "static bool\npnfs_layout_returning(const struct pnfs_layout_hdr *lo,\n\t\t      struct pnfs_layout_range *range)\n{\n\treturn test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags) &&\n\t\t(lo->plh_return_iomode == IOMODE_ANY ||\n\t\t lo->plh_return_iomode == range->iomode);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_RETURN",
            "&lo->plh_flags"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_returning(const struct pnfs_layout_hdr *lo,\n\t\t      struct pnfs_layout_range *range)\n{\n\treturn test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags) &&\n\t\t(lo->plh_return_iomode == IOMODE_ANY ||\n\t\t lo->plh_return_iomode == range->iomode);\n}"
  },
  {
    "function_name": "pnfs_layout_stateid_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "793-800",
    "snippet": "static bool\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\n\t\tconst nfs4_stateid *stateid)\n{\n\tu32 seqid = be32_to_cpu(stateid->seqid);\n\n\treturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_seqid_is_newer",
          "args": [
            "seqid",
            "lo->plh_barrier"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_seqid_is_newer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "763-766",
          "snippet": "static bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "stateid->seqid"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\n\t\tconst nfs4_stateid *stateid)\n{\n\tu32 seqid = be32_to_cpu(stateid->seqid);\n\n\treturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\n}"
  },
  {
    "function_name": "pnfs_set_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "769-791",
    "snippet": "void\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_seqid_is_newer",
          "args": [
            "new_barrier",
            "lo->plh_barrier"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_seqid_is_newer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "763-766",
          "snippet": "static bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lo->plh_outstanding"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "new->seqid"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "&lo->plh_stateid",
            "new"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "new->seqid"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lo->plh_stateid.seqid"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}"
  },
  {
    "function_name": "pnfs_seqid_is_newer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "763-766",
    "snippet": "static bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "s1 - s2"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\n{\n\treturn (s32)(s1 - s2) > 0;\n}"
  },
  {
    "function_name": "pnfs_destroy_all_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "750-757",
    "snippet": "void\npnfs_destroy_all_layouts(struct nfs_client *clp)\n{\n\tnfs4_deviceid_mark_client_invalid(clp);\n\tnfs4_deviceid_purge_client(clp);\n\n\tpnfs_destroy_layouts_byclid(clp, false);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_destroy_layouts_byclid",
          "args": [
            "clp",
            "false"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_layouts_byclid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "722-744",
          "snippet": "int\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_deviceid_purge_client",
          "args": [
            "clp"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_deviceid_purge_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "333-342",
          "snippet": "void\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n\nvoid\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_deviceid_mark_client_invalid",
          "args": [
            "clp"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_deviceid_mark_client_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "347-360",
          "snippet": "void\nnfs4_deviceid_mark_client_invalid(struct nfs_client *clp)\n{\n\tstruct nfs4_deviceid_node *d;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < NFS4_DEVICE_ID_HASH_SIZE; i ++){\n\t\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[i], node)\n\t\t\tif (d->nfs_client == clp)\n\t\t\t\tset_bit(NFS_DEVICEID_INVALID, &d->flags);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\n\nvoid\nnfs4_deviceid_mark_client_invalid(struct nfs_client *clp)\n{\n\tstruct nfs4_deviceid_node *d;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < NFS4_DEVICE_ID_HASH_SIZE; i ++){\n\t\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[i], node)\n\t\t\tif (d->nfs_client == clp)\n\t\t\t\tset_bit(NFS_DEVICEID_INVALID, &d->flags);\n\t}\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_destroy_all_layouts(struct nfs_client *clp)\n{\n\tnfs4_deviceid_mark_client_invalid(clp);\n\tnfs4_deviceid_purge_client(clp);\n\n\tpnfs_destroy_layouts_byclid(clp, false);\n}"
  },
  {
    "function_name": "pnfs_destroy_layouts_byclid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "722-744",
    "snippet": "int\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_free_bulk_destroy_list",
          "args": [
            "&layout_list",
            "is_recall"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_free_bulk_destroy_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "657-693",
          "snippet": "static int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&layout_list"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layout_bulk_destroy_byserver_locked",
          "args": [
            "clp",
            "server",
            "&layout_list"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_bulk_destroy_byserver_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "632-655",
          "snippet": "static int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "layout_list"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}"
  },
  {
    "function_name": "pnfs_destroy_layouts_byfsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "695-720",
    "snippet": "int\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\n\t\tstruct nfs_fsid *fsid,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\n\t\t\tcontinue;\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\tserver,\n\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_free_bulk_destroy_list",
          "args": [
            "&layout_list",
            "is_recall"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_free_bulk_destroy_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "657-693",
          "snippet": "static int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&layout_list"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layout_bulk_destroy_byserver_locked",
          "args": [
            "clp",
            "server",
            "&layout_list"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_bulk_destroy_byserver_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "632-655",
          "snippet": "static int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&server->fsid",
            "fsid",
            "sizeof(*fsid)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "layout_list"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\n\t\tstruct nfs_fsid *fsid,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\n\t\t\tcontinue;\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\tserver,\n\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}"
  },
  {
    "function_name": "pnfs_layout_free_bulk_destroy_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "657-693",
    "snippet": "static int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&lseg_list"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&lseg_list",
            "&range"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_BULK_RECALL",
            "&lo->plh_flags"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lo->plh_bulk_destroy"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "inode",
            "false"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2178-2258",
          "snippet": "int\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nint\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\n\tstruct nfs4_layoutcommit_data *data;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos;\n\tint status;\n\n\tif (!pnfs_layoutcommit_outstanding(inode))\n\t\treturn 0;\n\n\tdprintk(\"--> %s inode %lu\\n\", __func__, inode->i_ino);\n\n\tstatus = -EAGAIN;\n\tif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\n\t\tif (!sync)\n\t\t\tgoto out;\n\t\tstatus = wait_on_bit_lock_action(&nfsi->flags,\n\t\t\t\tNFS_INO_LAYOUTCOMMITTING,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\t/* Note kzalloc ensures data->res.seq_res.sr_slot == NULL */\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\tgoto clear_layoutcommitting;\n\n\tstatus = 0;\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\n\t\tgoto out_unlock;\n\n\tINIT_LIST_HEAD(&data->lseg_list);\n\tpnfs_list_write_lseg(inode, &data->lseg_list);\n\n\tend_pos = nfsi->layout->plh_lwb;\n\tnfsi->layout->plh_lwb = 0;\n\n\tnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\n\tspin_unlock(&inode->i_lock);\n\n\tdata->args.inode = inode;\n\tdata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\n\tnfs_fattr_init(&data->fattr);\n\tdata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\tdata->res.fattr = &data->fattr;\n\tdata->args.lastbytewritten = end_pos - 1;\n\tdata->res.server = NFS_SERVER(inode);\n\n\tif (ld->prepare_layoutcommit) {\n\t\tstatus = ld->prepare_layoutcommit(&data->args);\n\t\tif (status) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (end_pos < nfsi->layout->plh_lwb)\n\t\t\t\tnfsi->layout->plh_lwb = end_pos;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tput_rpccred(data->cred);\n\t\t\tset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\n\t\t\tgoto clear_layoutcommitting;\n\t\t}\n\t}\n\n\n\tstatus = nfs4_proc_layoutcommit(data, sync);\nout:\n\tif (status)\n\t\tmark_inode_dirty_sync(inode);\n\tdprintk(\"<-- %s status %d\\n\", __func__, status);\n\treturn status;\nout_unlock:\n\tspin_unlock(&inode->i_lock);\n\tkfree(data);\nclear_layoutcommitting:\n\tpnfs_clear_layoutcommitting(inode);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s freeing layout for inode %lu\\n\"",
            "__func__",
            "lo->plh_inode->i_ino"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "layout_list->next",
            "structpnfs_layout_hdr",
            "plh_bulk_destroy"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "layout_list"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "lseg_list"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\n\t\tbool is_bulk_recall)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = IOMODE_ANY,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(lseg_list);\n\tint ret = 0;\n\n\twhile (!list_empty(layout_list)) {\n\t\tlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\n\t\t\t\tplh_bulk_destroy);\n\t\tdprintk(\"%s freeing layout for inode %lu\\n\", __func__,\n\t\t\tlo->plh_inode->i_ino);\n\t\tinode = lo->plh_inode;\n\n\t\tpnfs_layoutcommit_inode(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_init(&lo->plh_bulk_destroy);\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tif (is_bulk_recall)\n\t\t\tset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\t\tif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg_list(&lseg_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tiput(inode);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_layout_bulk_destroy_byserver_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "632-655",
    "snippet": "static int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layout_add_bulk_destroy_list",
          "args": [
            "inode",
            "layout_list"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_add_bulk_destroy_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "613-629",
          "snippet": "static bool\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tbool ret = false;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tlist_add(&lo->plh_bulk_destroy, layout_list);\n\t\tret = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tbool ret = false;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tlist_add(&lo->plh_bulk_destroy, layout_list);\n\t\tret = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lo->plh_layouts"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "lo->plh_inode"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_igrab_and_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "517-525",
          "snippet": "static inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lo",
            "next",
            "&server->layouts",
            "plh_layouts"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\n\t\tstruct nfs_server *server,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo, *next;\n\tstruct inode *inode;\n\n\tlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\n\t\tinode = igrab(lo->plh_inode);\n\t\tif (inode == NULL)\n\t\t\tcontinue;\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\tspin_unlock(&clp->cl_lock);\n\t\tiput(inode);\n\t\tspin_lock(&clp->cl_lock);\n\t\trcu_read_lock();\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pnfs_layout_add_bulk_destroy_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "613-629",
    "snippet": "static bool\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tbool ret = false;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tlist_add(&lo->plh_bulk_destroy, layout_list);\n\t\tret = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lo->plh_bulk_destroy",
            "layout_list"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_bulk_destroy"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\n\t\tstruct list_head *layout_list)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tbool ret = false;\n\n\tspin_lock(&inode->i_lock);\n\tlo = NFS_I(inode)->layout;\n\tif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tlist_add(&lo->plh_bulk_destroy, layout_list);\n\t\tret = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pnfs_destroy_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "590-610",
    "snippet": "void\npnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tLIST_HEAD(tmp_list);\n\n\tspin_lock(&nfsi->vfs_inode.i_lock);\n\tlo = nfsi->layout;\n\tif (lo) {\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RO_FAILED);\n\t\tpnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RW_FAILED);\n\t\tpnfs_clear_retry_layoutget(lo);\n\t\tspin_unlock(&nfsi->vfs_inode.i_lock);\n\t\tpnfs_free_lseg_list(&tmp_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t} else\n\t\tspin_unlock(&nfsi->vfs_inode.i_lock);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsi->vfs_inode.i_lock"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&tmp_list"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "lo"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_clear_fail_bit",
          "args": [
            "lo",
            "NFS_LAYOUT_RW_FAILED"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_clear_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "269-274",
          "snippet": "static void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&tmp_list",
            "NULL"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsi->vfs_inode.i_lock"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tLIST_HEAD(tmp_list);\n\n\tspin_lock(&nfsi->vfs_inode.i_lock);\n\tlo = nfsi->layout;\n\tif (lo) {\n\t\tlo->plh_block_lgets++; /* permanently block new LAYOUTGETs */\n\t\tpnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RO_FAILED);\n\t\tpnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RW_FAILED);\n\t\tpnfs_clear_retry_layoutget(lo);\n\t\tspin_unlock(&nfsi->vfs_inode.i_lock);\n\t\tpnfs_free_lseg_list(&tmp_list);\n\t\tpnfs_put_layout_hdr(lo);\n\t} else\n\t\tspin_unlock(&nfsi->vfs_inode.i_lock);\n}"
  },
  {
    "function_name": "pnfs_free_lseg_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "576-588",
    "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_free_lseg",
          "args": [
            "lseg"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lseg->pls_list"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "tmp",
            "free_me",
            "pls_list"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "free_me"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
  },
  {
    "function_name": "pnfs_mark_matching_lsegs_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "549-573",
    "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Return %i\\n\"",
            "__func__",
            "invalid - removed"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_lseg_invalid",
          "args": [
            "lseg",
            "tmp_list"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "mark_lseg_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "528-544",
          "snippet": "static int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\"",
            "__func__",
            "lseg",
            "lseg->pls_range.iomode",
            "lseg->pls_range.offset",
            "lseg->pls_range.length"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_free_lseg",
          "args": [
            "&lseg->pls_range",
            "recall_range"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "should_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "508-515",
          "snippet": "static bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lseg",
            "next",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s:Begin lo %p\\n\"",
            "__func__",
            "lo"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
  },
  {
    "function_name": "mark_lseg_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "528-544",
    "snippet": "static int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_lseg_dec_and_remove_zero",
          "args": [
            "lseg",
            "tmp_list"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_dec_and_remove_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "517-525",
          "snippet": "static bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lseg %p ref %d\\n\"",
            "__func__",
            "lseg",
            "atomic_read(&lseg->pls_refcount)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lseg->pls_refcount"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_LSEG_VALID",
            "&lseg->pls_flags"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\n\t\t\t     struct list_head *tmp_list)\n{\n\tint rv = 0;\n\n\tif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\n\t\t/* Remove the reference keeping the lseg in the\n\t\t * list.  It will now be removed when all\n\t\t * outstanding io is finished.\n\t\t */\n\t\tdprintk(\"%s: lseg %p ref %d\\n\", __func__, lseg,\n\t\t\tatomic_read(&lseg->pls_refcount));\n\t\tif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\n\t\t\trv = 1;\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "pnfs_lseg_dec_and_remove_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "517-525",
    "snippet": "static bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lseg->pls_list",
            "tmp_list"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_remove_lseg",
          "args": [
            "lseg->pls_layout",
            "lseg"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_remove_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "332-345",
          "snippet": "static void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&lseg->pls_refcount"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\n\t\tstruct list_head *tmp_list)\n{\n\tif (!atomic_dec_and_test(&lseg->pls_refcount))\n\t\treturn false;\n\tpnfs_layout_remove_lseg(lseg->pls_layout, lseg);\n\tlist_add(&lseg->pls_list, tmp_list);\n\treturn true;\n}"
  },
  {
    "function_name": "should_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "508-515",
    "snippet": "static bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_lseg_range_intersecting",
          "args": [
            "lseg_range",
            "recall_range"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_lseg_range_intersecting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "495-506",
          "snippet": "static bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\n\t\t const struct pnfs_layout_range *recall_range)\n{\n\treturn (recall_range->iomode == IOMODE_ANY ||\n\t\tlseg_range->iomode == recall_range->iomode) &&\n\t       pnfs_lseg_range_intersecting(lseg_range, recall_range);\n}"
  },
  {
    "function_name": "pnfs_lseg_range_intersecting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "495-506",
    "snippet": "static bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "start2",
            "l2->length"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "460-467",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\n\t\t    const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\n\t       (end2 == NFS4_MAX_UINT64 || end2 > start1);\n}"
  },
  {
    "function_name": "pnfs_lseg_range_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "476-486",
    "snippet": "static bool\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\n\t\t const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (start1 <= start2) && (end1 >= end2);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "start2",
            "l2->length"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "460-467",
          "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\n\t\t const struct pnfs_layout_range *l2)\n{\n\tu64 start1 = l1->offset;\n\tu64 end1 = end_offset(start1, l1->length);\n\tu64 start2 = l2->offset;\n\tu64 end2 = end_offset(start2, l2->length);\n\n\treturn (start1 <= start2) && (end1 >= end2);\n}"
  },
  {
    "function_name": "end_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "460-467",
    "snippet": "static u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "pnfs_put_lseg_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "440-457",
    "snippet": "void\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_free_lseg_async",
          "args": [
            "lseg"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "434-438",
          "snippet": "static void pnfs_free_lseg_async(struct pnfs_layout_segment *lseg)\n{\n\tINIT_WORK(&lseg->pls_work, pnfs_free_lseg_async_work);\n\tschedule_work(&lseg->pls_work);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_free_lseg_async(struct pnfs_layout_segment *lseg)\n{\n\tINIT_WORK(&lseg->pls_work, pnfs_free_lseg_async_work);\n\tschedule_work(&lseg->pls_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_remove_lseg",
          "args": [
            "lo",
            "lseg"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_remove_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "332-345",
          "snippet": "static void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&lseg->pls_refcount"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lseg %p ref %d valid %d\\n\"",
            "__func__",
            "lseg",
            "atomic_read(&lseg->pls_refcount)",
            "test_bit(NFS_LSEG_VALID, &lseg->pls_flags)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_VALID",
            "&lseg->pls_flags"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lseg->pls_refcount"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lseg->pls_layout->plh_inode->i_lock"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\n{\n\tif (!lseg)\n\t\treturn;\n\n\tassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tif (atomic_dec_and_test(&lseg->pls_refcount)) {\n\t\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tpnfs_free_lseg_async(lseg);\n\t}\n}"
  },
  {
    "function_name": "pnfs_free_lseg_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "434-438",
    "snippet": "static void pnfs_free_lseg_async(struct pnfs_layout_segment *lseg)\n{\n\tINIT_WORK(&lseg->pls_work, pnfs_free_lseg_async_work);\n\tschedule_work(&lseg->pls_work);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&lseg->pls_work"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&lseg->pls_work",
            "pnfs_free_lseg_async_work"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_free_lseg_async(struct pnfs_layout_segment *lseg)\n{\n\tINIT_WORK(&lseg->pls_work, pnfs_free_lseg_async_work);\n\tschedule_work(&lseg->pls_work);\n}"
  },
  {
    "function_name": "pnfs_free_lseg_async_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "422-432",
    "snippet": "static void pnfs_free_lseg_async_work(struct work_struct *work)\n{\n\tstruct pnfs_layout_segment *lseg;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlseg = container_of(work, struct pnfs_layout_segment, pls_work);\n\tlo = lseg->pls_layout;\n\n\tpnfs_free_lseg(lseg);\n\tpnfs_put_layout_hdr(lo);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg",
          "args": [
            "lseg"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpnfs_layout_segment",
            "pls_work"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_free_lseg_async_work(struct work_struct *work)\n{\n\tstruct pnfs_layout_segment *lseg;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlseg = container_of(work, struct pnfs_layout_segment, pls_work);\n\tlo = lseg->pls_layout;\n\n\tpnfs_free_lseg(lseg);\n\tpnfs_put_layout_hdr(lo);\n}"
  },
  {
    "function_name": "pnfs_put_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "389-419",
    "snippet": "void\npnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\n\tif (!lseg)\n\t\treturn;\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\n\t/* Handle the case where refcount != 1 */\n\tif (atomic_add_unless(&lseg->pls_refcount, -1, 1))\n\t\treturn;\n\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\t/* Do we need a layoutreturn? */\n\tif (test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\tpnfs_layoutreturn_before_put_lseg(lseg, lo, inode);\n\n\tif (atomic_dec_and_lock(&lseg->pls_refcount, &inode->i_lock)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg(lseg);\n\t\tpnfs_put_layout_hdr(lo);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg",
          "args": [
            "lseg"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_remove_lseg",
          "args": [
            "lo",
            "lseg"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_remove_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "332-345",
          "snippet": "static void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&lseg->pls_refcount",
            "&inode->i_lock"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutreturn_before_put_lseg",
          "args": [
            "lseg",
            "lo",
            "inode"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutreturn_before_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "364-387",
          "snippet": "static void pnfs_layoutreturn_before_put_lseg(struct pnfs_layout_segment *lseg,\n\t\tstruct pnfs_layout_hdr *lo, struct inode *inode)\n{\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (pnfs_layout_need_return(lo, lseg)) {\n\t\tnfs4_stateid stateid;\n\t\tenum pnfs_iomode iomode;\n\n\t\tstateid = lo->plh_stateid;\n\t\tiomode = lo->plh_return_iomode;\n\t\t/* decreased in pnfs_send_layoutreturn() */\n\t\tlo->plh_block_lgets++;\n\t\tlo->plh_return_iomode = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_get_layout_hdr(lo);\n\n\t\t/* Send an async layoutreturn so we dont deadlock */\n\t\tpnfs_send_layoutreturn(lo, stateid, iomode, false);\n\t} else\n\t\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_layoutreturn_before_put_lseg(struct pnfs_layout_segment *lseg,\n\t\tstruct pnfs_layout_hdr *lo, struct inode *inode)\n{\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (pnfs_layout_need_return(lo, lseg)) {\n\t\tnfs4_stateid stateid;\n\t\tenum pnfs_iomode iomode;\n\n\t\tstateid = lo->plh_stateid;\n\t\tiomode = lo->plh_return_iomode;\n\t\t/* decreased in pnfs_send_layoutreturn() */\n\t\tlo->plh_block_lgets++;\n\t\tlo->plh_return_iomode = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_get_layout_hdr(lo);\n\n\t\t/* Send an async layoutreturn so we dont deadlock */\n\t\tpnfs_send_layoutreturn(lo, stateid, iomode, false);\n\t} else\n\t\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_LAYOUTRETURN",
            "&lseg->pls_flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&lseg->pls_refcount",
            "-1",
            "1"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lseg %p ref %d valid %d\\n\"",
            "__func__",
            "lseg",
            "atomic_read(&lseg->pls_refcount)",
            "test_bit(NFS_LSEG_VALID, &lseg->pls_flags)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lseg->pls_refcount"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo;\n\tstruct inode *inode;\n\n\tif (!lseg)\n\t\treturn;\n\n\tdprintk(\"%s: lseg %p ref %d valid %d\\n\", __func__, lseg,\n\t\tatomic_read(&lseg->pls_refcount),\n\t\ttest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\n\t/* Handle the case where refcount != 1 */\n\tif (atomic_add_unless(&lseg->pls_refcount, -1, 1))\n\t\treturn;\n\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\t/* Do we need a layoutreturn? */\n\tif (test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\tpnfs_layoutreturn_before_put_lseg(lseg, lo, inode);\n\n\tif (atomic_dec_and_lock(&lseg->pls_refcount, &inode->i_lock)) {\n\t\tpnfs_get_layout_hdr(lo);\n\t\tpnfs_layout_remove_lseg(lo, lseg);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_lseg(lseg);\n\t\tpnfs_put_layout_hdr(lo);\n\t}\n}"
  },
  {
    "function_name": "pnfs_layoutreturn_before_put_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "364-387",
    "snippet": "static void pnfs_layoutreturn_before_put_lseg(struct pnfs_layout_segment *lseg,\n\t\tstruct pnfs_layout_hdr *lo, struct inode *inode)\n{\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (pnfs_layout_need_return(lo, lseg)) {\n\t\tnfs4_stateid stateid;\n\t\tenum pnfs_iomode iomode;\n\n\t\tstateid = lo->plh_stateid;\n\t\tiomode = lo->plh_return_iomode;\n\t\t/* decreased in pnfs_send_layoutreturn() */\n\t\tlo->plh_block_lgets++;\n\t\tlo->plh_return_iomode = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_get_layout_hdr(lo);\n\n\t\t/* Send an async layoutreturn so we dont deadlock */\n\t\tpnfs_send_layoutreturn(lo, stateid, iomode, false);\n\t} else\n\t\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_send_layoutreturn",
          "args": [
            "lo",
            "stateid",
            "iomode",
            "false"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_send_layoutreturn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "928-962",
          "snippet": "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync);\n\nstatic int\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, nfs4_stateid stateid,\n\t\t       enum pnfs_iomode iomode, bool sync)\n{\n\tstruct inode *ino = lo->plh_inode;\n\tstruct nfs4_layoutreturn *lrp;\n\tint status = 0;\n\n\tlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\n\tif (unlikely(lrp == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tspin_lock(&ino->i_lock);\n\t\tlo->plh_block_lgets--;\n\t\tpnfs_clear_layoutreturn_waitbit(lo);\n\t\trpc_wake_up(&NFS_SERVER(ino)->roc_rpcwaitq);\n\t\tspin_unlock(&ino->i_lock);\n\t\tpnfs_put_layout_hdr(lo);\n\t\tgoto out;\n\t}\n\n\tlrp->args.stateid = stateid;\n\tlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\n\tlrp->args.inode = ino;\n\tlrp->args.range.iomode = iomode;\n\tlrp->args.range.offset = 0;\n\tlrp->args.range.length = NFS4_MAX_UINT64;\n\tlrp->args.layout = lo;\n\tlrp->clp = NFS_SERVER(ino)->nfs_client;\n\tlrp->cred = lo->plh_lc_cred;\n\n\tstatus = nfs4_proc_layoutreturn(lrp, sync);\nout:\n\tdprintk(\"<-- %s status: %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_need_return",
          "args": [
            "lo",
            "lseg"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_need_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "348-362",
          "snippet": "static bool\npnfs_layout_need_return(struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *s;\n\n\tif (!test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\treturn false;\n\n\tlist_for_each_entry(s, &lo->plh_segs, pls_list)\n\t\tif (s != lseg && test_bit(NFS_LSEG_LAYOUTRETURN, &s->pls_flags))\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_need_return(struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *s;\n\n\tif (!test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\treturn false;\n\n\tlist_for_each_entry(s, &lo->plh_segs, pls_list)\n\t\tif (s != lseg && test_bit(NFS_LSEG_LAYOUTRETURN, &s->pls_flags))\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_layoutreturn_before_put_lseg(struct pnfs_layout_segment *lseg,\n\t\tstruct pnfs_layout_hdr *lo, struct inode *inode)\n{\n\tlo = lseg->pls_layout;\n\tinode = lo->plh_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (pnfs_layout_need_return(lo, lseg)) {\n\t\tnfs4_stateid stateid;\n\t\tenum pnfs_iomode iomode;\n\n\t\tstateid = lo->plh_stateid;\n\t\tiomode = lo->plh_return_iomode;\n\t\t/* decreased in pnfs_send_layoutreturn() */\n\t\tlo->plh_block_lgets++;\n\t\tlo->plh_return_iomode = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_get_layout_hdr(lo);\n\n\t\t/* Send an async layoutreturn so we dont deadlock */\n\t\tpnfs_send_layoutreturn(lo, stateid, iomode, false);\n\t} else\n\t\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "pnfs_layout_need_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "348-362",
    "snippet": "static bool\npnfs_layout_need_return(struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *s;\n\n\tif (!test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\treturn false;\n\n\tlist_for_each_entry(s, &lo->plh_segs, pls_list)\n\t\tif (s != lseg && test_bit(NFS_LSEG_LAYOUTRETURN, &s->pls_flags))\n\t\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_LAYOUTRETURN",
            "&s->pls_flags"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&lo->plh_segs",
            "pls_list"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\npnfs_layout_need_return(struct pnfs_layout_hdr *lo,\n\t\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_segment *s;\n\n\tif (!test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\n\t\treturn false;\n\n\tlist_for_each_entry(s, &lo->plh_segs, pls_list)\n\t\tif (s != lseg && test_bit(NFS_LSEG_LAYOUTRETURN, &s->pls_flags))\n\t\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "pnfs_layout_remove_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "332-345",
    "snippet": "static void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&NFS_SERVER(inode)->roc_rpcwaitq"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_LAYOUT_BULK_RECALL",
            "&lo->plh_flags"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&lo->plh_refcount"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lseg->pls_list"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(NFS_LSEG_VALID, &lseg->pls_flags)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LSEG_VALID",
            "&lseg->pls_flags"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_segment *lseg)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\n\tlist_del_init(&lseg->pls_list);\n\t/* Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */\n\tatomic_dec(&lo->plh_refcount);\n\tif (list_empty(&lo->plh_segs))\n\t\tclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\n\trpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\n}"
  },
  {
    "function_name": "pnfs_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "325-330",
    "snippet": "static void pnfs_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\n\tNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lseg"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void pnfs_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\n\tNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\n}"
  },
  {
    "function_name": "init_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "314-323",
    "snippet": "static void\ninit_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg)\n{\n\tINIT_LIST_HEAD(&lseg->pls_list);\n\tINIT_LIST_HEAD(&lseg->pls_lc_list);\n\tatomic_set(&lseg->pls_refcount, 1);\n\tsmp_mb();\n\tset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\n\tlseg->pls_layout = lo;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LSEG_VALID",
            "&lseg->pls_flags"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&lseg->pls_refcount",
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lseg->pls_lc_list"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lseg->pls_list"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\ninit_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg)\n{\n\tINIT_LIST_HEAD(&lseg->pls_list);\n\tINIT_LIST_HEAD(&lseg->pls_lc_list);\n\tatomic_set(&lseg->pls_refcount, 1);\n\tsmp_mb();\n\tset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\n\tlseg->pls_layout = lo;\n}"
  },
  {
    "function_name": "pnfs_layout_io_test_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "296-312",
    "snippet": "static bool\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tunsigned long start, end;\n\tint fail_bit = pnfs_iomode_to_fail_bit(iomode);\n\n\tif (test_bit(fail_bit, &lo->plh_flags) == 0)\n\t\treturn false;\n\tend = jiffies;\n\tstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\n\tif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\n\t\t/* It is time to retry the failed layoutgets */\n\t\tpnfs_layout_clear_fail_bit(lo, fail_bit);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [
      "#define PNFS_LAYOUTGET_RETRY_TIMEOUT (120*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_layout_clear_fail_bit",
          "args": [
            "lo",
            "fail_bit"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_clear_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "269-274",
          "snippet": "static void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "lo->plh_retry_timestamp",
            "start",
            "end"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "fail_bit",
            "&lo->plh_flags"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_iomode_to_fail_bit",
          "args": [
            "iomode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_iomode_to_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "254-259",
          "snippet": "static int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define PNFS_LAYOUTGET_RETRY_TIMEOUT (120*HZ)\n\nstatic bool\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tunsigned long start, end;\n\tint fail_bit = pnfs_iomode_to_fail_bit(iomode);\n\n\tif (test_bit(fail_bit, &lo->plh_flags) == 0)\n\t\treturn false;\n\tend = jiffies;\n\tstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\n\tif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\n\t\t/* It is time to retry the failed layoutgets */\n\t\tpnfs_layout_clear_fail_bit(lo, fail_bit);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "pnfs_layout_io_set_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "276-294",
    "snippet": "static void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Setting layout IOMODE_%s fail bit\\n\"",
            "__func__",
            "iomode == IOMODE_RW ?  \"RW\" : \"READ\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&head"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&head",
            "&range"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layout_set_fail_bit",
          "args": [
            "lo",
            "pnfs_iomode_to_fail_bit(iomode)"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layout_set_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "261-267",
          "snippet": "static void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_iomode_to_fail_bit",
          "args": [
            "iomode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_iomode_to_fail_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "254-259",
          "snippet": "static int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\n{\n\tstruct inode *inode = lo->plh_inode;\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(head);\n\n\tspin_lock(&inode->i_lock);\n\tpnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\n\tpnfs_mark_matching_lsegs_invalid(lo, &head, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&head);\n\tdprintk(\"%s Setting layout IOMODE_%s fail bit\\n\", __func__,\n\t\t\tiomode == IOMODE_RW ?  \"RW\" : \"READ\");\n}"
  },
  {
    "function_name": "pnfs_layout_clear_fail_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "269-274",
    "snippet": "static void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&lo->plh_refcount"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "fail_bit",
            "&lo->plh_flags"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tif (test_and_clear_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_dec(&lo->plh_refcount);\n}"
  },
  {
    "function_name": "pnfs_layout_set_fail_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "261-267",
    "snippet": "static void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lo->plh_refcount"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "fail_bit",
            "&lo->plh_flags"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\n{\n\tlo->plh_retry_timestamp = jiffies;\n\tif (!test_and_set_bit(fail_bit, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
  },
  {
    "function_name": "pnfs_iomode_to_fail_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "254-259",
    "snippet": "static int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\npnfs_iomode_to_fail_bit(u32 iomode)\n{\n\treturn iomode == IOMODE_RW ?\n\t\tNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\n}"
  },
  {
    "function_name": "pnfs_put_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "240-252",
    "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_free_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "212-227",
          "snippet": "static void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_detach_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_detach_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "229-238",
          "snippet": "static void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"NFS: BUG unfreed layout segments.\\n\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_segs"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&lo->plh_refcount",
            "&inode->i_lock"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
  },
  {
    "function_name": "pnfs_detach_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "229-238",
    "snippet": "static void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: freeing layout cache %p\\n\"",
            "__func__",
            "lo"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "lo->plh_inode"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\n\tdprintk(\"%s: freeing layout cache %p\\n\", __func__, lo);\n\tnfsi->layout = NULL;\n\t/* Reset MDS Threshold I/O counters */\n\tnfsi->write_io = 0;\n\tnfsi->read_io = 0;\n}"
  },
  {
    "function_name": "pnfs_free_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "212-227",
    "snippet": "static void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ld->free_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "lo->plh_lc_cred"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lo->plh_layouts"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->plh_layouts"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo->plh_inode"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\n\tstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\n\n\tif (!list_empty(&lo->plh_layouts)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del_init(&lo->plh_layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tput_rpccred(lo->plh_lc_cred);\n\treturn ld->free_layout_hdr(lo);\n}"
  },
  {
    "function_name": "pnfs_alloc_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "205-210",
    "snippet": "static struct pnfs_layout_hdr *\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\n\treturn ld->alloc_layout_hdr(ino, gfp_flags);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ld->alloc_layout_hdr",
          "args": [
            "ino",
            "gfp_flags"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\n{\n\tstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\n\treturn ld->alloc_layout_hdr(ino, gfp_flags);\n}"
  },
  {
    "function_name": "pnfs_get_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "199-203",
    "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lo->plh_refcount"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
  },
  {
    "function_name": "pnfs_unregister_layoutdriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "184-191",
    "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(pnfs_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ld_type->pnfs_tblid"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Deregistering id:%u\\n\"",
            "__func__",
            "ld_type->id"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
  },
  {
    "function_name": "pnfs_register_layoutdriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "151-181",
    "snippet": "int\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(pnfs_spinlock);",
      "static LIST_HEAD(pnfs_modules_tbl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\"",
            "__func__",
            "ld_type->id"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Registering id:%u name:%s\\n\"",
            "__func__",
            "ld_type->id",
            "ld_type->name"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ld_type->pnfs_tblid",
            "&pnfs_modules_tbl"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_pnfs_driver_locked",
          "args": [
            "ld_type->id"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "find_pnfs_driver_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "59-71",
          "snippet": "static struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nstatic struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nint\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}"
  },
  {
    "function_name": "set_pnfs_layoutdriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "108-149",
    "snippet": "void\nset_pnfs_layoutdriver(struct nfs_server *server, const struct nfs_fh *mntfh,\n\t\t      u32 id)\n{\n\tstruct pnfs_layoutdriver_type *ld_type = NULL;\n\n\tif (id == 0)\n\t\tgoto out_no_driver;\n\tif (!(server->nfs_client->cl_exchange_flags &\n\t\t (EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS))) {\n\t\tprintk(KERN_ERR \"NFS: %s: id %u cl_exchange_flags 0x%x\\n\",\n\t\t\t__func__, id, server->nfs_client->cl_exchange_flags);\n\t\tgoto out_no_driver;\n\t}\n\tld_type = find_pnfs_driver(id);\n\tif (!ld_type) {\n\t\trequest_module(\"%s-%u\", LAYOUT_NFSV4_1_MODULE_PREFIX, id);\n\t\tld_type = find_pnfs_driver(id);\n\t\tif (!ld_type) {\n\t\t\tdprintk(\"%s: No pNFS module found for %u.\\n\",\n\t\t\t\t__func__, id);\n\t\t\tgoto out_no_driver;\n\t\t}\n\t}\n\tserver->pnfs_curr_ld = ld_type;\n\tif (ld_type->set_layoutdriver\n\t    && ld_type->set_layoutdriver(server, mntfh)) {\n\t\tprintk(KERN_ERR \"NFS: %s: Error initializing pNFS layout \"\n\t\t\t\"driver %u.\\n\", __func__, id);\n\t\tmodule_put(ld_type->owner);\n\t\tgoto out_no_driver;\n\t}\n\t/* Bump the MDS count */\n\tatomic_inc(&server->nfs_client->cl_mds_count);\n\n\tdprintk(\"%s: pNFS module for %u set\\n\", __func__, id);\n\treturn;\n\nout_no_driver:\n\tdprintk(\"%s: Using NFSv4 I/O\\n\", __func__);\n\tserver->pnfs_curr_ld = NULL;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Using NFSv4 I/O\\n\"",
            "__func__"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: pNFS module for %u set\\n\"",
            "__func__",
            "id"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&server->nfs_client->cl_mds_count"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "ld_type->owner"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: Error initializing pNFS layout \"\n\t\t\t\"driver %u.\\n\"",
            "__func__",
            "id"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ld_type->set_layoutdriver",
          "args": [
            "server",
            "mntfh"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: No pNFS module found for %u.\\n\"",
            "__func__",
            "id"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_pnfs_driver",
          "args": [
            "id"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "find_pnfs_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "73-86",
          "snippet": "static struct pnfs_layoutdriver_type *\nfind_pnfs_driver(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tspin_lock(&pnfs_spinlock);\n\tlocal = find_pnfs_driver_locked(id);\n\tif (local != NULL && !try_module_get(local->owner)) {\n\t\tdprintk(\"%s: Could not grab reference on module\\n\", __func__);\n\t\tlocal = NULL;\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\treturn local;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nstatic struct pnfs_layoutdriver_type *\nfind_pnfs_driver(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tspin_lock(&pnfs_spinlock);\n\tlocal = find_pnfs_driver_locked(id);\n\tif (local != NULL && !try_module_get(local->owner)) {\n\t\tdprintk(\"%s: Could not grab reference on module\\n\", __func__);\n\t\tlocal = NULL;\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_module",
          "args": [
            "\"%s-%u\"",
            "LAYOUT_NFSV4_1_MODULE_PREFIX",
            "id"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\nset_pnfs_layoutdriver(struct nfs_server *server, const struct nfs_fh *mntfh,\n\t\t      u32 id)\n{\n\tstruct pnfs_layoutdriver_type *ld_type = NULL;\n\n\tif (id == 0)\n\t\tgoto out_no_driver;\n\tif (!(server->nfs_client->cl_exchange_flags &\n\t\t (EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS))) {\n\t\tprintk(KERN_ERR \"NFS: %s: id %u cl_exchange_flags 0x%x\\n\",\n\t\t\t__func__, id, server->nfs_client->cl_exchange_flags);\n\t\tgoto out_no_driver;\n\t}\n\tld_type = find_pnfs_driver(id);\n\tif (!ld_type) {\n\t\trequest_module(\"%s-%u\", LAYOUT_NFSV4_1_MODULE_PREFIX, id);\n\t\tld_type = find_pnfs_driver(id);\n\t\tif (!ld_type) {\n\t\t\tdprintk(\"%s: No pNFS module found for %u.\\n\",\n\t\t\t\t__func__, id);\n\t\t\tgoto out_no_driver;\n\t\t}\n\t}\n\tserver->pnfs_curr_ld = ld_type;\n\tif (ld_type->set_layoutdriver\n\t    && ld_type->set_layoutdriver(server, mntfh)) {\n\t\tprintk(KERN_ERR \"NFS: %s: Error initializing pNFS layout \"\n\t\t\t\"driver %u.\\n\", __func__, id);\n\t\tmodule_put(ld_type->owner);\n\t\tgoto out_no_driver;\n\t}\n\t/* Bump the MDS count */\n\tatomic_inc(&server->nfs_client->cl_mds_count);\n\n\tdprintk(\"%s: pNFS module for %u set\\n\", __func__, id);\n\treturn;\n\nout_no_driver:\n\tdprintk(\"%s: Using NFSv4 I/O\\n\", __func__);\n\tserver->pnfs_curr_ld = NULL;\n}"
  },
  {
    "function_name": "unset_pnfs_layoutdriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "88-100",
    "snippet": "void\nunset_pnfs_layoutdriver(struct nfs_server *nfss)\n{\n\tif (nfss->pnfs_curr_ld) {\n\t\tif (nfss->pnfs_curr_ld->clear_layoutdriver)\n\t\t\tnfss->pnfs_curr_ld->clear_layoutdriver(nfss);\n\t\t/* Decrement the MDS count. Purge the deviceid cache if zero */\n\t\tif (atomic_dec_and_test(&nfss->nfs_client->cl_mds_count))\n\t\t\tnfs4_deviceid_purge_client(nfss->nfs_client);\n\t\tmodule_put(nfss->pnfs_curr_ld->owner);\n\t}\n\tnfss->pnfs_curr_ld = NULL;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "nfss->pnfs_curr_ld->owner"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_deviceid_purge_client",
          "args": [
            "nfss->nfs_client"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_deviceid_purge_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "333-342",
          "snippet": "void\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n\nvoid\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&nfss->nfs_client->cl_mds_count"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfss->pnfs_curr_ld->clear_layoutdriver",
          "args": [
            "nfss"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\nunset_pnfs_layoutdriver(struct nfs_server *nfss)\n{\n\tif (nfss->pnfs_curr_ld) {\n\t\tif (nfss->pnfs_curr_ld->clear_layoutdriver)\n\t\t\tnfss->pnfs_curr_ld->clear_layoutdriver(nfss);\n\t\t/* Decrement the MDS count. Purge the deviceid cache if zero */\n\t\tif (atomic_dec_and_test(&nfss->nfs_client->cl_mds_count))\n\t\t\tnfs4_deviceid_purge_client(nfss->nfs_client);\n\t\tmodule_put(nfss->pnfs_curr_ld->owner);\n\t}\n\tnfss->pnfs_curr_ld = NULL;\n}"
  },
  {
    "function_name": "find_pnfs_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "73-86",
    "snippet": "static struct pnfs_layoutdriver_type *\nfind_pnfs_driver(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tspin_lock(&pnfs_spinlock);\n\tlocal = find_pnfs_driver_locked(id);\n\tif (local != NULL && !try_module_get(local->owner)) {\n\t\tdprintk(\"%s: Could not grab reference on module\\n\", __func__);\n\t\tlocal = NULL;\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\treturn local;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(pnfs_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Could not grab reference on module\\n\"",
            "__func__"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "local->owner"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_pnfs_driver_locked",
          "args": [
            "id"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "find_pnfs_driver_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "59-71",
          "snippet": "static struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nstatic struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pnfs_spinlock"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nstatic struct pnfs_layoutdriver_type *\nfind_pnfs_driver(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tspin_lock(&pnfs_spinlock);\n\tlocal = find_pnfs_driver_locked(id);\n\tif (local != NULL && !try_module_get(local->owner)) {\n\t\tdprintk(\"%s: Could not grab reference on module\\n\", __func__);\n\t\tlocal = NULL;\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\treturn local;\n}"
  },
  {
    "function_name": "find_pnfs_driver_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
    "lines": "59-71",
    "snippet": "static struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}",
    "includes": [
      "#include \"delegation.h\"",
      "#include \"nfs4trace.h\"",
      "#include \"iostat.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(pnfs_modules_tbl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Searching for id %u, found %p\\n\"",
            "__func__",
            "id",
            "local"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "local",
            "&pnfs_modules_tbl",
            "pnfs_tblid"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nstatic struct pnfs_layoutdriver_type *\nfind_pnfs_driver_locked(u32 id)\n{\n\tstruct pnfs_layoutdriver_type *local;\n\n\tlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\n\t\tif (local->id == id)\n\t\t\tgoto out;\n\tlocal = NULL;\nout:\n\tdprintk(\"%s: Searching for id %u, found %p\\n\", __func__, id, local);\n\treturn local;\n}"
  }
]