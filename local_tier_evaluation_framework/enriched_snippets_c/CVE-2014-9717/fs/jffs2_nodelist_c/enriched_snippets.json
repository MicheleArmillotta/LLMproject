[
  {
    "function_name": "_jffs2_ref_totlen(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "718-755",
    "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARN_ON(",
          "args": [
            ")"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_jffs2_dbg_dump_node_refs_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",",
            "eb->wasted_size,",
            "eb->dirty_size,",
            "eb->used_size,",
            "eb->free_size)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "No next ref. jeb->last_node is %p\\n\",",
            "eb->last_node)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "next %p (0x%08x-0x%08x)\\n\",",
            "ef_next(ref),",
            "ef_offset(ref_next(ref)),",
            "ef_offset(ref_next(ref)) + ref->__totlen)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef_next(ref))"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_next(",
          "args": [
            "ef)"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ef_next(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "101-117",
          "snippet": "tatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef_next(ref))"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",",
            "ef,",
            "ef_offset(ref),",
            "ef_offset(ref) + ref->__totlen,",
            "et,",
            "ef->__totlen)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "et != ref->__totlen)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ref_totlen(",
          "args": [
            ",",
            "eb,",
            "ef)"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
  },
  {
    "function_name": "_ref_totlen(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "692-716",
    "snippet": "tatic inline uint32_t __ref_totlen(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_eraseblock *jeb,\n\t\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ref_end;\n\tstruct jffs2_raw_node_ref *next_ref = ref_next(ref);\n\n\tif (next_ref)\n\t\tref_end = ref_offset(next_ref);\n\telse {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\t/* Last node in block. Use free_space */\n\t\tif (unlikely(ref != jeb->last_node)) {\n\t\t\tpr_crit(\"ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\\n\",\n\t\t\t\tref, ref_offset(ref), jeb->last_node,\n\t\t\t\tjeb->last_node ?\n\t\t\t\tref_offset(jeb->last_node) : 0);\n\t\t\tBUG();\n\t\t}\n\t\tref_end = jeb->offset + c->sector_size - jeb->free_size;\n\t}\n\treturn ref_end - ref_offset(ref);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\\n\",",
            "ef,",
            "ef_offset(ref),",
            "eb->last_node,",
            "eb->last_node ?\n\t\t\t\tref_offset(jeb->last_node) : 0)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "eb->last_node)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "ef != jeb->last_node)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ext_ref)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_next(",
          "args": [
            "ef)"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ef_next(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "101-117",
          "snippet": "tatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t __ref_totlen(struct jffs2_sb_info *c,\n\t\t\t\t    struct jffs2_eraseblock *jeb,\n\t\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ref_end;\n\tstruct jffs2_raw_node_ref *next_ref = ref_next(ref);\n\n\tif (next_ref)\n\t\tref_end = ref_offset(next_ref);\n\telse {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\t/* Last node in block. Use free_space */\n\t\tif (unlikely(ref != jeb->last_node)) {\n\t\t\tpr_crit(\"ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\\n\",\n\t\t\t\tref, ref_offset(ref), jeb->last_node,\n\t\t\t\tjeb->last_node ?\n\t\t\t\tref_offset(jeb->last_node) : 0);\n\t\t\tBUG();\n\t\t}\n\t\tref_end = jeb->offset + c->sector_size - jeb->free_size;\n\t}\n\treturn ref_end - ref_offset(ref);\n}"
  },
  {
    "function_name": "ffs2_scan_dirty_space(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "662-689",
    "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs,",
            "ize,",
            "ULL)"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_obsolete(",
          "args": [
            "eb->last_node)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",",
            "ize,",
            "eb->free_size,",
            "eb->wasted_size)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "ize > jeb->free_size)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_link_node_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "585-659",
    "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "ef)"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "ef)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",",
            "ef,",
            "ef_offset(ref),",
            "ef_offset(ref)+len,",
            "ef_offset(jeb->last_node),",
            "ef_offset(jeb->last_node)+last_len)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "eb->last_node)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "eb->last_node)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "ef_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef_offset(ref) != jeb->offset)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_noderef(",
          "args": [
            "New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\",",
            "ef,",
            "ef->flash_offset,",
            "fs,",
            "ef->next_in_ino,",
            "en)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_noderef(",
          "args": [
            "Last node at %p is (%08x,%p)\\n\",",
            "ef,",
            "ef->flash_offset,",
            "ef->next_in_ino)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "jeb->allocated_refs)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
  },
  {
    "function_name": "ffs2_kill_fragtree(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "565-583",
    "snippet": "oid jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)\n{\n\tstruct jffs2_node_frag *frag, *next;\n\n\tdbg_fragtree(\"killing\\n\");\n\trbtree_postorder_for_each_entry_safe(frag, next, root, rb) {\n\t\tif (frag->node && !(--frag->node->frags)) {\n\t\t\t/* Not a hole, and it's the final remaining frag\n\t\t\t   of this node. Free the node */\n\t\t\tif (c)\n\t\t\t\tjffs2_mark_node_obsolete(c, frag->node->raw);\n\n\t\t\tjffs2_free_full_dnode(frag->node);\n\t\t}\n\n\t\tjffs2_free_node_frag(frag);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ond_resched(",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_node_frag(",
          "args": [
            "rag)"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "265-269",
          "snippet": "oid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *node_frag_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *node_frag_slab;\n\noid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dnode(",
          "args": [
            "rag->node)"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "144-148",
          "snippet": "oid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *full_dnode_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *full_dnode_slab;\n\noid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "rag->node->raw)"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_postorder_for_each_entry_safe(",
          "args": [
            "rag,",
            "ext,",
            "oot,",
            "b)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree(",
          "args": [
            "killing\\n\")"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\noid jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)\n{\n\tstruct jffs2_node_frag *frag, *next;\n\n\tdbg_fragtree(\"killing\\n\");\n\trbtree_postorder_for_each_entry_safe(frag, next, root, rb) {\n\t\tif (frag->node && !(--frag->node->frags)) {\n\t\t\t/* Not a hole, and it's the final remaining frag\n\t\t\t   of this node. Free the node */\n\t\t\tif (c)\n\t\t\t\tjffs2_mark_node_obsolete(c, frag->node->raw);\n\n\t\t\tjffs2_free_full_dnode(frag->node);\n\t\t}\n\n\t\tjffs2_free_node_frag(frag);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "ffs2_lookup_node_frag(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "524-561",
    "snippet": "truct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "returning NULL, empty fragtree\\n\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "no match. Returning frag %#04x-%#04x, closest previous\\n\",",
            "rev->ofs,",
            "rev->ofs+prev->size)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_entry(",
          "args": [
            "ext,",
            "truct ffs2_node_frag,",
            "b)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "root %p, offset %d\\n\",",
            "ragtree,",
            "ffset)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}"
  },
  {
    "function_name": "ffs2_free_raw_node_refs(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "504-522",
    "snippet": "oid jffs2_free_raw_node_refs(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_raw_node_ref *this, *next;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tthis = c->blocks[i].first_node;\n\t\twhile (this) {\n\t\t\tif (this[REFS_PER_BLOCK].flash_offset == REF_LINK_NODE)\n\t\t\t\tnext = this[REFS_PER_BLOCK].next_in_ino;\n\t\t\telse\n\t\t\t\tnext = NULL;\n\n\t\t\tjffs2_free_refblock(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->blocks[i].first_node = c->blocks[i].last_node = NULL;\n\t}\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_refblock(",
          "args": [
            "his)"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_refblock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "251-255",
          "snippet": "oid jffs2_free_refblock(struct jffs2_raw_node_ref *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_node_ref_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *raw_node_ref_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *raw_node_ref_slab;\n\noid jffs2_free_refblock(struct jffs2_raw_node_ref *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_node_ref_slab, x);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\noid jffs2_free_raw_node_refs(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_raw_node_ref *this, *next;\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tthis = c->blocks[i].first_node;\n\t\twhile (this) {\n\t\t\tif (this[REFS_PER_BLOCK].flash_offset == REF_LINK_NODE)\n\t\t\t\tnext = this[REFS_PER_BLOCK].next_in_ino;\n\t\t\telse\n\t\t\t\tnext = NULL;\n\n\t\t\tjffs2_free_refblock(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->blocks[i].first_node = c->blocks[i].last_node = NULL;\n\t}\n}"
  },
  {
    "function_name": "ffs2_free_ino_caches(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "487-502",
    "snippet": "oid jffs2_free_ino_caches(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_inode_cache *this, *next;\n\n\tfor (i=0; i < c->inocache_hashsize; i++) {\n\t\tthis = c->inocache_list[i];\n\t\twhile (this) {\n\t\t\tnext = this->next;\n\t\t\tjffs2_xattr_free_inode(c, this);\n\t\t\tjffs2_free_inode_cache(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->inocache_list[i] = NULL;\n\t}\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_inode_cache(",
          "args": [
            "his)"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_inode_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "279-283",
          "snippet": "oid jffs2_free_inode_cache(struct jffs2_inode_cache *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(inode_cache_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *inode_cache_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *inode_cache_slab;\n\noid jffs2_free_inode_cache(struct jffs2_inode_cache *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(inode_cache_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_xattr_free_inode(",
          "args": [
            ",",
            "his)"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_xattr_free_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "614-632",
          "snippet": "oid jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_free_ino_caches() until unmounting FS. */\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\txd = ref->xd;\n\t\tif (atomic_dec_and_test(&xd->refcnt)) {\n\t\t\tunload_xattr_datum(c, xd);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\t/* It's called from jffs2_free_ino_caches() until unmounting FS. */\n\tstruct jffs2_xattr_datum *xd;\n\tstruct jffs2_xattr_ref *ref, *_ref;\n\n\tdown_write(&c->xattr_sem);\n\tfor (ref = ic->xref; ref; ref = _ref) {\n\t\t_ref = ref->next;\n\t\txd = ref->xd;\n\t\tif (atomic_dec_and_test(&xd->refcnt)) {\n\t\t\tunload_xattr_datum(c, xd);\n\t\t\tjffs2_free_xattr_datum(xd);\n\t\t}\n\t\tjffs2_free_xattr_ref(ref);\n\t}\n\tic->xref = NULL;\n\tup_write(&c->xattr_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\noid jffs2_free_ino_caches(struct jffs2_sb_info *c)\n{\n\tint i;\n\tstruct jffs2_inode_cache *this, *next;\n\n\tfor (i=0; i < c->inocache_hashsize; i++) {\n\t\tthis = c->inocache_list[i];\n\t\twhile (this) {\n\t\t\tnext = this->next;\n\t\t\tjffs2_xattr_free_inode(c, this);\n\t\t\tjffs2_free_inode_cache(this);\n\t\t\tthis = next;\n\t\t}\n\t\tc->inocache_list[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "ffs2_del_ino_cache(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "457-485",
    "snippet": "oid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\n{\n\tstruct jffs2_inode_cache **prev;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tBUG_ON(old->xref);\n#endif\n\tdbg_inocache(\"del %p (ino #%u)\\n\", old, old->ino);\n\tspin_lock(&c->inocache_lock);\n\n\tprev = &c->inocache_list[old->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < old->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tif ((*prev) == old) {\n\t\t*prev = old->next;\n\t}\n\n\t/* Free it now unless it's in READING or CLEARING state, which\n\t   are the transitions upon read_inode() and clear_inode(). The\n\t   rest of the time we know nobody else is looking at it, and\n\t   if it's held by read_inode() or clear_inode() they'll free it\n\t   for themselves. */\n\tif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\n\t\tjffs2_free_inode_cache(old);\n\n\tspin_unlock(&c->inocache_lock);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_inode_cache(",
          "args": [
            "ld)"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_inode_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "279-283",
          "snippet": "oid jffs2_free_inode_cache(struct jffs2_inode_cache *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(inode_cache_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *inode_cache_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *inode_cache_slab;\n\noid jffs2_free_inode_cache(struct jffs2_inode_cache *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(inode_cache_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_inocache(",
          "args": [
            "del %p (ino #%u)\\n\",",
            "ld,",
            "ld->ino)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ld->xref)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\n{\n\tstruct jffs2_inode_cache **prev;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tBUG_ON(old->xref);\n#endif\n\tdbg_inocache(\"del %p (ino #%u)\\n\", old, old->ino);\n\tspin_lock(&c->inocache_lock);\n\n\tprev = &c->inocache_list[old->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < old->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tif ((*prev) == old) {\n\t\t*prev = old->next;\n\t}\n\n\t/* Free it now unless it's in READING or CLEARING state, which\n\t   are the transitions upon read_inode() and clear_inode(). The\n\t   rest of the time we know nobody else is looking at it, and\n\t   if it's held by read_inode() or clear_inode() they'll free it\n\t   for themselves. */\n\tif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\n\t\tjffs2_free_inode_cache(old);\n\n\tspin_unlock(&c->inocache_lock);\n}"
  },
  {
    "function_name": "ffs2_add_ino_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "436-455",
    "snippet": "oid jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)\n{\n\tstruct jffs2_inode_cache **prev;\n\n\tspin_lock(&c->inocache_lock);\n\tif (!new->ino)\n\t\tnew->ino = ++c->highest_ino;\n\n\tdbg_inocache(\"add %p (ino #%u)\\n\", new, new->ino);\n\n\tprev = &c->inocache_list[new->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < new->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n\n\tspin_unlock(&c->inocache_lock);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_inocache(",
          "args": [
            "add %p (ino #%u)\\n\",",
            "ew,",
            "ew->ino)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)\n{\n\tstruct jffs2_inode_cache **prev;\n\n\tspin_lock(&c->inocache_lock);\n\tif (!new->ino)\n\t\tnew->ino = ++c->highest_ino;\n\n\tdbg_inocache(\"add %p (ino #%u)\\n\", new, new->ino);\n\n\tprev = &c->inocache_list[new->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < new->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n\n\tspin_unlock(&c->inocache_lock);\n}"
  },
  {
    "function_name": "ffs2_get_ino_cache(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "421-434",
    "snippet": "truct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_set_inocache_state(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "408-414",
    "snippet": "oid jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)\n{\n\tspin_lock(&c->inocache_lock);\n\tic->state = state;\n\twake_up(&c->inocache_wq);\n\tspin_unlock(&c->inocache_lock);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_up(",
          "args": [
            "c->inocache_wq)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->inocache_lock)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)\n{\n\tspin_lock(&c->inocache_lock);\n\tic->state = state;\n\twake_up(&c->inocache_wq);\n\tspin_unlock(&c->inocache_lock);\n}"
  },
  {
    "function_name": "ffs2_add_full_dnode_to_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "363-406",
    "snippet": "nt jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tint ret;\n\tstruct jffs2_node_frag *newfrag;\n\n\tif (unlikely(!fn->size))\n\t\treturn 0;\n\n\tnewfrag = new_fragment(fn, fn->ofs, fn->size);\n\tif (unlikely(!newfrag))\n\t\treturn -ENOMEM;\n\tnewfrag->node->frags = 1;\n\n\tdbg_fragtree(\"adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",\n\t\t  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\n\n\tret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/* If we now share a page with other nodes, mark either previous\n\t   or next node REF_NORMAL, as appropriate.  */\n\tif (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *prev = frag_prev(newfrag);\n\n\t\tmark_ref_normal(fn->raw);\n\t\t/* If we don't start at zero there's _always_ a previous */\n\t\tif (prev->node)\n\t\t\tmark_ref_normal(prev->node->raw);\n\t}\n\n\tif ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *next = frag_next(newfrag);\n\n\t\tif (next) {\n\t\t\tmark_ref_normal(fn->raw);\n\t\t\tif (next->node)\n\t\t\t\tmark_ref_normal(next->node->raw);\n\t\t}\n\t}\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg_fragtree_paranoia_check_nolock(",
          "args": [
            ")"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_fragtree_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "74-119",
          "snippet": "id\n__jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tint bitched = 0;\n\n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tstruct jffs2_full_dnode *fn = frag->node;\n\n\t\tif (!fn || !fn->raw)\n\t\t\tcontinue;\n\n\t\tif (ref_flags(fn->raw) == REF_PRISTINE) {\n\t\t\tif (fn->frags > 1) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw), fn->frags);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\t/* A hole node which isn't multi-page should be garbage-collected\n\t\t\t   and merged anyway, so we just check for the frag size here,\n\t\t\t   rather than mucking around with actually reading the node\n\t\t\t   and checking the compression type, which is the real way\n\t\t\t   to tell a hole node. */\n\t\t\tif (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)\n\t\t\t\t\t&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw));\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\tif ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)\n\t\t\t\t\t&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitched) {\n\t\tJFFS2_ERROR(\"fragtree is corrupted.\\n\");\n\t\t__jffs2_dbg_dump_fragtree_nolock(f);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tint bitched = 0;\n\n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tstruct jffs2_full_dnode *fn = frag->node;\n\n\t\tif (!fn || !fn->raw)\n\t\t\tcontinue;\n\n\t\tif (ref_flags(fn->raw) == REF_PRISTINE) {\n\t\t\tif (fn->frags > 1) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw), fn->frags);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\t/* A hole node which isn't multi-page should be garbage-collected\n\t\t\t   and merged anyway, so we just check for the frag size here,\n\t\t\t   rather than mucking around with actually reading the node\n\t\t\t   and checking the compression type, which is the real way\n\t\t\t   to tell a hole node. */\n\t\t\tif (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)\n\t\t\t\t\t&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t\tref_offset(fn->raw));\n\t\t\t\tbitched = 1;\n\t\t\t}\n\n\t\t\tif ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)\n\t\t\t\t\t&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {\n\t\t\t\tJFFS2_ERROR(\"REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2.\\n\",\n\t\t\t\t       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbitched = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitched) {\n\t\tJFFS2_ERROR(\"fragtree is corrupted.\\n\");\n\t\t__jffs2_dbg_dump_fragtree_nolock(f);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "ext->node->raw)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "n->raw)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_next(",
          "args": [
            "ewfrag)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "rev->node->raw)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "n->raw)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_prev(",
          "args": [
            "ewfrag)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "et)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_frag_to_fragtree(",
          "args": [
            ",",
            "f->fragtree,",
            "ewfrag)"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_frag_to_fragtree(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "215-357",
          "snippet": "tatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\n{\n\tstruct jffs2_node_frag *this;\n\tuint32_t lastend;\n\n\t/* Skip all the nodes which are completed before this one starts */\n\tthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\n\n\tif (this) {\n\t\tdbg_fragtree2(\"lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",\n\t\t\t  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\n\t\tlastend = this->ofs + this->size;\n\t} else {\n\t\tdbg_fragtree2(\"lookup gave no frag\\n\");\n\t\tlastend = 0;\n\t}\n\n\t/* See if we ran off the end of the fragtree */\n\tif (lastend <= newfrag->ofs) {\n\t\t/* We did */\n\n\t\t/* Check if 'this' node was on the same page as the new node.\n\t\t   If so, both 'this' and the new node get marked REF_NORMAL so\n\t\t   the GC can take a look.\n\t\t*/\n\t\tif (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {\n\t\t\tif (this->node)\n\t\t\t\tmark_ref_normal(this->node->raw);\n\t\t\tmark_ref_normal(newfrag->node->raw);\n\t\t}\n\n\t\treturn no_overlapping_node(c, root, newfrag, this, lastend);\n\t}\n\n\tif (this->node)\n\t\tdbg_fragtree2(\"dealing with frag %u-%u, phys %#08x(%d).\\n\",\n\t\tthis->ofs, this->ofs + this->size,\n\t\tref_offset(this->node->raw), ref_flags(this->node->raw));\n\telse\n\t\tdbg_fragtree2(\"dealing with hole frag %u-%u.\\n\",\n\t\tthis->ofs, this->ofs + this->size);\n\n\t/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,\n\t * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs\n\t */\n\tif (newfrag->ofs > this->ofs) {\n\t\t/* This node isn't completely obsoleted. The start of it remains valid */\n\n\t\t/* Mark the new node and the partially covered node REF_NORMAL -- let\n\t\t   the GC take a look at them */\n\t\tmark_ref_normal(newfrag->node->raw);\n\t\tif (this->node)\n\t\t\tmark_ref_normal(this->node->raw);\n\n\t\tif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\n\t\t\t/* The new node splits 'this' frag into two */\n\t\t\tstruct jffs2_node_frag *newfrag2;\n\n\t\t\tif (this->node)\n\t\t\t\tdbg_fragtree2(\"split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\n\t\t\telse\n\t\t\t\tdbg_fragtree2(\"split old hole frag 0x%04x-0x%04x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size);\n\n\t\t\t/* New second frag pointing to this's node */\n\t\t\tnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\n\t\t\t\t\t\tthis->ofs + this->size - newfrag->ofs - newfrag->size);\n\t\t\tif (unlikely(!newfrag2))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (this->node)\n\t\t\t\tthis->node->frags++;\n\n\t\t\t/* Adjust size of original 'this' */\n\t\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t\t/* Now, we know there's no node with offset\n\t\t\t   greater than this->ofs but smaller than\n\t\t\t   newfrag2->ofs or newfrag->ofs, for obvious\n\t\t\t   reasons. So we can do a tree insert from\n\t\t\t   'this' to insert newfrag, and a tree insert\n\t\t\t   from newfrag to insert newfrag2. */\n\t\t\tjffs2_fragtree_insert(newfrag, this);\n\t\t\trb_insert_color(&newfrag->rb, root);\n\n\t\t\tjffs2_fragtree_insert(newfrag2, newfrag);\n\t\t\trb_insert_color(&newfrag2->rb, root);\n\n\t\t\treturn 0;\n\t\t}\n\t\t/* New node just reduces 'this' frag in size, doesn't split it */\n\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t/* Again, we know it lives down here in the tree */\n\t\tjffs2_fragtree_insert(newfrag, this);\n\t\trb_insert_color(&newfrag->rb, root);\n\t} else {\n\t\t/* New frag starts at the same point as 'this' used to. Replace\n\t\t   it in the tree without doing a delete and insertion */\n\t\tdbg_fragtree2(\"inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",\n\t\t\t  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\n\n\t\trb_replace_node(&this->rb, &newfrag->rb, root);\n\n\t\tif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\n\t\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x)\\n\", this, this->ofs, this->ofs+this->size);\n\t\t\tjffs2_obsolete_node_frag(c, this);\n\t\t} else {\n\t\t\tthis->ofs += newfrag->size;\n\t\t\tthis->size -= newfrag->size;\n\n\t\t\tjffs2_fragtree_insert(this, newfrag);\n\t\t\trb_insert_color(&this->rb, root);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* OK, now we have newfrag added in the correct place in the tree, but\n\t   frag_next(newfrag) may be a fragment which is overlapped by it\n\t*/\n\twhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\n\t\t/* 'this' frag is obsoleted completely. */\n\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x) and removing from tree\\n\",\n\t\t\tthis, this->ofs, this->ofs+this->size);\n\t\trb_erase(&this->rb, root);\n\t\tjffs2_obsolete_node_frag(c, this);\n\t}\n\t/* Now we're pointing at the first frag which isn't totally obsoleted by\n\t   the new frag */\n\n\tif (!this || newfrag->ofs + newfrag->size == this->ofs)\n\t\treturn 0;\n\n\t/* Still some overlap but we don't need to move it in the tree */\n\tthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\n\tthis->ofs = newfrag->ofs + newfrag->size;\n\n\t/* And mark them REF_NORMAL so the GC takes a look at them */\n\tif (this->node)\n\t\tmark_ref_normal(this->node->raw);\n\tmark_ref_normal(newfrag->node->raw);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\n{\n\tstruct jffs2_node_frag *this;\n\tuint32_t lastend;\n\n\t/* Skip all the nodes which are completed before this one starts */\n\tthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\n\n\tif (this) {\n\t\tdbg_fragtree2(\"lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",\n\t\t\t  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\n\t\tlastend = this->ofs + this->size;\n\t} else {\n\t\tdbg_fragtree2(\"lookup gave no frag\\n\");\n\t\tlastend = 0;\n\t}\n\n\t/* See if we ran off the end of the fragtree */\n\tif (lastend <= newfrag->ofs) {\n\t\t/* We did */\n\n\t\t/* Check if 'this' node was on the same page as the new node.\n\t\t   If so, both 'this' and the new node get marked REF_NORMAL so\n\t\t   the GC can take a look.\n\t\t*/\n\t\tif (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {\n\t\t\tif (this->node)\n\t\t\t\tmark_ref_normal(this->node->raw);\n\t\t\tmark_ref_normal(newfrag->node->raw);\n\t\t}\n\n\t\treturn no_overlapping_node(c, root, newfrag, this, lastend);\n\t}\n\n\tif (this->node)\n\t\tdbg_fragtree2(\"dealing with frag %u-%u, phys %#08x(%d).\\n\",\n\t\tthis->ofs, this->ofs + this->size,\n\t\tref_offset(this->node->raw), ref_flags(this->node->raw));\n\telse\n\t\tdbg_fragtree2(\"dealing with hole frag %u-%u.\\n\",\n\t\tthis->ofs, this->ofs + this->size);\n\n\t/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,\n\t * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs\n\t */\n\tif (newfrag->ofs > this->ofs) {\n\t\t/* This node isn't completely obsoleted. The start of it remains valid */\n\n\t\t/* Mark the new node and the partially covered node REF_NORMAL -- let\n\t\t   the GC take a look at them */\n\t\tmark_ref_normal(newfrag->node->raw);\n\t\tif (this->node)\n\t\t\tmark_ref_normal(this->node->raw);\n\n\t\tif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\n\t\t\t/* The new node splits 'this' frag into two */\n\t\t\tstruct jffs2_node_frag *newfrag2;\n\n\t\t\tif (this->node)\n\t\t\t\tdbg_fragtree2(\"split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\n\t\t\telse\n\t\t\t\tdbg_fragtree2(\"split old hole frag 0x%04x-0x%04x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size);\n\n\t\t\t/* New second frag pointing to this's node */\n\t\t\tnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\n\t\t\t\t\t\tthis->ofs + this->size - newfrag->ofs - newfrag->size);\n\t\t\tif (unlikely(!newfrag2))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (this->node)\n\t\t\t\tthis->node->frags++;\n\n\t\t\t/* Adjust size of original 'this' */\n\t\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t\t/* Now, we know there's no node with offset\n\t\t\t   greater than this->ofs but smaller than\n\t\t\t   newfrag2->ofs or newfrag->ofs, for obvious\n\t\t\t   reasons. So we can do a tree insert from\n\t\t\t   'this' to insert newfrag, and a tree insert\n\t\t\t   from newfrag to insert newfrag2. */\n\t\t\tjffs2_fragtree_insert(newfrag, this);\n\t\t\trb_insert_color(&newfrag->rb, root);\n\n\t\t\tjffs2_fragtree_insert(newfrag2, newfrag);\n\t\t\trb_insert_color(&newfrag2->rb, root);\n\n\t\t\treturn 0;\n\t\t}\n\t\t/* New node just reduces 'this' frag in size, doesn't split it */\n\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t/* Again, we know it lives down here in the tree */\n\t\tjffs2_fragtree_insert(newfrag, this);\n\t\trb_insert_color(&newfrag->rb, root);\n\t} else {\n\t\t/* New frag starts at the same point as 'this' used to. Replace\n\t\t   it in the tree without doing a delete and insertion */\n\t\tdbg_fragtree2(\"inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",\n\t\t\t  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\n\n\t\trb_replace_node(&this->rb, &newfrag->rb, root);\n\n\t\tif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\n\t\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x)\\n\", this, this->ofs, this->ofs+this->size);\n\t\t\tjffs2_obsolete_node_frag(c, this);\n\t\t} else {\n\t\t\tthis->ofs += newfrag->size;\n\t\t\tthis->size -= newfrag->size;\n\n\t\t\tjffs2_fragtree_insert(this, newfrag);\n\t\t\trb_insert_color(&this->rb, root);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* OK, now we have newfrag added in the correct place in the tree, but\n\t   frag_next(newfrag) may be a fragment which is overlapped by it\n\t*/\n\twhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\n\t\t/* 'this' frag is obsoleted completely. */\n\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x) and removing from tree\\n\",\n\t\t\tthis, this->ofs, this->ofs+this->size);\n\t\trb_erase(&this->rb, root);\n\t\tjffs2_obsolete_node_frag(c, this);\n\t}\n\t/* Now we're pointing at the first frag which isn't totally obsoleted by\n\t   the new frag */\n\n\tif (!this || newfrag->ofs + newfrag->size == this->ofs)\n\t\treturn 0;\n\n\t/* Still some overlap but we don't need to move it in the tree */\n\tthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\n\tthis->ofs = newfrag->ofs + newfrag->size;\n\n\t/* And mark them REF_NORMAL so the GC takes a look at them */\n\tif (this->node)\n\t\tmark_ref_normal(this->node->raw);\n\tmark_ref_normal(newfrag->node->raw);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_fragtree(",
          "args": [
            "adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",",
            "n->ofs,",
            "n->ofs+fn->size,",
            "ef_offset(fn->raw),",
            "ewfrag)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "n->raw)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "newfrag)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_fragment(",
          "args": [
            "n,",
            "n->ofs,",
            "n->size)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "ew_fragment(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "149-163",
          "snippet": "tatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "fn->size)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tint ret;\n\tstruct jffs2_node_frag *newfrag;\n\n\tif (unlikely(!fn->size))\n\t\treturn 0;\n\n\tnewfrag = new_fragment(fn, fn->ofs, fn->size);\n\tif (unlikely(!newfrag))\n\t\treturn -ENOMEM;\n\tnewfrag->node->frags = 1;\n\n\tdbg_fragtree(\"adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",\n\t\t  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\n\n\tret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/* If we now share a page with other nodes, mark either previous\n\t   or next node REF_NORMAL, as appropriate.  */\n\tif (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *prev = frag_prev(newfrag);\n\n\t\tmark_ref_normal(fn->raw);\n\t\t/* If we don't start at zero there's _always_ a previous */\n\t\tif (prev->node)\n\t\t\tmark_ref_normal(prev->node->raw);\n\t}\n\n\tif ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *next = frag_next(newfrag);\n\n\t\tif (next) {\n\t\t\tmark_ref_normal(fn->raw);\n\t\t\tif (next->node)\n\t\t\t\tmark_ref_normal(next->node->raw);\n\t\t}\n\t}\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_add_frag_to_fragtree(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "215-357",
    "snippet": "tatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\n{\n\tstruct jffs2_node_frag *this;\n\tuint32_t lastend;\n\n\t/* Skip all the nodes which are completed before this one starts */\n\tthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\n\n\tif (this) {\n\t\tdbg_fragtree2(\"lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",\n\t\t\t  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\n\t\tlastend = this->ofs + this->size;\n\t} else {\n\t\tdbg_fragtree2(\"lookup gave no frag\\n\");\n\t\tlastend = 0;\n\t}\n\n\t/* See if we ran off the end of the fragtree */\n\tif (lastend <= newfrag->ofs) {\n\t\t/* We did */\n\n\t\t/* Check if 'this' node was on the same page as the new node.\n\t\t   If so, both 'this' and the new node get marked REF_NORMAL so\n\t\t   the GC can take a look.\n\t\t*/\n\t\tif (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {\n\t\t\tif (this->node)\n\t\t\t\tmark_ref_normal(this->node->raw);\n\t\t\tmark_ref_normal(newfrag->node->raw);\n\t\t}\n\n\t\treturn no_overlapping_node(c, root, newfrag, this, lastend);\n\t}\n\n\tif (this->node)\n\t\tdbg_fragtree2(\"dealing with frag %u-%u, phys %#08x(%d).\\n\",\n\t\tthis->ofs, this->ofs + this->size,\n\t\tref_offset(this->node->raw), ref_flags(this->node->raw));\n\telse\n\t\tdbg_fragtree2(\"dealing with hole frag %u-%u.\\n\",\n\t\tthis->ofs, this->ofs + this->size);\n\n\t/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,\n\t * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs\n\t */\n\tif (newfrag->ofs > this->ofs) {\n\t\t/* This node isn't completely obsoleted. The start of it remains valid */\n\n\t\t/* Mark the new node and the partially covered node REF_NORMAL -- let\n\t\t   the GC take a look at them */\n\t\tmark_ref_normal(newfrag->node->raw);\n\t\tif (this->node)\n\t\t\tmark_ref_normal(this->node->raw);\n\n\t\tif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\n\t\t\t/* The new node splits 'this' frag into two */\n\t\t\tstruct jffs2_node_frag *newfrag2;\n\n\t\t\tif (this->node)\n\t\t\t\tdbg_fragtree2(\"split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\n\t\t\telse\n\t\t\t\tdbg_fragtree2(\"split old hole frag 0x%04x-0x%04x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size);\n\n\t\t\t/* New second frag pointing to this's node */\n\t\t\tnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\n\t\t\t\t\t\tthis->ofs + this->size - newfrag->ofs - newfrag->size);\n\t\t\tif (unlikely(!newfrag2))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (this->node)\n\t\t\t\tthis->node->frags++;\n\n\t\t\t/* Adjust size of original 'this' */\n\t\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t\t/* Now, we know there's no node with offset\n\t\t\t   greater than this->ofs but smaller than\n\t\t\t   newfrag2->ofs or newfrag->ofs, for obvious\n\t\t\t   reasons. So we can do a tree insert from\n\t\t\t   'this' to insert newfrag, and a tree insert\n\t\t\t   from newfrag to insert newfrag2. */\n\t\t\tjffs2_fragtree_insert(newfrag, this);\n\t\t\trb_insert_color(&newfrag->rb, root);\n\n\t\t\tjffs2_fragtree_insert(newfrag2, newfrag);\n\t\t\trb_insert_color(&newfrag2->rb, root);\n\n\t\t\treturn 0;\n\t\t}\n\t\t/* New node just reduces 'this' frag in size, doesn't split it */\n\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t/* Again, we know it lives down here in the tree */\n\t\tjffs2_fragtree_insert(newfrag, this);\n\t\trb_insert_color(&newfrag->rb, root);\n\t} else {\n\t\t/* New frag starts at the same point as 'this' used to. Replace\n\t\t   it in the tree without doing a delete and insertion */\n\t\tdbg_fragtree2(\"inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",\n\t\t\t  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\n\n\t\trb_replace_node(&this->rb, &newfrag->rb, root);\n\n\t\tif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\n\t\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x)\\n\", this, this->ofs, this->ofs+this->size);\n\t\t\tjffs2_obsolete_node_frag(c, this);\n\t\t} else {\n\t\t\tthis->ofs += newfrag->size;\n\t\t\tthis->size -= newfrag->size;\n\n\t\t\tjffs2_fragtree_insert(this, newfrag);\n\t\t\trb_insert_color(&this->rb, root);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* OK, now we have newfrag added in the correct place in the tree, but\n\t   frag_next(newfrag) may be a fragment which is overlapped by it\n\t*/\n\twhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\n\t\t/* 'this' frag is obsoleted completely. */\n\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x) and removing from tree\\n\",\n\t\t\tthis, this->ofs, this->ofs+this->size);\n\t\trb_erase(&this->rb, root);\n\t\tjffs2_obsolete_node_frag(c, this);\n\t}\n\t/* Now we're pointing at the first frag which isn't totally obsoleted by\n\t   the new frag */\n\n\tif (!this || newfrag->ofs + newfrag->size == this->ofs)\n\t\treturn 0;\n\n\t/* Still some overlap but we don't need to move it in the tree */\n\tthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\n\tthis->ofs = newfrag->ofs + newfrag->size;\n\n\t/* And mark them REF_NORMAL so the GC takes a look at them */\n\tif (this->node)\n\t\tmark_ref_normal(this->node->raw);\n\tmark_ref_normal(newfrag->node->raw);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "ewfrag->node->raw)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "his->node->raw)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_obsolete_node_frag(",
          "args": [
            ",",
            "his)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_obsolete_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "101-120",
          "snippet": "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}"
        }
      },
      {
        "call_info": {
          "callee": "b_erase(",
          "args": [
            "this->rb,",
            "oot)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "obsoleting node frag %p (%x-%x) and removing from tree\\n\",",
            "his,",
            "his->ofs,",
            "his->ofs+this->size)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_next(",
          "args": [
            "ewfrag)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "this->rb,",
            "oot)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_fragtree_insert(",
          "args": [
            "his,",
            "ewfrag)"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_fragtree_insert(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "122-144",
          "snippet": "tatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\n{\n\tstruct rb_node *parent = &base->rb;\n\tstruct rb_node **link = &parent;\n\n\tdbg_fragtree2(\"insert frag (0x%04x-0x%04x)\\n\", newfrag->ofs, newfrag->ofs + newfrag->size);\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbase = rb_entry(parent, struct jffs2_node_frag, rb);\n\n\t\tif (newfrag->ofs > base->ofs)\n\t\t\tlink = &base->rb.rb_right;\n\t\telse if (newfrag->ofs < base->ofs)\n\t\t\tlink = &base->rb.rb_left;\n\t\telse {\n\t\t\tJFFS2_ERROR(\"duplicate frag at %08x (%p,%p)\\n\", newfrag->ofs, newfrag, base);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&newfrag->rb, &base->rb, link);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\n{\n\tstruct rb_node *parent = &base->rb;\n\tstruct rb_node **link = &parent;\n\n\tdbg_fragtree2(\"insert frag (0x%04x-0x%04x)\\n\", newfrag->ofs, newfrag->ofs + newfrag->size);\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbase = rb_entry(parent, struct jffs2_node_frag, rb);\n\n\t\tif (newfrag->ofs > base->ofs)\n\t\t\tlink = &base->rb.rb_right;\n\t\telse if (newfrag->ofs < base->ofs)\n\t\t\tlink = &base->rb.rb_left;\n\t\telse {\n\t\t\tJFFS2_ERROR(\"duplicate frag at %08x (%p,%p)\\n\", newfrag->ofs, newfrag, base);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&newfrag->rb, &base->rb, link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "obsoleting node frag %p (%x-%x)\\n\",",
            "his,",
            "his->ofs,",
            "his->ofs+this->size)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_replace_node(",
          "args": [
            "this->rb,",
            "newfrag->rb,",
            "oot)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",",
            "ewfrag,",
            "ewfrag->ofs,",
            "ewfrag->ofs+newfrag->size,",
            "his,",
            "his->ofs,",
            "his->ofs+this->size)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "newfrag->rb,",
            "oot)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "newfrag2->rb,",
            "oot)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "newfrag->rb,",
            "oot)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "newfrag2)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_fragment(",
          "args": [
            "his->node,",
            "ewfrag->ofs + newfrag->size,",
            "his->ofs + this->size - newfrag->ofs - newfrag->size)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ew_fragment(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "149-163",
          "snippet": "tatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "split old hole frag 0x%04x-0x%04x\\n\",",
            "his->ofs,",
            "his->ofs+this->size)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",",
            "his->ofs,",
            "his->ofs+this->size,",
            "ef_offset(this->node->raw))"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "his->node->raw)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "his->node->raw)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "ewfrag->node->raw)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "dealing with hole frag %u-%u.\\n\",",
            "his->ofs,",
            "his->ofs + this->size)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "dealing with frag %u-%u, phys %#08x(%d).\\n\",",
            "his->ofs,",
            "his->ofs + this->size,",
            "ef_offset(this->node->raw),",
            "ef_flags(this->node->raw))"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "his->node->raw)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "his->node->raw)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_overlapping_node(",
          "args": [
            ",",
            "oot,",
            "ewfrag,",
            "his,",
            "astend)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "o_overlapping_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "169-212",
          "snippet": "tatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\n\t\t \t       struct jffs2_node_frag *newfrag,\n\t\t\t       struct jffs2_node_frag *this, uint32_t lastend)\n{\n\tif (lastend < newfrag->node->ofs) {\n\t\t/* put a hole in before the new fragment */\n\t\tstruct jffs2_node_frag *holefrag;\n\n\t\tholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\n\t\tif (unlikely(!holefrag)) {\n\t\t\tjffs2_free_node_frag(newfrag);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (this) {\n\t\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t\t   because there are no frags with offset greater than it.\n\t\t\t   So that's where we want to put the hole */\n\t\t\tdbg_fragtree2(\"add hole frag %#04x-%#04x on the right of the new frag.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"Add hole frag %#04x-%#04x to the root of the tree.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, NULL, &root->rb_node);\n\t\t}\n\t\trb_insert_color(&holefrag->rb, root);\n\t\tthis = holefrag;\n\t}\n\n\tif (this) {\n\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t   because there are no frags with offset greater than it.\n\t\t   So that's where we want to put new fragment */\n\t\tdbg_fragtree2(\"add the new node at the right\\n\");\n\t\trb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\n\t} else {\n\t\tdbg_fragtree2(\"insert the new node at the root of the tree\\n\");\n\t\trb_link_node(&newfrag->rb, NULL, &root->rb_node);\n\t}\n\trb_insert_color(&newfrag->rb, root);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\n\t\t \t       struct jffs2_node_frag *newfrag,\n\t\t\t       struct jffs2_node_frag *this, uint32_t lastend)\n{\n\tif (lastend < newfrag->node->ofs) {\n\t\t/* put a hole in before the new fragment */\n\t\tstruct jffs2_node_frag *holefrag;\n\n\t\tholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\n\t\tif (unlikely(!holefrag)) {\n\t\t\tjffs2_free_node_frag(newfrag);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (this) {\n\t\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t\t   because there are no frags with offset greater than it.\n\t\t\t   So that's where we want to put the hole */\n\t\t\tdbg_fragtree2(\"add hole frag %#04x-%#04x on the right of the new frag.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"Add hole frag %#04x-%#04x to the root of the tree.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, NULL, &root->rb_node);\n\t\t}\n\t\trb_insert_color(&holefrag->rb, root);\n\t\tthis = holefrag;\n\t}\n\n\tif (this) {\n\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t   because there are no frags with offset greater than it.\n\t\t   So that's where we want to put new fragment */\n\t\tdbg_fragtree2(\"add the new node at the right\\n\");\n\t\trb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\n\t} else {\n\t\tdbg_fragtree2(\"insert the new node at the root of the tree\\n\");\n\t\trb_link_node(&newfrag->rb, NULL, &root->rb_node);\n\t}\n\trb_insert_color(&newfrag->rb, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "ewfrag->node->raw)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "his->node->raw)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "lookup gave no frag\\n\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",",
            "his->ofs,",
            "his->ofs+this->size,",
            "his->node?(ref_offset(this->node->raw)):0xffffffff,",
            "his)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "his->node->raw)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_lookup_node_frag(",
          "args": [
            "oot,",
            "ewfrag->node->ofs)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_lookup_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "524-561",
          "snippet": "truct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\n{\n\tstruct jffs2_node_frag *this;\n\tuint32_t lastend;\n\n\t/* Skip all the nodes which are completed before this one starts */\n\tthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\n\n\tif (this) {\n\t\tdbg_fragtree2(\"lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\\n\",\n\t\t\t  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\n\t\tlastend = this->ofs + this->size;\n\t} else {\n\t\tdbg_fragtree2(\"lookup gave no frag\\n\");\n\t\tlastend = 0;\n\t}\n\n\t/* See if we ran off the end of the fragtree */\n\tif (lastend <= newfrag->ofs) {\n\t\t/* We did */\n\n\t\t/* Check if 'this' node was on the same page as the new node.\n\t\t   If so, both 'this' and the new node get marked REF_NORMAL so\n\t\t   the GC can take a look.\n\t\t*/\n\t\tif (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {\n\t\t\tif (this->node)\n\t\t\t\tmark_ref_normal(this->node->raw);\n\t\t\tmark_ref_normal(newfrag->node->raw);\n\t\t}\n\n\t\treturn no_overlapping_node(c, root, newfrag, this, lastend);\n\t}\n\n\tif (this->node)\n\t\tdbg_fragtree2(\"dealing with frag %u-%u, phys %#08x(%d).\\n\",\n\t\tthis->ofs, this->ofs + this->size,\n\t\tref_offset(this->node->raw), ref_flags(this->node->raw));\n\telse\n\t\tdbg_fragtree2(\"dealing with hole frag %u-%u.\\n\",\n\t\tthis->ofs, this->ofs + this->size);\n\n\t/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,\n\t * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs\n\t */\n\tif (newfrag->ofs > this->ofs) {\n\t\t/* This node isn't completely obsoleted. The start of it remains valid */\n\n\t\t/* Mark the new node and the partially covered node REF_NORMAL -- let\n\t\t   the GC take a look at them */\n\t\tmark_ref_normal(newfrag->node->raw);\n\t\tif (this->node)\n\t\t\tmark_ref_normal(this->node->raw);\n\n\t\tif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\n\t\t\t/* The new node splits 'this' frag into two */\n\t\t\tstruct jffs2_node_frag *newfrag2;\n\n\t\t\tif (this->node)\n\t\t\t\tdbg_fragtree2(\"split old frag 0x%04x-0x%04x, phys 0x%08x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\n\t\t\telse\n\t\t\t\tdbg_fragtree2(\"split old hole frag 0x%04x-0x%04x\\n\",\n\t\t\t\t\tthis->ofs, this->ofs+this->size);\n\n\t\t\t/* New second frag pointing to this's node */\n\t\t\tnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\n\t\t\t\t\t\tthis->ofs + this->size - newfrag->ofs - newfrag->size);\n\t\t\tif (unlikely(!newfrag2))\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (this->node)\n\t\t\t\tthis->node->frags++;\n\n\t\t\t/* Adjust size of original 'this' */\n\t\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t\t/* Now, we know there's no node with offset\n\t\t\t   greater than this->ofs but smaller than\n\t\t\t   newfrag2->ofs or newfrag->ofs, for obvious\n\t\t\t   reasons. So we can do a tree insert from\n\t\t\t   'this' to insert newfrag, and a tree insert\n\t\t\t   from newfrag to insert newfrag2. */\n\t\t\tjffs2_fragtree_insert(newfrag, this);\n\t\t\trb_insert_color(&newfrag->rb, root);\n\n\t\t\tjffs2_fragtree_insert(newfrag2, newfrag);\n\t\t\trb_insert_color(&newfrag2->rb, root);\n\n\t\t\treturn 0;\n\t\t}\n\t\t/* New node just reduces 'this' frag in size, doesn't split it */\n\t\tthis->size = newfrag->ofs - this->ofs;\n\n\t\t/* Again, we know it lives down here in the tree */\n\t\tjffs2_fragtree_insert(newfrag, this);\n\t\trb_insert_color(&newfrag->rb, root);\n\t} else {\n\t\t/* New frag starts at the same point as 'this' used to. Replace\n\t\t   it in the tree without doing a delete and insertion */\n\t\tdbg_fragtree2(\"inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\\n\",\n\t\t\t  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\n\n\t\trb_replace_node(&this->rb, &newfrag->rb, root);\n\n\t\tif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\n\t\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x)\\n\", this, this->ofs, this->ofs+this->size);\n\t\t\tjffs2_obsolete_node_frag(c, this);\n\t\t} else {\n\t\t\tthis->ofs += newfrag->size;\n\t\t\tthis->size -= newfrag->size;\n\n\t\t\tjffs2_fragtree_insert(this, newfrag);\n\t\t\trb_insert_color(&this->rb, root);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* OK, now we have newfrag added in the correct place in the tree, but\n\t   frag_next(newfrag) may be a fragment which is overlapped by it\n\t*/\n\twhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\n\t\t/* 'this' frag is obsoleted completely. */\n\t\tdbg_fragtree2(\"obsoleting node frag %p (%x-%x) and removing from tree\\n\",\n\t\t\tthis, this->ofs, this->ofs+this->size);\n\t\trb_erase(&this->rb, root);\n\t\tjffs2_obsolete_node_frag(c, this);\n\t}\n\t/* Now we're pointing at the first frag which isn't totally obsoleted by\n\t   the new frag */\n\n\tif (!this || newfrag->ofs + newfrag->size == this->ofs)\n\t\treturn 0;\n\n\t/* Still some overlap but we don't need to move it in the tree */\n\tthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\n\tthis->ofs = newfrag->ofs + newfrag->size;\n\n\t/* And mark them REF_NORMAL so the GC takes a look at them */\n\tif (this->node)\n\t\tmark_ref_normal(this->node->raw);\n\tmark_ref_normal(newfrag->node->raw);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "o_overlapping_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "169-212",
    "snippet": "tatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\n\t\t \t       struct jffs2_node_frag *newfrag,\n\t\t\t       struct jffs2_node_frag *this, uint32_t lastend)\n{\n\tif (lastend < newfrag->node->ofs) {\n\t\t/* put a hole in before the new fragment */\n\t\tstruct jffs2_node_frag *holefrag;\n\n\t\tholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\n\t\tif (unlikely(!holefrag)) {\n\t\t\tjffs2_free_node_frag(newfrag);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (this) {\n\t\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t\t   because there are no frags with offset greater than it.\n\t\t\t   So that's where we want to put the hole */\n\t\t\tdbg_fragtree2(\"add hole frag %#04x-%#04x on the right of the new frag.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"Add hole frag %#04x-%#04x to the root of the tree.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, NULL, &root->rb_node);\n\t\t}\n\t\trb_insert_color(&holefrag->rb, root);\n\t\tthis = holefrag;\n\t}\n\n\tif (this) {\n\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t   because there are no frags with offset greater than it.\n\t\t   So that's where we want to put new fragment */\n\t\tdbg_fragtree2(\"add the new node at the right\\n\");\n\t\trb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\n\t} else {\n\t\tdbg_fragtree2(\"insert the new node at the root of the tree\\n\");\n\t\trb_link_node(&newfrag->rb, NULL, &root->rb_node);\n\t}\n\trb_insert_color(&newfrag->rb, root);\n\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "newfrag->rb,",
            "oot)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "newfrag->rb,",
            "ULL,",
            "root->rb_node)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "insert the new node at the root of the tree\\n\")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "newfrag->rb,",
            "this->rb,",
            "this->rb.rb_right)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "add the new node at the right\\n\")"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "holefrag->rb,",
            "oot)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "holefrag->rb,",
            "ULL,",
            "root->rb_node)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "Add hole frag %#04x-%#04x to the root of the tree.\\n\",",
            "olefrag->ofs,",
            "olefrag->ofs + holefrag->size)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "holefrag->rb,",
            "this->rb,",
            "this->rb.rb_right)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "add hole frag %#04x-%#04x on the right of the new frag.\\n\",",
            "olefrag->ofs,",
            "olefrag->ofs + holefrag->size)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_node_frag(",
          "args": [
            "ewfrag)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "265-269",
          "snippet": "oid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *node_frag_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *node_frag_slab;\n\noid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "holefrag)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_fragment(",
          "args": [
            "ULL,",
            "astend,",
            "ewfrag->node->ofs - lastend)"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ew_fragment(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "149-163",
          "snippet": "tatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\n\t\t \t       struct jffs2_node_frag *newfrag,\n\t\t\t       struct jffs2_node_frag *this, uint32_t lastend)\n{\n\tif (lastend < newfrag->node->ofs) {\n\t\t/* put a hole in before the new fragment */\n\t\tstruct jffs2_node_frag *holefrag;\n\n\t\tholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\n\t\tif (unlikely(!holefrag)) {\n\t\t\tjffs2_free_node_frag(newfrag);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (this) {\n\t\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t\t   because there are no frags with offset greater than it.\n\t\t\t   So that's where we want to put the hole */\n\t\t\tdbg_fragtree2(\"add hole frag %#04x-%#04x on the right of the new frag.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"Add hole frag %#04x-%#04x to the root of the tree.\\n\",\n\t\t\t\tholefrag->ofs, holefrag->ofs + holefrag->size);\n\t\t\trb_link_node(&holefrag->rb, NULL, &root->rb_node);\n\t\t}\n\t\trb_insert_color(&holefrag->rb, root);\n\t\tthis = holefrag;\n\t}\n\n\tif (this) {\n\t\t/* By definition, the 'this' node has no right-hand child,\n\t\t   because there are no frags with offset greater than it.\n\t\t   So that's where we want to put new fragment */\n\t\tdbg_fragtree2(\"add the new node at the right\\n\");\n\t\trb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\n\t} else {\n\t\tdbg_fragtree2(\"insert the new node at the root of the tree\\n\");\n\t\trb_link_node(&newfrag->rb, NULL, &root->rb_node);\n\t}\n\trb_insert_color(&newfrag->rb, root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ew_fragment(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "149-163",
    "snippet": "tatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "cannot allocate a jffs2_node_frag object\\n\")"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(",
          "args": [
            "ewfrag)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_node_frag(",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}"
  },
  {
    "function_name": "ffs2_fragtree_insert(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "122-144",
    "snippet": "tatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\n{\n\tstruct rb_node *parent = &base->rb;\n\tstruct rb_node **link = &parent;\n\n\tdbg_fragtree2(\"insert frag (0x%04x-0x%04x)\\n\", newfrag->ofs, newfrag->ofs + newfrag->size);\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbase = rb_entry(parent, struct jffs2_node_frag, rb);\n\n\t\tif (newfrag->ofs > base->ofs)\n\t\t\tlink = &base->rb.rb_right;\n\t\telse if (newfrag->ofs < base->ofs)\n\t\t\tlink = &base->rb.rb_left;\n\t\telse {\n\t\t\tJFFS2_ERROR(\"duplicate frag at %08x (%p,%p)\\n\", newfrag->ofs, newfrag, base);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&newfrag->rb, &base->rb, link);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "newfrag->rb,",
            "base->rb,",
            "ink)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "duplicate frag at %08x (%p,%p)\\n\",",
            "ewfrag->ofs,",
            "ewfrag,",
            "ase)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_entry(",
          "args": [
            "arent,",
            "truct ffs2_node_frag,",
            "b)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "insert frag (0x%04x-0x%04x)\\n\",",
            "ewfrag->ofs,",
            "ewfrag->ofs + newfrag->size)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\n{\n\tstruct rb_node *parent = &base->rb;\n\tstruct rb_node **link = &parent;\n\n\tdbg_fragtree2(\"insert frag (0x%04x-0x%04x)\\n\", newfrag->ofs, newfrag->ofs + newfrag->size);\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tbase = rb_entry(parent, struct jffs2_node_frag, rb);\n\n\t\tif (newfrag->ofs > base->ofs)\n\t\t\tlink = &base->rb.rb_right;\n\t\telse if (newfrag->ofs < base->ofs)\n\t\t\tlink = &base->rb.rb_left;\n\t\telse {\n\t\t\tJFFS2_ERROR(\"duplicate frag at %08x (%p,%p)\\n\", newfrag->ofs, newfrag, base);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&newfrag->rb, &base->rb, link);\n}"
  },
  {
    "function_name": "ffs2_obsolete_node_frag(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "101-120",
    "snippet": "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_node_frag(",
          "args": [
            "his)"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "265-269",
          "snippet": "oid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *node_frag_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *node_frag_slab;\n\noid jffs2_free_node_frag(struct jffs2_node_frag *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(node_frag_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ark_ref_normal(",
          "args": [
            "his->node->raw)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",",
            "ef_offset(this->node->raw),",
            "his->node->ofs,",
            "his->node->ofs+this->node->size,",
            "his->node->frags)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "his->node->raw)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dnode(",
          "args": [
            "his->node)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "144-148",
          "snippet": "oid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *full_dnode_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *full_dnode_slab;\n\noid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "his->node->raw)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",",
            "ef_offset(this->node->raw),",
            "his->node->ofs,",
            "his->node->ofs+this->node->size)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "his->node->raw)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}"
  },
  {
    "function_name": "ffs2_truncate_fragtree(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "59-99",
    "snippet": "int32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)\n{\n\tstruct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);\n\n\tdbg_fragtree(\"truncating fragtree to 0x%08x bytes\\n\", size);\n\n\t/* We know frag->ofs <= size. That's what lookup does for us */\n\tif (frag && frag->ofs != size) {\n\t\tif (frag->ofs+frag->size > size) {\n\t\t\tfrag->size = size - frag->ofs;\n\t\t}\n\t\tfrag = frag_next(frag);\n\t}\n\twhile (frag && frag->ofs >= size) {\n\t\tstruct jffs2_node_frag *next = frag_next(frag);\n\n\t\tfrag_erase(frag, list);\n\t\tjffs2_obsolete_node_frag(c, frag);\n\t\tfrag = next;\n\t}\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tfrag = frag_last(list);\n\n\t/* Sanity check for truncation to longer than we started with... */\n\tif (!frag)\n\t\treturn 0;\n\tif (frag->ofs + frag->size < size)\n\t\treturn frag->ofs + frag->size;\n\n\t/* If the last fragment starts at the RAM page boundary, it is\n\t * REF_PRISTINE irrespective of its size. */\n\tif (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {\n\t\tdbg_fragtree2(\"marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\\n\",\n\t\t\tfrag->ofs, frag->ofs + frag->size);\n\t\tfrag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;\n\t}\n\treturn size;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "rag->node->raw)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree2(",
          "args": [
            "marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\\n\",",
            "rag->ofs,",
            "rag->ofs + frag->size)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_last(",
          "args": [
            "ist)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "rag_last(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "333-341",
          "snippet": "tatic inline struct jffs2_node_frag *frag_last(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_last(root);\n\n\tif (!node)\n\t\treturn NULL;\n\n\treturn rb_entry(node, struct jffs2_node_frag, rb);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_node_frag *frag_last(struct rb_root *root)\n{\n\tstruct rb_node *node = rb_last(root);\n\n\tif (!node)\n\t\treturn NULL;\n\n\treturn rb_entry(node, struct jffs2_node_frag, rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_obsolete_node_frag(",
          "args": [
            ",",
            "rag)"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_obsolete_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "101-120",
          "snippet": "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this);\n\ntatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_node_frag *this)\n{\n\tif (this->node) {\n\t\tthis->node->frags--;\n\t\tif (!this->node->frags) {\n\t\t\t/* The node has no valid frags left. It's totally obsoleted */\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) obsolete\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\n\t\t\tjffs2_mark_node_obsolete(c, this->node->raw);\n\t\t\tjffs2_free_full_dnode(this->node);\n\t\t} else {\n\t\t\tdbg_fragtree2(\"marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\\n\",\n\t\t\t\tref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\n\t\t\tmark_ref_normal(this->node->raw);\n\t\t}\n\n\t}\n\tjffs2_free_node_frag(this);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rag_erase(",
          "args": [
            "rag,",
            "ist)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_next(",
          "args": [
            "rag)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rag_next(",
          "args": [
            "rag)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_fragtree(",
          "args": [
            "truncating fragtree to 0x%08x bytes\\n\",",
            "ize)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_lookup_node_frag(",
          "args": [
            "ist,",
            "ize)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_lookup_node_frag(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "524-561",
          "snippet": "truct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\n{\n\t/* The common case in lookup is that there will be a node\n\t   which precisely matches. So we go looking for that first */\n\tstruct rb_node *next;\n\tstruct jffs2_node_frag *prev = NULL;\n\tstruct jffs2_node_frag *frag = NULL;\n\n\tdbg_fragtree2(\"root %p, offset %d\\n\", fragtree, offset);\n\n\tnext = fragtree->rb_node;\n\n\twhile(next) {\n\t\tfrag = rb_entry(next, struct jffs2_node_frag, rb);\n\n\t\tif (frag->ofs + frag->size <= offset) {\n\t\t\t/* Remember the closest smaller match on the way down */\n\t\t\tif (!prev || frag->ofs > prev->ofs)\n\t\t\t\tprev = frag;\n\t\t\tnext = frag->rb.rb_right;\n\t\t} else if (frag->ofs > offset) {\n\t\t\tnext = frag->rb.rb_left;\n\t\t} else {\n\t\t\treturn frag;\n\t\t}\n\t}\n\n\t/* Exact match not found. Go back up looking at each parent,\n\t   and return the closest smaller one */\n\n\tif (prev)\n\t\tdbg_fragtree2(\"no match. Returning frag %#04x-%#04x, closest previous\\n\",\n\t\t\t  prev->ofs, prev->ofs+prev->size);\n\telse\n\t\tdbg_fragtree2(\"returning NULL, empty fragtree\\n\");\n\n\treturn prev;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)\n{\n\tstruct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);\n\n\tdbg_fragtree(\"truncating fragtree to 0x%08x bytes\\n\", size);\n\n\t/* We know frag->ofs <= size. That's what lookup does for us */\n\tif (frag && frag->ofs != size) {\n\t\tif (frag->ofs+frag->size > size) {\n\t\t\tfrag->size = size - frag->ofs;\n\t\t}\n\t\tfrag = frag_next(frag);\n\t}\n\twhile (frag && frag->ofs >= size) {\n\t\tstruct jffs2_node_frag *next = frag_next(frag);\n\n\t\tfrag_erase(frag, list);\n\t\tjffs2_obsolete_node_frag(c, frag);\n\t\tfrag = next;\n\t}\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tfrag = frag_last(list);\n\n\t/* Sanity check for truncation to longer than we started with... */\n\tif (!frag)\n\t\treturn 0;\n\tif (frag->ofs + frag->size < size)\n\t\treturn frag->ofs + frag->size;\n\n\t/* If the last fragment starts at the RAM page boundary, it is\n\t * REF_PRISTINE irrespective of its size. */\n\tif (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {\n\t\tdbg_fragtree2(\"marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\\n\",\n\t\t\tfrag->ofs, frag->ofs + frag->size);\n\t\tfrag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;\n\t}\n\treturn size;\n}"
  },
  {
    "function_name": "ffs2_add_fd_to_list(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
    "lines": "26-57",
    "snippet": "oid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/rbtree.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_full_dirent(",
          "args": [
            "prev)"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "130-134",
          "snippet": "oid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "(*prev)->raw))"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_dentlist(",
          "args": [
            "marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",",
            "*prev)->name,",
            "*prev)->ino)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_dentlist(",
          "args": [
            "Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",",
            "*prev)->name,",
            "*prev)->ino)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "*prev)->name,",
            "ew->name)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_dentlist(",
          "args": [
            "add dirent \\\"%s\\\", ino #%u\\n\",",
            "ew->name,",
            "ew->ino)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}"
  }
]