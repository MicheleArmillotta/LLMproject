[
  {
    "function_name": "f2fs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1226-1237",
    "snippet": "static sector_t f2fs_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\tint err = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn generic_block_bmap(mapping, block, get_data_block);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "get_data_block"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic sector_t f2fs_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\tint err = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn generic_block_bmap(mapping, block, get_data_block);\n}"
  },
  {
    "function_name": "f2fs_set_data_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1202-1224",
    "snippet": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\n\tSetPageUptodate(page);\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tregister_inmem_page(inode, page);\n\t\treturn 1;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tupdate_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dirty_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "update_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "693-721",
          "snippet": "void update_dirty_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new;\n\tint ret = 0;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tinode_inc_dirty_pages(inode);\n\t\tgoto out;\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tinode_inc_dirty_pages(inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\nout:\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid update_dirty_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new;\n\tint ret = 0;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tinode_inc_dirty_pages(inode);\n\t\tgoto out;\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tinode_inc_dirty_pages(inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\nout:\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_inmem_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "register_inmem_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "178-208",
          "snippet": "void register_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *new;\n\tint err;\n\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n\n\tnew = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);\n\n\t/* add atomic page indices to the list */\n\tnew->page = page;\n\tINIT_LIST_HEAD(&new->list);\nretry:\n\t/* increase reference count with clean state */\n\tmutex_lock(&fi->inmem_lock);\n\terr = radix_tree_insert(&fi->inmem_root, page->index, new);\n\tif (err == -EEXIST) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tkmem_cache_free(inmem_entry_slab, new);\n\t\treturn;\n\t} else if (err) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tgoto retry;\n\t}\n\tget_page(page);\n\tlist_add_tail(&new->list, &fi->inmem_pages);\n\tinc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\tmutex_unlock(&fi->inmem_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid register_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *new;\n\tint err;\n\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n\n\tnew = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);\n\n\t/* add atomic page indices to the list */\n\tnew->page = page;\n\tINIT_LIST_HEAD(&new->list);\nretry:\n\t/* increase reference count with clean state */\n\tmutex_lock(&fi->inmem_lock);\n\terr = radix_tree_insert(&fi->inmem_root, page->index, new);\n\tif (err == -EEXIST) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tkmem_cache_free(inmem_entry_slab, new);\n\t\treturn;\n\t} else if (err) {\n\t\tmutex_unlock(&fi->inmem_lock);\n\t\tgoto retry;\n\t}\n\tget_page(page);\n\tlist_add_tail(&new->list, &fi->inmem_pages);\n\tinc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\tmutex_unlock(&fi->inmem_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_set_page_dirty",
          "args": [
            "page",
            "DATA"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\n\tSetPageUptodate(page);\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tregister_inmem_page(inode, page);\n\t\treturn 1;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tupdate_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1192-1200",
    "snippet": "int f2fs_release_page(struct page *page, gfp_t wait)\n{\n\t/* If this is dirty page, keep PagePrivate */\n\tif (PageDirty(page))\n\t\treturn 0;\n\n\tClearPagePrivate(page);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_release_page(struct page *page, gfp_t wait)\n{\n\t/* If this is dirty page, keep PagePrivate */\n\tif (PageDirty(page))\n\t\treturn 0;\n\n\tClearPagePrivate(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "f2fs_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1171-1190",
    "snippet": "void f2fs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t\t\t\tunsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino >= F2FS_ROOT_INO(sbi) &&\n\t\t(offset % PAGE_CACHE_SIZE || length != PAGE_CACHE_SIZE))\n\t\treturn;\n\n\tif (PageDirty(page)) {\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\tdec_page_count(sbi, F2FS_DIRTY_META);\n\t\telse if (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\telse\n\t\t\tinode_dec_dirty_pages(inode);\n\t}\n\tClearPagePrivate(page);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "sbi",
            "F2FS_DIRTY_NODES"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_ROOT_INO",
          "args": [
            "sbi"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t\t\t\tunsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino >= F2FS_ROOT_INO(sbi) &&\n\t\t(offset % PAGE_CACHE_SIZE || length != PAGE_CACHE_SIZE))\n\t\treturn;\n\n\tif (PageDirty(page)) {\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\tdec_page_count(sbi, F2FS_DIRTY_META);\n\t\telse if (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\telse\n\t\t\tinode_dec_dirty_pages(inode);\n\t}\n\tClearPagePrivate(page);\n}"
  },
  {
    "function_name": "f2fs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1138-1169",
    "snippet": "static ssize_t f2fs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tint err;\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\terr = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (check_direct_IO(inode, rw, iter, offset))\n\t\treturn 0;\n\n\ttrace_f2fs_direct_IO_enter(inode, offset, count, rw);\n\n\tif (rw & WRITE)\n\t\t__allocate_data_blocks(inode, offset, count);\n\n\terr = blockdev_direct_IO(rw, iocb, inode, iter, offset, get_data_block);\n\tif (err < 0 && (rw & WRITE))\n\t\tf2fs_write_failed(mapping, offset + count);\n\n\ttrace_f2fs_direct_IO_exit(inode, offset, count, rw, err);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_direct_IO_exit",
          "args": [
            "inode",
            "offset",
            "count",
            "rw",
            "err"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_write_failed",
          "args": [
            "mapping",
            "offset + count"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "975-983",
          "snippet": "static void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "get_data_block"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__allocate_data_blocks",
          "args": [
            "inode",
            "offset",
            "count"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "__allocate_data_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "595-643",
          "snippet": "static void __allocate_data_blocks(struct inode *inode, loff_t offset,\n\t\t\t\t\t\t\tsize_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tu64 start = F2FS_BYTES_TO_BLK(offset);\n\tu64 len = F2FS_BYTES_TO_BLK(count);\n\tbool allocated;\n\tu64 end_offset;\n\n\twhile (len) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\n\t\t/* When reading holes, we need its node page */\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tif (get_dnode_of_data(&dn, start, ALLOC_NODE))\n\t\t\tgoto out;\n\n\t\tallocated = false;\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\twhile (dn.ofs_in_node < end_offset && len) {\n\t\t\tif (dn.data_blkaddr == NULL_ADDR) {\n\t\t\t\tif (__allocate_data_block(&dn))\n\t\t\t\t\tgoto sync_out;\n\t\t\t\tallocated = true;\n\t\t\t}\n\t\t\tlen--;\n\t\t\tstart++;\n\t\t\tdn.ofs_in_node++;\n\t\t}\n\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\n\t\tf2fs_put_dnode(&dn);\n\t\tf2fs_unlock_op(sbi);\n\t}\n\treturn;\n\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __allocate_data_blocks(struct inode *inode, loff_t offset,\n\t\t\t\t\t\t\tsize_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tu64 start = F2FS_BYTES_TO_BLK(offset);\n\tu64 len = F2FS_BYTES_TO_BLK(count);\n\tbool allocated;\n\tu64 end_offset;\n\n\twhile (len) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\n\t\t/* When reading holes, we need its node page */\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tif (get_dnode_of_data(&dn, start, ALLOC_NODE))\n\t\t\tgoto out;\n\n\t\tallocated = false;\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\twhile (dn.ofs_in_node < end_offset && len) {\n\t\t\tif (dn.data_blkaddr == NULL_ADDR) {\n\t\t\t\tif (__allocate_data_block(&dn))\n\t\t\t\t\tgoto sync_out;\n\t\t\t\tallocated = true;\n\t\t\t}\n\t\t\tlen--;\n\t\t\tstart++;\n\t\t\tdn.ofs_in_node++;\n\t\t}\n\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\n\t\tf2fs_put_dnode(&dn);\n\t\tf2fs_unlock_op(sbi);\n\t}\n\treturn;\n\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_direct_IO_enter",
          "args": [
            "inode",
            "offset",
            "count",
            "rw"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_direct_IO",
          "args": [
            "inode",
            "rw",
            "iter",
            "offset"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "check_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "1121-1136",
          "snippet": "static int check_direct_IO(struct inode *inode, int rw,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tunsigned blocksize_mask = inode->i_sb->s_blocksize - 1;\n\n\tif (rw == READ)\n\t\treturn 0;\n\n\tif (offset & blocksize_mask)\n\t\treturn -EINVAL;\n\n\tif (iov_iter_alignment(iter) & blocksize_mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_direct_IO(struct inode *inode, int rw,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tunsigned blocksize_mask = inode->i_sb->s_blocksize - 1;\n\n\tif (rw == READ)\n\t\treturn 0;\n\n\tif (offset & blocksize_mask)\n\t\treturn -EINVAL;\n\n\tif (iov_iter_alignment(iter) & blocksize_mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic ssize_t f2fs_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tint err;\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\terr = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (check_direct_IO(inode, rw, iter, offset))\n\t\treturn 0;\n\n\ttrace_f2fs_direct_IO_enter(inode, offset, count, rw);\n\n\tif (rw & WRITE)\n\t\t__allocate_data_blocks(inode, offset, count);\n\n\terr = blockdev_direct_IO(rw, iocb, inode, iter, offset, get_data_block);\n\tif (err < 0 && (rw & WRITE))\n\t\tf2fs_write_failed(mapping, offset + count);\n\n\ttrace_f2fs_direct_IO_exit(inode, offset, count, rw, err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "check_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1121-1136",
    "snippet": "static int check_direct_IO(struct inode *inode, int rw,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tunsigned blocksize_mask = inode->i_sb->s_blocksize - 1;\n\n\tif (rw == READ)\n\t\treturn 0;\n\n\tif (offset & blocksize_mask)\n\t\treturn -EINVAL;\n\n\tif (iov_iter_alignment(iter) & blocksize_mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_alignment",
          "args": [
            "iter"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_direct_IO(struct inode *inode, int rw,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tunsigned blocksize_mask = inode->i_sb->s_blocksize - 1;\n\n\tif (rw == READ)\n\t\treturn 0;\n\n\tif (offset & blocksize_mask)\n\t\treturn -EINVAL;\n\n\tif (iov_iter_alignment(iter) & blocksize_mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "1100-1119",
    "snippet": "static int f2fs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_f2fs_write_end(inode, pos, len, copied);\n\n\tset_page_dirty(page);\n\n\tif (pos + copied > i_size_read(inode)) {\n\t\ti_size_write(inode, pos + copied);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\n\tf2fs_put_page(page, 1);\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_f2fs_write_end(inode, pos, len, copied);\n\n\tset_page_dirty(page);\n\n\tif (pos + copied > i_size_read(inode)) {\n\t\ti_size_write(inode, pos + copied);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\n\tf2fs_put_page(page, 1);\n\treturn copied;\n}"
  },
  {
    "function_name": "f2fs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "985-1098",
    "snippet": "static int f2fs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page, *ipage;\n\tpgoff_t index = ((unsigned long long) pos) >> PAGE_CACHE_SHIFT;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\ttrace_f2fs_write_begin(inode, pos, len, flags);\n\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * We should check this at this moment to avoid deadlock on inode page\n\t * and #0 page. The locking rule for inline_data conversion should be:\n\t * lock_page(page #0) -> lock_page(inode_page)\n\t */\n\tif (index != 0) {\n\t\terr = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\nrepeat:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t*pagep = page;\n\n\tf2fs_lock_op(sbi);\n\n\t/* check inline_data */\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto unlock_fail;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tif (pos + len <= MAX_INLINE_DATA) {\n\t\t\tread_inline_data(page, ipage);\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tsync_inode_page(&dn);\n\t\t\tgoto put_next;\n\t\t}\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\t\tif (err)\n\t\t\tgoto put_fail;\n\t}\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\tgoto put_fail;\nput_next:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\n\n\tif ((len == PAGE_CACHE_SIZE) || PageUptodate(page))\n\t\treturn 0;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif ((pos & PAGE_CACHE_MASK) >= i_size_read(inode)) {\n\t\tunsigned start = pos & (PAGE_CACHE_SIZE - 1);\n\t\tunsigned end = start + len;\n\n\t\t/* Reading beyond i_size is simple: memset to zero */\n\t\tzero_user_segments(page, 0, start, end, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(sbi, page, &fio);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\tSetPageUptodate(page);\n\tclear_cold_data(page);\n\treturn 0;\n\nput_fail:\n\tf2fs_put_dnode(&dn);\nunlock_fail:\n\tf2fs_unlock_op(sbi);\n\tf2fs_put_page(page, 1);\nfail:\n\tf2fs_write_failed(mapping, pos + len);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "975-983",
          "snippet": "static void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_cold_data",
          "args": [
            "page"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "clear_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "377-380",
          "snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "sbi",
            "page",
            "&fio"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "0",
            "start",
            "end",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "&dn",
            "index"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_page",
          "args": [
            "&dn",
            "page"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "85-141",
          "snippet": "int f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DATA_EXIST"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_inline_data",
          "args": [
            "page",
            "ipage"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "59-83",
          "snippet": "int f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "ipage",
            "ipage",
            "0"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_write_begin",
          "args": [
            "inode",
            "pos",
            "len",
            "flags"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page, *ipage;\n\tpgoff_t index = ((unsigned long long) pos) >> PAGE_CACHE_SHIFT;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\ttrace_f2fs_write_begin(inode, pos, len, flags);\n\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * We should check this at this moment to avoid deadlock on inode page\n\t * and #0 page. The locking rule for inline_data conversion should be:\n\t * lock_page(page #0) -> lock_page(inode_page)\n\t */\n\tif (index != 0) {\n\t\terr = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\nrepeat:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t*pagep = page;\n\n\tf2fs_lock_op(sbi);\n\n\t/* check inline_data */\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto unlock_fail;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tif (pos + len <= MAX_INLINE_DATA) {\n\t\t\tread_inline_data(page, ipage);\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tsync_inode_page(&dn);\n\t\t\tgoto put_next;\n\t\t}\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\t\tif (err)\n\t\t\tgoto put_fail;\n\t}\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\tgoto put_fail;\nput_next:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\n\n\tif ((len == PAGE_CACHE_SIZE) || PageUptodate(page))\n\t\treturn 0;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif ((pos & PAGE_CACHE_MASK) >= i_size_read(inode)) {\n\t\tunsigned start = pos & (PAGE_CACHE_SIZE - 1);\n\t\tunsigned end = start + len;\n\n\t\t/* Reading beyond i_size is simple: memset to zero */\n\t\tzero_user_segments(page, 0, start, end, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(sbi, page, &fio);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\tSetPageUptodate(page);\n\tclear_cold_data(page);\n\treturn 0;\n\nput_fail:\n\tf2fs_put_dnode(&dn);\nunlock_fail:\n\tf2fs_unlock_op(sbi);\n\tf2fs_put_page(page, 1);\nfail:\n\tf2fs_write_failed(mapping, pos + len);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "975-983",
    "snippet": "static void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_blocks",
          "args": [
            "inode",
            "inode->i_size",
            "true"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "482-540",
          "snippet": "int truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void f2fs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\ttruncate_blocks(inode, inode->i_size, true);\n\t}\n}"
  },
  {
    "function_name": "f2fs_write_data_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "933-973",
    "snippet": "static int f2fs_write_data_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool locked = false;\n\tint ret;\n\tlong diff;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, DATA);\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tif (S_ISDIR(inode->i_mode) && wbc->sync_mode == WB_SYNC_NONE &&\n\t\t\tget_dirty_pages(inode) < nr_pages_to_skip(sbi, DATA) &&\n\t\t\tavailable_free_memory(sbi, DIRTY_DENTS))\n\t\tgoto skip_write;\n\n\tdiff = nr_pages_to_write(sbi, DATA, wbc);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmutex_lock(&sbi->writepages);\n\t\tlocked = true;\n\t}\n\tret = write_cache_pages(mapping, wbc, __f2fs_writepage, mapping);\n\tif (locked)\n\t\tmutex_unlock(&sbi->writepages);\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\tremove_dirty_dir_inode(inode);\n\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn ret;\n\nskip_write:\n\twbc->pages_skipped += get_dirty_pages(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "892-895",
          "snippet": "static inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(long)0",
            "wbc->nr_to_write - diff"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "168-180",
          "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dirty_dir_inode",
          "args": [
            "inode"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dirty_dir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "741-769",
          "snippet": "void remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "DATA",
            "WRITE"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->writepages"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "__f2fs_writepage",
            "mapping"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->writepages"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_pages_to_write",
          "args": [
            "sbi",
            "DATA",
            "wbc"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "731-750",
          "snippet": "static inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "DIRTY_DENTS"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_pages_to_skip",
          "args": [
            "sbi",
            "DATA"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "713-726",
          "snippet": "static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepages",
          "args": [
            "mapping->host",
            "wbc",
            "DATA"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_data_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool locked = false;\n\tint ret;\n\tlong diff;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, DATA);\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tif (S_ISDIR(inode->i_mode) && wbc->sync_mode == WB_SYNC_NONE &&\n\t\t\tget_dirty_pages(inode) < nr_pages_to_skip(sbi, DATA) &&\n\t\t\tavailable_free_memory(sbi, DIRTY_DENTS))\n\t\tgoto skip_write;\n\n\tdiff = nr_pages_to_write(sbi, DATA, wbc);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmutex_lock(&sbi->writepages);\n\t\tlocked = true;\n\t}\n\tret = write_cache_pages(mapping, wbc, __f2fs_writepage, mapping);\n\tif (locked)\n\t\tmutex_unlock(&sbi->writepages);\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\tremove_dirty_dir_inode(inode);\n\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn ret;\n\nskip_write:\n\twbc->pages_skipped += get_dirty_pages(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "__f2fs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "924-931",
    "snippet": "static int __f2fs_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\tvoid *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __f2fs_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\tvoid *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "f2fs_write_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "840-922",
    "snippet": "static int f2fs_write_data_page(struct page *page,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = ((unsigned long long) i_size)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\tunsigned offset = 0;\n\tbool need_balance_fs = false;\n\tint err = 0;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE,\n\t};\n\n\ttrace_f2fs_writepage(page, DATA);\n\n\tif (page->index < end_index)\n\t\tgoto write;\n\n\t/*\n\t * If the offset is out-of-range of file size,\n\t * this page does not have to be written to disk.\n\t */\n\toffset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif ((page->index >= end_index + 1) || !offset)\n\t\tgoto out;\n\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nwrite:\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (f2fs_is_drop_cache(inode))\n\t\tgoto out;\n\tif (f2fs_is_volatile_file(inode) && !wbc->for_reclaim &&\n\t\t\tavailable_free_memory(sbi, BASE_CHECK))\n\t\tgoto redirty_out;\n\n\t/* Dentry blocks are controlled by checkpoint */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\tgoto redirty_out;\n\t\terr = do_write_data_page(page, &fio);\n\t\tgoto done;\n\t}\n\n\t/* we should bypass data pages to proceed the kworkder jobs */\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tSetPageError(page);\n\t\tgoto out;\n\t}\n\n\tif (!wbc->for_reclaim)\n\t\tneed_balance_fs = true;\n\telse if (has_not_enough_free_secs(sbi, 0))\n\t\tgoto redirty_out;\n\n\terr = -EAGAIN;\n\tf2fs_lock_op(sbi);\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_write_inline_data(inode, page);\n\tif (err == -EAGAIN)\n\t\terr = do_write_data_page(page, &fio);\n\tf2fs_unlock_op(sbi);\ndone:\n\tif (err && err != -ENOENT)\n\t\tgoto redirty_out;\n\n\tclear_cold_data(page);\nout:\n\tinode_dec_dirty_pages(inode);\n\tunlock_page(page);\n\tif (need_balance_fs)\n\t\tf2fs_balance_fs(sbi);\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "DATA",
            "WRITE"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_cold_data",
          "args": [
            "page"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "clear_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "377-380",
          "snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_write_data_page",
          "args": [
            "page",
            "&fio"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "802-838",
          "snippet": "int do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_write_inline_data",
          "args": [
            "inode",
            "page"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "175-205",
          "snippet": "int f2fs_write_inline_data(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EAGAIN;\n\t}\n\n\tf2fs_bug_on(F2FS_I_SB(inode), page->index);\n\n\tf2fs_wait_on_page_writeback(dn.inode_page, NODE);\n\tsrc_addr = kmap_atomic(page);\n\tdst_addr = inline_data_addr(dn.inode_page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tkunmap_atomic(src_addr);\n\n\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_write_inline_data(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EAGAIN;\n\t}\n\n\tf2fs_bug_on(F2FS_I_SB(inode), page->index);\n\n\tf2fs_wait_on_page_writeback(dn.inode_page, NODE);\n\tsrc_addr = kmap_atomic(page);\n\tdst_addr = inline_data_addr(dn.inode_page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tkunmap_atomic(src_addr);\n\n\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "0"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "BASE_CHECK"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_drop_cache",
          "args": [
            "inode"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_drop_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1277-1280",
          "snippet": "static inline bool f2fs_is_drop_cache(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DROP_CACHE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_drop_cache(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DROP_CACHE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_sbi_flag_set(sbi, SBI_POR_DOING)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepage",
          "args": [
            "page",
            "DATA"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_data_page(struct page *page,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = ((unsigned long long) i_size)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\tunsigned offset = 0;\n\tbool need_balance_fs = false;\n\tint err = 0;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE,\n\t};\n\n\ttrace_f2fs_writepage(page, DATA);\n\n\tif (page->index < end_index)\n\t\tgoto write;\n\n\t/*\n\t * If the offset is out-of-range of file size,\n\t * this page does not have to be written to disk.\n\t */\n\toffset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif ((page->index >= end_index + 1) || !offset)\n\t\tgoto out;\n\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nwrite:\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (f2fs_is_drop_cache(inode))\n\t\tgoto out;\n\tif (f2fs_is_volatile_file(inode) && !wbc->for_reclaim &&\n\t\t\tavailable_free_memory(sbi, BASE_CHECK))\n\t\tgoto redirty_out;\n\n\t/* Dentry blocks are controlled by checkpoint */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\tgoto redirty_out;\n\t\terr = do_write_data_page(page, &fio);\n\t\tgoto done;\n\t}\n\n\t/* we should bypass data pages to proceed the kworkder jobs */\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tSetPageError(page);\n\t\tgoto out;\n\t}\n\n\tif (!wbc->for_reclaim)\n\t\tneed_balance_fs = true;\n\telse if (has_not_enough_free_secs(sbi, 0))\n\t\tgoto redirty_out;\n\n\terr = -EAGAIN;\n\tf2fs_lock_op(sbi);\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_write_inline_data(inode, page);\n\tif (err == -EAGAIN)\n\t\terr = do_write_data_page(page, &fio);\n\tf2fs_unlock_op(sbi);\ndone:\n\tif (err && err != -ENOENT)\n\t\tgoto redirty_out;\n\n\tclear_cold_data(page);\nout:\n\tinode_dec_dirty_pages(inode);\n\tunlock_page(page);\n\tif (need_balance_fs)\n\t\tf2fs_balance_fs(sbi);\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}"
  },
  {
    "function_name": "do_write_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "802-838",
    "snippet": "int do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_APPEND_WRITE"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_extent_cache",
          "args": [
            "&dn"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "294-373",
          "snippet": "void update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_data_page",
          "args": [
            "page",
            "&dn",
            "fio"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "write_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1234-1246",
          "snippet": "void write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rewrite_data_page",
          "args": [
            "page",
            "fio"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "rewrite_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1248-1252",
          "snippet": "void rewrite_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstat_inc_inplace_blocks(F2FS_P_SB(page));\n\tf2fs_submit_page_mbio(F2FS_P_SB(page), page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid rewrite_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstat_inc_inplace_blocks(F2FS_P_SB(page));\n\tf2fs_submit_page_mbio(F2FS_P_SB(page), page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_inplace_update",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "need_inplace_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "507-533",
          "snippet": "static inline bool need_inplace_update(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int policy = SM_I(sbi)->ipu_policy;\n\n\t/* IPU can be done only for the user data */\n\tif (S_ISDIR(inode->i_mode) || f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (policy & (0x1 << F2FS_IPU_FORCE))\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_SSR) && need_SSR(sbi))\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_UTIL) &&\n\t\t\tutilization(sbi) > SM_I(sbi)->min_ipu_util)\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_SSR_UTIL) && need_SSR(sbi) &&\n\t\t\tutilization(sbi) > SM_I(sbi)->min_ipu_util)\n\t\treturn true;\n\n\t/* this is only set during fdatasync */\n\tif (policy & (0x1 << F2FS_IPU_FSYNC) &&\n\t\t\tis_inode_flag_set(F2FS_I(inode), FI_NEED_IPU))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool need_inplace_update(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int policy = SM_I(sbi)->ipu_policy;\n\n\t/* IPU can be done only for the user data */\n\tif (S_ISDIR(inode->i_mode) || f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (policy & (0x1 << F2FS_IPU_FORCE))\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_SSR) && need_SSR(sbi))\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_UTIL) &&\n\t\t\tutilization(sbi) > SM_I(sbi)->min_ipu_util)\n\t\treturn true;\n\tif (policy & (0x1 << F2FS_IPU_SSR_UTIL) && need_SSR(sbi) &&\n\t\t\tutilization(sbi) > SM_I(sbi)->min_ipu_util)\n\t\treturn true;\n\n\t/* this is only set during fdatasync */\n\tif (policy & (0x1 << F2FS_IPU_FSYNC) &&\n\t\t\tis_inode_flag_set(F2FS_I(inode), FI_NEED_IPU))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cold_data",
          "args": [
            "page"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "is_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "367-370",
          "snippet": "static inline int is_cold_data(struct page *page)\n{\n\treturn PageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int is_cold_data(struct page *page)\n{\n\treturn PageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "page->index",
            "LOOKUP_NODE"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_read_data_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "789-800",
    "snippet": "static int f2fs_read_data_pages(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\t/* If the file has inline data, skip readpages */\n\tif (f2fs_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn mpage_readpages(mapping, pages, nr_pages, get_data_block);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "get_data_block"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_read_data_pages(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\t/* If the file has inline data, skip readpages */\n\tif (f2fs_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn mpage_readpages(mapping, pages, nr_pages, get_data_block);\n}"
  },
  {
    "function_name": "f2fs_read_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "773-787",
    "snippet": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\t/* If the file has inline data, try to read it directly */\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = mpage_readpage(page, get_data_block);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "get_data_block"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_read_inline_data",
          "args": [
            "inode",
            "page"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "59-83",
          "snippet": "int f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_readpage",
          "args": [
            "page",
            "DATA"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\t/* If the file has inline data, try to read it directly */\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = mpage_readpage(page, get_data_block);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "f2fs_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "766-771",
    "snippet": "int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo,\n\t\t\t\tstart, len, get_data_block_fiemap);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_fiemap",
          "args": [
            "inode",
            "fieinfo",
            "start",
            "len",
            "get_data_block_fiemap"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "409-418",
          "snippet": "int generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tmutex_lock(&inode->i_mutex);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\treturn generic_block_fiemap(inode, fieinfo,\n\t\t\t\tstart, len, get_data_block_fiemap);\n}"
  },
  {
    "function_name": "get_data_block_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "760-764",
    "snippet": "static int get_data_block_fiemap(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn __get_data_block(inode, iblock, bh_result, create, true);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_data_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "create",
            "true"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "653-752",
          "snippet": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_data_block_fiemap(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn __get_data_block(inode, iblock, bh_result, create, true);\n}"
  },
  {
    "function_name": "get_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "754-758",
    "snippet": "static int get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn __get_data_block(inode, iblock, bh_result, create, false);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_data_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "create",
            "false"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "653-752",
          "snippet": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn __get_data_block(inode, iblock, bh_result, create, false);\n}"
  },
  {
    "function_name": "__get_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "653-752",
    "snippet": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_get_data_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "err"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__allocate_data_block",
          "args": [
            "&dn"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__allocate_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "561-593",
          "snippet": "static int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablock_addr",
          "args": [
            "dn.node_page",
            "dn.ofs_in_node"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "datablock_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1098-1106",
          "snippet": "static inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "dn.node_page",
            "F2FS_I(inode)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "pgofs",
            "mode"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "dn.node_page",
            "F2FS_I(inode)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "dn.data_blkaddr"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "dn.data_blkaddr"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_extent_cache",
          "args": [
            "inode",
            "pgofs",
            "bh_result"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "check_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "251-292",
          "snippet": "static int check_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct buffer_head *bh_result)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tpgoff_t start_fofs, end_fofs;\n\tblock_t start_blkaddr;\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn 0;\n\n\tread_lock(&fi->ext.ext_lock);\n\tif (fi->ext.len == 0) {\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 0;\n\t}\n\n\tstat_inc_total_hit(inode->i_sb);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\n\tif (pgofs >= start_fofs && pgofs <= end_fofs) {\n\t\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\t\tsize_t count;\n\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\tstart_blkaddr + pgofs - start_fofs);\n\t\tcount = end_fofs - pgofs + 1;\n\t\tif (count < (UINT_MAX >> blkbits))\n\t\t\tbh_result->b_size = (count << blkbits);\n\t\telse\n\t\t\tbh_result->b_size = UINT_MAX;\n\n\t\tstat_inc_read_hit(inode->i_sb);\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&fi->ext.ext_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct buffer_head *bh_result)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tpgoff_t start_fofs, end_fofs;\n\tblock_t start_blkaddr;\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn 0;\n\n\tread_lock(&fi->ext.ext_lock);\n\tif (fi->ext.len == 0) {\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 0;\n\t}\n\n\tstat_inc_total_hit(inode->i_sb);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\n\tif (pgofs >= start_fofs && pgofs <= end_fofs) {\n\t\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\t\tsize_t count;\n\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\tstart_blkaddr + pgofs - start_fofs);\n\t\tcount = end_fofs - pgofs + 1;\n\t\tif (count < (UINT_MAX >> blkbits))\n\t\t\tbh_result->b_size = (count << blkbits);\n\t\telse\n\t\t\tbh_result->b_size = UINT_MAX;\n\n\t\tstat_inc_read_hit(inode->i_sb);\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&fi->ext.ext_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "iblock >> (PAGE_CACHE_SHIFT - blkbits)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create, bool fiemap)\n{\n\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\tunsigned maxblocks = bh_result->b_size >> blkbits;\n\tstruct dnode_of_data dn;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA;\n\tpgoff_t pgofs, end_offset;\n\tint err = 0, ofs = 1;\n\tbool allocated = false;\n\n\t/* Get the page offset from the block offset(iblock) */\n\tpgofs =\t(pgoff_t)(iblock >> (PAGE_CACHE_SHIFT - blkbits));\n\n\tif (check_extent_cache(inode, pgofs, bh_result))\n\t\tgoto out;\n\n\tif (create)\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\n\t/* When reading holes, we need its node page */\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto unlock_out;\n\t}\n\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\tgoto put_out;\n\n\tif (dn.data_blkaddr != NULL_ADDR) {\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else if (create) {\n\t\terr = __allocate_data_block(&dn);\n\t\tif (err)\n\t\t\tgoto put_out;\n\t\tallocated = true;\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, dn.data_blkaddr);\n\t} else {\n\t\tgoto put_out;\n\t}\n\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\tbh_result->b_size = (((size_t)1) << blkbits);\n\tdn.ofs_in_node++;\n\tpgofs++;\n\nget_next:\n\tif (dn.ofs_in_node >= end_offset) {\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\t\tallocated = false;\n\t\tf2fs_put_dnode(&dn);\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, mode);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = 0;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (dn.data_blkaddr == NEW_ADDR && !fiemap)\n\t\t\tgoto put_out;\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\t}\n\n\tif (maxblocks > (bh_result->b_size >> blkbits)) {\n\t\tblock_t blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR && create) {\n\t\t\terr = __allocate_data_block(&dn);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tallocated = true;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t}\n\t\t/* Give more consecutive addresses for the readahead */\n\t\tif (blkaddr == (bh_result->b_blocknr + ofs)) {\n\t\t\tofs++;\n\t\t\tdn.ofs_in_node++;\n\t\t\tpgofs++;\n\t\t\tbh_result->b_size += (((size_t)1) << blkbits);\n\t\t\tgoto get_next;\n\t\t}\n\t}\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\nput_out:\n\tf2fs_put_dnode(&dn);\nunlock_out:\n\tif (create)\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\nout:\n\ttrace_f2fs_get_data_block(inode, iblock, bh_result, err);\n\treturn err;\n}"
  },
  {
    "function_name": "__allocate_data_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "595-643",
    "snippet": "static void __allocate_data_blocks(struct inode *inode, loff_t offset,\n\t\t\t\t\t\t\tsize_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tu64 start = F2FS_BYTES_TO_BLK(offset);\n\tu64 len = F2FS_BYTES_TO_BLK(count);\n\tbool allocated;\n\tu64 end_offset;\n\n\twhile (len) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\n\t\t/* When reading holes, we need its node page */\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tif (get_dnode_of_data(&dn, start, ALLOC_NODE))\n\t\t\tgoto out;\n\n\t\tallocated = false;\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\twhile (dn.ofs_in_node < end_offset && len) {\n\t\t\tif (dn.data_blkaddr == NULL_ADDR) {\n\t\t\t\tif (__allocate_data_block(&dn))\n\t\t\t\t\tgoto sync_out;\n\t\t\t\tallocated = true;\n\t\t\t}\n\t\t\tlen--;\n\t\t\tstart++;\n\t\t\tdn.ofs_in_node++;\n\t\t}\n\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\n\t\tf2fs_put_dnode(&dn);\n\t\tf2fs_unlock_op(sbi);\n\t}\n\treturn;\n\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__allocate_data_block",
          "args": [
            "&dn"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__allocate_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "561-593",
          "snippet": "static int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "dn.node_page",
            "F2FS_I(inode)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "start",
            "ALLOC_NODE"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "count"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "offset"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __allocate_data_blocks(struct inode *inode, loff_t offset,\n\t\t\t\t\t\t\tsize_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tu64 start = F2FS_BYTES_TO_BLK(offset);\n\tu64 len = F2FS_BYTES_TO_BLK(count);\n\tbool allocated;\n\tu64 end_offset;\n\n\twhile (len) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\n\t\t/* When reading holes, we need its node page */\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tif (get_dnode_of_data(&dn, start, ALLOC_NODE))\n\t\t\tgoto out;\n\n\t\tallocated = false;\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\twhile (dn.ofs_in_node < end_offset && len) {\n\t\t\tif (dn.data_blkaddr == NULL_ADDR) {\n\t\t\t\tif (__allocate_data_block(&dn))\n\t\t\t\t\tgoto sync_out;\n\t\t\t\tallocated = true;\n\t\t\t}\n\t\t\tlen--;\n\t\t\tstart++;\n\t\t\tdn.ofs_in_node++;\n\t\t}\n\n\t\tif (allocated)\n\t\t\tsync_inode_page(&dn);\n\n\t\tf2fs_put_dnode(&dn);\n\t\tf2fs_unlock_op(sbi);\n\t}\n\treturn;\n\nsync_out:\n\tif (allocated)\n\t\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\treturn;\n}"
  },
  {
    "function_name": "__allocate_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "561-593",
    "snippet": "static int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dn->inode",
            "((fofs + 1) << PAGE_CACHE_SHIFT)"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dn->inode"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_bidx_of_node",
          "args": [
            "ofs_of_node(dn->node_page)",
            "fi"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "start_bidx_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "470-488",
          "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofs_of_node",
          "args": [
            "dn->node_page"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ofs_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "259-264",
          "snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_data_blkaddr",
          "args": [
            "dn"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__set_data_blkaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "200-215",
          "snippet": "static void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_data_block",
          "args": [
            "sbi",
            "NULL",
            "NULL_ADDR",
            "&dn->data_blkaddr",
            "&sum",
            "seg"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1154-1200",
          "snippet": "void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tbool direct_io = (type == CURSEG_DIRECT_IO);\n\n\ttype = direct_io ? CURSEG_WARM_DATA : type;\n\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* direct_io'ed data is aligned to the segment for better performance */\n\tif (direct_io && curseg->next_blkoff)\n\t\t__allocate_new_segments(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\tmutex_lock(&sit_i->sentry_lock);\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\trefresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type))\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_summary",
          "args": [
            "&sum",
            "dn->nid",
            "dn->ofs_in_node",
            "ni.version"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "set_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "671-677",
          "snippet": "static inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "dn->nid",
            "&ni"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inc_valid_block_count(sbi, dn->inode, 1)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_valid_block_count",
          "args": [
            "sbi",
            "dn->inode",
            "1"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "827-844",
          "snippet": "static inline bool inc_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t struct inode *inode, blkcnt_t count)\n{\n\tblock_t\tvalid_block_count;\n\n\tspin_lock(&sbi->stat_lock);\n\tvalid_block_count =\n\t\tsbi->total_valid_block_count + (block_t)count;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\tinode->i_blocks += count;\n\tsbi->total_valid_block_count = valid_block_count;\n\tsbi->alloc_valid_block_count += (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool inc_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t struct inode *inode, blkcnt_t count)\n{\n\tblock_t\tvalid_block_count;\n\n\tspin_lock(&sbi->stat_lock);\n\tvalid_block_count =\n\t\tsbi->total_valid_block_count + (block_t)count;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\tinode->i_blocks += count;\n\tsbi->total_valid_block_count = valid_block_count;\n\tsbi->alloc_valid_block_count += (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dn->inode)",
            "FI_NO_ALLOC"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int __allocate_data_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint seg = CURSEG_WARM_DATA;\n\tpgoff_t fofs;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\n\tif (dn->ofs_in_node == 0 && dn->inode_page == dn->node_page)\n\t\tseg = CURSEG_DIRECT_IO;\n\n\tallocate_data_block(sbi, NULL, NULL_ADDR, &dn->data_blkaddr, &sum, seg);\n\n\t/* direct IO doesn't use extent cache to maximize the performance */\n\t__set_data_blkaddr(dn);\n\n\t/* update i_size */\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\tif (i_size_read(dn->inode) < ((fofs + 1) << PAGE_CACHE_SHIFT))\n\t\ti_size_write(dn->inode, ((fofs + 1) << PAGE_CACHE_SHIFT));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_new_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "501-559",
    "snippet": "struct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_UPDATE_DIR"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "((index + 1) << PAGE_CACHE_SHIFT)"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "F2FS_I_SB(inode)",
            "page",
            "&fio"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "&dn",
            "index"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "ipage",
            "NULL",
            "0"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "get_lock_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "433-491",
    "snippet": "struct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "F2FS_I_SB(inode)",
            "page",
            "&fio"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dn.data_blkaddr == NULL_ADDR"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "index",
            "LOOKUP_NODE"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "find_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "375-426",
    "snippet": "struct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "F2FS_I_SB(inode)",
            "page",
            "&fio"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dn.data_blkaddr == NEW_ADDR"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "index",
            "LOOKUP_NODE"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "update_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "294-373",
    "snippet": "void update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&fi->ext.ext_lock"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "fi",
            "FI_NO_EXTENT"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&fi->ext.ext_lock"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_bidx_of_node",
          "args": [
            "ofs_of_node(dn->node_page)",
            "fi"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "start_bidx_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "470-488",
          "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofs_of_node",
          "args": [
            "dn->node_page"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ofs_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "259-264",
          "snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "fi",
            "FI_NO_EXTENT"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_data_blkaddr",
          "args": [
            "dn"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__set_data_blkaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "200-215",
          "snippet": "static void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(dn->inode)",
            "dn->data_blkaddr == NEW_ADDR"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}"
  },
  {
    "function_name": "check_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "251-292",
    "snippet": "static int check_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct buffer_head *bh_result)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tpgoff_t start_fofs, end_fofs;\n\tblock_t start_blkaddr;\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn 0;\n\n\tread_lock(&fi->ext.ext_lock);\n\tif (fi->ext.len == 0) {\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 0;\n\t}\n\n\tstat_inc_total_hit(inode->i_sb);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\n\tif (pgofs >= start_fofs && pgofs <= end_fofs) {\n\t\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\t\tsize_t count;\n\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\tstart_blkaddr + pgofs - start_fofs);\n\t\tcount = end_fofs - pgofs + 1;\n\t\tif (count < (UINT_MAX >> blkbits))\n\t\t\tbh_result->b_size = (count << blkbits);\n\t\telse\n\t\t\tbh_result->b_size = UINT_MAX;\n\n\t\tstat_inc_read_hit(inode->i_sb);\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&fi->ext.ext_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&fi->ext.ext_lock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_read_hit",
          "args": [
            "inode->i_sb"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "start_blkaddr + pgofs - start_fofs"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_inc_total_hit",
          "args": [
            "inode->i_sb"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&fi->ext.ext_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "fi",
            "FI_NO_EXTENT"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct buffer_head *bh_result)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tpgoff_t start_fofs, end_fofs;\n\tblock_t start_blkaddr;\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn 0;\n\n\tread_lock(&fi->ext.ext_lock);\n\tif (fi->ext.len == 0) {\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 0;\n\t}\n\n\tstat_inc_total_hit(inode->i_sb);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\n\tif (pgofs >= start_fofs && pgofs <= end_fofs) {\n\t\tunsigned int blkbits = inode->i_sb->s_blocksize_bits;\n\t\tsize_t count;\n\n\t\tset_buffer_new(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\tstart_blkaddr + pgofs - start_fofs);\n\t\tcount = end_fofs - pgofs + 1;\n\t\tif (count < (UINT_MAX >> blkbits))\n\t\t\tbh_result->b_size = (count << blkbits);\n\t\telse\n\t\t\tbh_result->b_size = UINT_MAX;\n\n\t\tstat_inc_read_hit(inode->i_sb);\n\t\tread_unlock(&fi->ext.ext_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&fi->ext.ext_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_reserve_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "235-249",
    "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "dn"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_new_block",
          "args": [
            "dn"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "217-233",
          "snippet": "int reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "dn",
            "index",
            "ALLOC_NODE"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
  },
  {
    "function_name": "reserve_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "217-233",
    "snippet": "int reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dn->inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_data_blkaddr",
          "args": [
            "dn"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__set_data_blkaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "200-215",
          "snippet": "static void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_reserve_new_block",
          "args": [
            "dn->inode",
            "dn->nid",
            "dn->ofs_in_node"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inc_valid_block_count(sbi, dn->inode, 1)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_valid_block_count",
          "args": [
            "sbi",
            "dn->inode",
            "1"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "827-844",
          "snippet": "static inline bool inc_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t struct inode *inode, blkcnt_t count)\n{\n\tblock_t\tvalid_block_count;\n\n\tspin_lock(&sbi->stat_lock);\n\tvalid_block_count =\n\t\tsbi->total_valid_block_count + (block_t)count;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\tinode->i_blocks += count;\n\tsbi->total_valid_block_count = valid_block_count;\n\tsbi->alloc_valid_block_count += (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool inc_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t struct inode *inode, blkcnt_t count)\n{\n\tblock_t\tvalid_block_count;\n\n\tspin_lock(&sbi->stat_lock);\n\tvalid_block_count =\n\t\tsbi->total_valid_block_count + (block_t)count;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\tinode->i_blocks += count;\n\tsbi->total_valid_block_count = valid_block_count;\n\tsbi->alloc_valid_block_count += (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dn->inode)",
            "FI_NO_ALLOC"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_data_blkaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "200-215",
    "snippet": "static void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "node_page"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dn->data_blkaddr"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkaddr_in_node",
          "args": [
            "rn"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "blkaddr_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1093-1096",
          "snippet": "static inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_NODE",
          "args": [
            "node_page"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "670-673",
          "snippet": "static inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "node_page",
            "NODE"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn;\n\t__le32 *addr_array;\n\tstruct page *node_page = dn->node_page;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\trn = F2FS_NODE(node_page);\n\n\t/* Get physical address of data block */\n\taddr_array = blkaddr_in_node(rn);\n\taddr_array[ofs_in_node] = cpu_to_le32(dn->data_blkaddr);\n\tset_page_dirty(node_page);\n}"
  },
  {
    "function_name": "f2fs_submit_page_mbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "154-192",
    "snippet": "void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_submit_page_mbio",
          "args": [
            "page",
            "fio"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_trace_ios",
          "args": [
            "page",
            "fio",
            "0"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "83-118",
          "snippet": "void f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct last_io_info last_io;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct last_io_info last_io;\n\nvoid f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__submit_merged_bio",
          "args": [
            "io"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "__submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "91-105",
          "snippet": "static void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "io->bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bio_alloc",
          "args": [
            "sbi",
            "fio->blk_addr",
            "bio_blocks",
            "is_read"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "75-89",
          "snippet": "static struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_BIO_BLOCKS",
          "args": [
            "sbi"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_page_count",
          "args": [
            "sbi",
            "F2FS_WRITEBACK"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "inc_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "858-862",
          "snippet": "static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_block_addr",
          "args": [
            "sbi",
            "fio->blk_addr"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "verify_block_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "606-610",
          "snippet": "static inline void verify_block_addr(struct f2fs_sb_info *sbi, block_t blk_addr)\n{\n\tif (blk_addr < SEG0_BLKADDR(sbi) || blk_addr >= MAX_BLKADDR(sbi))\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void verify_block_addr(struct f2fs_sb_info *sbi, block_t blk_addr)\n{\n\tif (blk_addr < SEG0_BLKADDR(sbi) || blk_addr >= MAX_BLKADDR(sbi))\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_read_io",
          "args": [
            "fio->rw"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_TYPE_OF_BIO",
          "args": [
            "fio->type"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}"
  },
  {
    "function_name": "f2fs_submit_page_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "133-152",
    "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "fio->rw",
            "bio"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bio_alloc",
          "args": [
            "sbi",
            "fio->blk_addr",
            "1",
            "is_read_io(fio->rw)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "75-89",
          "snippet": "static struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_read_io",
          "args": [
            "fio->rw"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_trace_ios",
          "args": [
            "page",
            "fio",
            "0"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "83-118",
          "snippet": "void f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct last_io_info last_io;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct last_io_info last_io;\n\nvoid f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_submit_page_bio",
          "args": [
            "page",
            "fio"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_submit_merged_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "107-127",
    "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__submit_merged_bio",
          "args": [
            "io"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "91-105",
          "snippet": "static void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOBARRIER"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&io->io_rwsem"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_read_io",
          "args": [
            "rw"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_TYPE_OF_BIO",
          "args": [
            "type"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
  },
  {
    "function_name": "__submit_merged_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "91-105",
    "snippet": "static void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "fio->rw",
            "io->bio"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_submit_write_bio",
          "args": [
            "io->sbi->sb",
            "fio",
            "io->bio"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_submit_read_bio",
          "args": [
            "io->sbi->sb",
            "fio",
            "io->bio"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_read_io",
          "args": [
            "fio->rw"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __submit_merged_bio(struct f2fs_bio_info *io)\n{\n\tstruct f2fs_io_info *fio = &io->fio;\n\n\tif (!io->bio)\n\t\treturn;\n\n\tif (is_read_io(fio->rw))\n\t\ttrace_f2fs_submit_read_bio(io->sbi->sb, fio, io->bio);\n\telse\n\t\ttrace_f2fs_submit_write_bio(io->sbi->sb, fio, io->bio);\n\n\tsubmit_bio(fio->rw, io->bio);\n\tio->bio = NULL;\n}"
  },
  {
    "function_name": "__bio_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "75-89",
    "snippet": "static struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SECTOR_FROM_BLOCK",
          "args": [
            "blk_addr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "npages"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,\n\t\t\t\tint npages, bool is_read)\n{\n\tstruct bio *bio;\n\n\t/* No failure on bio allocation */\n\tbio = bio_alloc(GFP_NOIO, npages);\n\n\tbio->bi_bdev = sbi->sb->s_bdev;\n\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);\n\tbio->bi_end_io = is_read ? f2fs_read_end_io : f2fs_write_end_io;\n\tbio->bi_private = sbi;\n\n\treturn bio;\n}"
  },
  {
    "function_name": "f2fs_write_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "47-70",
    "snippet": "static void f2fs_write_end_io(struct bio *bio, int err)\n{\n\tstruct f2fs_sb_info *sbi = bio->bi_private;\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (unlikely(err)) {\n\t\t\tset_page_dirty(page);\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\tend_page_writeback(page);\n\t\tdec_page_count(sbi, F2FS_WRITEBACK);\n\t}\n\n\tif (!get_pages(sbi, F2FS_WRITEBACK) &&\n\t\t\t!list_empty(&sbi->cp_wait.task_list))\n\t\twake_up(&sbi->cp_wait);\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sbi->cp_wait"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sbi->cp_wait.task_list"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_WRITEBACK"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "sbi",
            "F2FS_WRITEBACK"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_stop_checkpoint",
          "args": [
            "sbi"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_stop_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1315-1319",
          "snippet": "static inline void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\tsbi->sb->s_flags |= MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\tsbi->sb->s_flags |= MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&page->mapping->flags"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void f2fs_write_end_io(struct bio *bio, int err)\n{\n\tstruct f2fs_sb_info *sbi = bio->bi_private;\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (unlikely(err)) {\n\t\t\tset_page_dirty(page);\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\tend_page_writeback(page);\n\t\tdec_page_count(sbi, F2FS_WRITEBACK);\n\t}\n\n\tif (!get_pages(sbi, F2FS_WRITEBACK) &&\n\t\t\t!list_empty(&sbi->cp_wait.task_list))\n\t\twake_up(&sbi->cp_wait);\n\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "f2fs_read_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
    "lines": "28-45",
    "snippet": "static void f2fs_read_end_io(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (!err) {\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tbio_put(bio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void f2fs_read_end_io(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (!err) {\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tbio_put(bio);\n}"
  }
]