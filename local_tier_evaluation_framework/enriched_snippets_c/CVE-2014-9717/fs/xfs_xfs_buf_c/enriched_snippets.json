[
  {
    "function_name": "xfs_buf_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1897-1901",
    "snippet": "void\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_buf_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_destroy",
          "args": [
            "xfs_buf_zone"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "110-115",
          "snippet": "static inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_terminate(void)\n{\n\tkmem_zone_destroy(xfs_buf_zone);\n}"
  },
  {
    "function_name": "xfs_buf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1883-1895",
    "snippet": "int __init\nxfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\treturn 0;\n\n out:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_buf_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_init_flags",
          "args": [
            "sizeof(xfs_buf_t)",
            "\"xfs_buf\"",
            "KM_ZONE_HWALIGN",
            "NULL"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_init_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "97-102",
          "snippet": "static inline kmem_zone_t *\nkmem_zone_init_flags(int size, char *zone_name, unsigned long flags,\n\t\t     void (*construct)(void *))\n{\n\treturn kmem_cache_create(zone_name, size, 0, flags, construct);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline kmem_zone_t *\nkmem_zone_init_flags(int size, char *zone_name, unsigned long flags,\n\t\t     void (*construct)(void *))\n{\n\treturn kmem_cache_create(zone_name, size, 0, flags, construct);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nint __init\nxfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\treturn 0;\n\n out:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xfs_buf_delwri_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1856-1881",
    "snippet": "int\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_list"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&io_list",
            "structxfs_buf",
            "b_list"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&io_list"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_buf_delwri_submit",
          "args": [
            "buffer_list",
            "&io_list",
            "true"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_buf_delwri_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1769-1829",
          "snippet": "static int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "io_list"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_buf_delwri_submit_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1840-1846",
    "snippet": "int\nxfs_buf_delwri_submit_nowait(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\treturn __xfs_buf_delwri_submit(buffer_list, &io_list, false);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_buf_delwri_submit",
          "args": [
            "buffer_list",
            "&io_list",
            "false"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_buf_delwri_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1769-1829",
          "snippet": "static int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "io_list"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit_nowait(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\treturn __xfs_buf_delwri_submit(buffer_list, &io_list, false);\n}"
  },
  {
    "function_name": "__xfs_buf_delwri_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1769-1829",
    "snippet": "static int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit",
          "args": [
            "bp"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_list"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bp",
            "n",
            "io_list",
            "b_list"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_sort",
          "args": [
            "NULL",
            "io_list",
            "xfs_buf_cmp"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_delwri_split",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&bp->b_list",
            "io_list"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_list"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_trylock",
          "args": [
            "bp"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "934-946",
          "snippet": "int\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ispinned",
          "args": [
            "bp"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ispinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "356-359",
          "snippet": "static inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bp",
            "n",
            "buffer_list",
            "b_list"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\n__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC | XBF_WRITE_FAIL);\n\t\tbp->b_flags |= XBF_WRITE | XBF_ASYNC;\n\n\t\t/*\n\t\t * we do all Io submission async. This means if we need to wait\n\t\t * for IO completion we need to take an extra reference so the\n\t\t * buffer is still valid on the other side.\n\t\t */\n\t\tif (wait)\n\t\t\txfs_buf_hold(bp);\n\t\telse\n\t\t\tlist_del_init(&bp->b_list);\n\n\t\txfs_buf_submit(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}"
  },
  {
    "function_name": "xfs_buf_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1751-1767",
    "snippet": "static int\nxfs_buf_cmp(\n\tvoid\t\t*priv,\n\tstruct list_head *a,\n\tstruct list_head *b)\n{\n\tstruct xfs_buf\t*ap = container_of(a, struct xfs_buf, b_list);\n\tstruct xfs_buf\t*bp = container_of(b, struct xfs_buf, b_list);\n\txfs_daddr_t\t\tdiff;\n\n\tdiff = ap->b_maps[0].bm_bn - bp->b_maps[0].bm_bn;\n\tif (diff < 0)\n\t\treturn -1;\n\tif (diff > 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structxfs_buf",
            "b_list"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structxfs_buf",
            "b_list"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\nxfs_buf_cmp(\n\tvoid\t\t*priv,\n\tstruct list_head *a,\n\tstruct list_head *b)\n{\n\tstruct xfs_buf\t*ap = container_of(a, struct xfs_buf, b_list);\n\tstruct xfs_buf\t*bp = container_of(b, struct xfs_buf, b_list);\n\txfs_daddr_t\t\tdiff;\n\n\tdiff = ap->b_maps[0].bm_bn - bp->b_maps[0].bm_bn;\n\tif (diff < 0)\n\t\treturn -1;\n\tif (diff > 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_buf_delwri_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1709-1744",
    "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bp->b_list",
            "list"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bp->b_hold"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bp->b_list"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_delwri_queue",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_delwri_queued",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bp->b_flags & XBF_READ)"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_alloc_buftarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1666-1696",
    "snippet": "xfs_buftarg_t *\nxfs_alloc_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct block_device\t*bdev)\n{\n\txfs_buftarg_t\t\t*btp;\n\n\tbtp = kmem_zalloc(sizeof(*btp), KM_SLEEP | KM_NOFS);\n\n\tbtp->bt_mount = mp;\n\tbtp->bt_dev =  bdev->bd_dev;\n\tbtp->bt_bdev = bdev;\n\tbtp->bt_bdi = blk_get_backing_dev_info(bdev);\n\n\tif (xfs_setsize_buftarg_early(btp, bdev))\n\t\tgoto error;\n\n\tif (list_lru_init(&btp->bt_lru))\n\t\tgoto error;\n\n\tbtp->bt_shrinker.count_objects = xfs_buftarg_shrink_count;\n\tbtp->bt_shrinker.scan_objects = xfs_buftarg_shrink_scan;\n\tbtp->bt_shrinker.seeks = DEFAULT_SEEKS;\n\tbtp->bt_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&btp->bt_shrinker);\n\treturn btp;\n\nerror:\n\tkmem_free(btp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "btp"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&btp->bt_shrinker"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_init",
          "args": [
            "&btp->bt_lru"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_setsize_buftarg_early",
          "args": [
            "btp",
            "bdev"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setsize_buftarg_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1658-1664",
          "snippet": "STATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_get_backing_dev_info",
          "args": [
            "bdev"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*btp)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buftarg_t *\nxfs_alloc_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct block_device\t*bdev)\n{\n\txfs_buftarg_t\t\t*btp;\n\n\tbtp = kmem_zalloc(sizeof(*btp), KM_SLEEP | KM_NOFS);\n\n\tbtp->bt_mount = mp;\n\tbtp->bt_dev =  bdev->bd_dev;\n\tbtp->bt_bdev = bdev;\n\tbtp->bt_bdi = blk_get_backing_dev_info(bdev);\n\n\tif (xfs_setsize_buftarg_early(btp, bdev))\n\t\tgoto error;\n\n\tif (list_lru_init(&btp->bt_lru))\n\t\tgoto error;\n\n\tbtp->bt_shrinker.count_objects = xfs_buftarg_shrink_count;\n\tbtp->bt_shrinker.scan_objects = xfs_buftarg_shrink_scan;\n\tbtp->bt_shrinker.seeks = DEFAULT_SEEKS;\n\tbtp->bt_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&btp->bt_shrinker);\n\treturn btp;\n\nerror:\n\tkmem_free(btp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_setsize_buftarg_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1658-1664",
    "snippet": "STATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setsize_buftarg",
          "args": [
            "btp",
            "bdev_logical_block_size(bdev)"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setsize_buftarg_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1658-1664",
          "snippet": "STATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_setsize_buftarg_early(\n\txfs_buftarg_t\t\t*btp,\n\tstruct block_device\t*bdev)\n{\n\treturn xfs_setsize_buftarg(btp, bdev_logical_block_size(bdev));\n}"
  },
  {
    "function_name": "xfs_setsize_buftarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1626-1651",
    "snippet": "int\nxfs_setsize_buftarg(\n\txfs_buftarg_t\t\t*btp,\n\tunsigned int\t\tsectorsize)\n{\n\t/* Set up metadata sector size info */\n\tbtp->bt_meta_sectorsize = sectorsize;\n\tbtp->bt_meta_sectormask = sectorsize - 1;\n\n\tif (set_blocksize(btp->bt_bdev, sectorsize)) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tbdevname(btp->bt_bdev, name);\n\n\t\txfs_warn(btp->bt_mount,\n\t\t\t\"Cannot set_blocksize to %u on device %s\",\n\t\t\tsectorsize, name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set up device logical sector size mask */\n\tbtp->bt_logical_sectorsize = bdev_logical_block_size(btp->bt_bdev);\n\tbtp->bt_logical_sectormask = bdev_logical_block_size(btp->bt_bdev) - 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "btp->bt_bdev"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "btp->bt_bdev"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "btp->bt_mount",
            "\"Cannot set_blocksize to %u on device %s\"",
            "sectorsize",
            "name"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "btp->bt_bdev",
            "name"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "btp->bt_bdev",
            "sectorsize"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_setsize_buftarg(\n\txfs_buftarg_t\t\t*btp,\n\tunsigned int\t\tsectorsize)\n{\n\t/* Set up metadata sector size info */\n\tbtp->bt_meta_sectorsize = sectorsize;\n\tbtp->bt_meta_sectormask = sectorsize - 1;\n\n\tif (set_blocksize(btp->bt_bdev, sectorsize)) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tbdevname(btp->bt_bdev, name);\n\n\t\txfs_warn(btp->bt_mount,\n\t\t\t\"Cannot set_blocksize to %u on device %s\",\n\t\t\tsectorsize, name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set up device logical sector size mask */\n\tbtp->bt_logical_sectorsize = bdev_logical_block_size(btp->bt_bdev);\n\tbtp->bt_logical_sectormask = bdev_logical_block_size(btp->bt_bdev) - 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_free_buftarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1612-1624",
    "snippet": "void\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "btp"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_blkdev_issue_flush",
          "args": [
            "btp"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_issue_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "702-707",
          "snippet": "void\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&btp->bt_lru"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&btp->bt_shrinker"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_free_buftarg(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buftarg\t*btp)\n{\n\tunregister_shrinker(&btp->bt_shrinker);\n\tlist_lru_destroy(&btp->bt_lru);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER)\n\t\txfs_blkdev_issue_flush(btp);\n\n\tkmem_free(btp);\n}"
  },
  {
    "function_name": "xfs_buftarg_shrink_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1602-1610",
    "snippet": "static unsigned long\nxfs_buftarg_shrink_count(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_buftarg\t*btp = container_of(shrink,\n\t\t\t\t\tstruct xfs_buftarg, bt_shrinker);\n\treturn list_lru_shrink_count(&btp->bt_lru, sc);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&btp->bt_lru",
            "sc"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structxfs_buftarg",
            "bt_shrinker"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic unsigned long\nxfs_buftarg_shrink_count(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_buftarg\t*btp = container_of(shrink,\n\t\t\t\t\tstruct xfs_buftarg, bt_shrinker);\n\treturn list_lru_shrink_count(&btp->bt_lru, sc);\n}"
  },
  {
    "function_name": "xfs_buftarg_shrink_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1579-1600",
    "snippet": "static unsigned long\nxfs_buftarg_shrink_scan(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_buftarg\t*btp = container_of(shrink,\n\t\t\t\t\tstruct xfs_buftarg, bt_shrinker);\n\tLIST_HEAD(dispose);\n\tunsigned long\t\tfreed;\n\n\tfreed = list_lru_shrink_walk(&btp->bt_lru, sc,\n\t\t\t\t     xfs_buftarg_isolate, &dispose);\n\n\twhile (!list_empty(&dispose)) {\n\t\tstruct xfs_buf *bp;\n\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\tlist_del_init(&bp->b_lru);\n\t\txfs_buf_rele(bp);\n\t}\n\n\treturn freed;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_lru"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dispose",
            "structxfs_buf",
            "b_lru"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dispose"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&btp->bt_lru",
            "sc",
            "xfs_buftarg_isolate",
            "&dispose"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structxfs_buftarg",
            "bt_shrinker"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic unsigned long\nxfs_buftarg_shrink_scan(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_buftarg\t*btp = container_of(shrink,\n\t\t\t\t\tstruct xfs_buftarg, bt_shrinker);\n\tLIST_HEAD(dispose);\n\tunsigned long\t\tfreed;\n\n\tfreed = list_lru_shrink_walk(&btp->bt_lru, sc,\n\t\t\t\t     xfs_buftarg_isolate, &dispose);\n\n\twhile (!list_empty(&dispose)) {\n\t\tstruct xfs_buf *bp;\n\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\tlist_del_init(&bp->b_lru);\n\t\txfs_buf_rele(bp);\n\t}\n\n\treturn freed;\n}"
  },
  {
    "function_name": "xfs_buftarg_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1547-1577",
    "snippet": "static enum lru_status\nxfs_buftarg_isolate(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n{\n\tstruct xfs_buf\t\t*bp = container_of(item, struct xfs_buf, b_lru);\n\tstruct list_head\t*dispose = arg;\n\n\t/*\n\t * we are inverting the lru lock/bp->b_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&bp->b_lock))\n\t\treturn LRU_SKIP;\n\t/*\n\t * Decrement the b_lru_ref count unless the value is already\n\t * zero. If the value is already zero, we need to reclaim the\n\t * buffer, otherwise it gets another trip through the LRU.\n\t */\n\tif (!atomic_add_unless(&bp->b_lru_ref, -1, 0)) {\n\t\tspin_unlock(&bp->b_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tbp->b_state |= XFS_BSTATE_DISPOSE;\n\tlist_lru_isolate_move(lru, item, dispose);\n\tspin_unlock(&bp->b_lock);\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "item",
            "dispose"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&bp->b_lru_ref",
            "-1",
            "0"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structxfs_buf",
            "b_lru"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic enum lru_status\nxfs_buftarg_isolate(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n{\n\tstruct xfs_buf\t\t*bp = container_of(item, struct xfs_buf, b_lru);\n\tstruct list_head\t*dispose = arg;\n\n\t/*\n\t * we are inverting the lru lock/bp->b_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&bp->b_lock))\n\t\treturn LRU_SKIP;\n\t/*\n\t * Decrement the b_lru_ref count unless the value is already\n\t * zero. If the value is already zero, we need to reclaim the\n\t * buffer, otherwise it gets another trip through the LRU.\n\t */\n\tif (!atomic_add_unless(&bp->b_lru_ref, -1, 0)) {\n\t\tspin_unlock(&bp->b_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tbp->b_state |= XFS_BSTATE_DISPOSE;\n\tlist_lru_isolate_move(lru, item, dispose);\n\tspin_unlock(&bp->b_lock);\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "xfs_wait_buftarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1518-1545",
    "snippet": "void\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "btp->bt_mount",
            "\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\"",
            "(long long)bp->b_bn"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_lru"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&dispose",
            "structxfs_buf",
            "b_lru"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dispose"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_walk",
          "args": [
            "&btp->bt_lru",
            "xfs_buftarg_wait_rele",
            "&dispose",
            "LONG_MAX"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_count",
          "args": [
            "&btp->bt_lru"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_wait_buftarg(\n\tstruct xfs_buftarg\t*btp)\n{\n\tLIST_HEAD(dispose);\n\tint loop = 0;\n\n\t/* loop until there is nothing left on the lru list. */\n\twhile (list_lru_count(&btp->bt_lru)) {\n\t\tlist_lru_walk(&btp->bt_lru, xfs_buftarg_wait_rele,\n\t\t\t      &dispose, LONG_MAX);\n\n\t\twhile (!list_empty(&dispose)) {\n\t\t\tstruct xfs_buf *bp;\n\t\t\tbp = list_first_entry(&dispose, struct xfs_buf, b_lru);\n\t\t\tlist_del_init(&bp->b_lru);\n\t\t\tif (bp->b_flags & XBF_WRITE_FAIL) {\n\t\t\t\txfs_alert(btp->bt_mount,\n\"Corruption Alert: Buffer at block 0x%llx had permanent write failures!\\n\"\n\"Please run xfs_repair to determine the extent of the problem.\",\n\t\t\t\t\t(long long)bp->b_bn);\n\t\t\t}\n\t\t\txfs_buf_rele(bp);\n\t\t}\n\t\tif (loop++ != 0)\n\t\t\tdelay(100);\n\t}\n}"
  },
  {
    "function_name": "xfs_buftarg_wait_rele",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1488-1516",
    "snippet": "static enum lru_status\nxfs_buftarg_wait_rele(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n\n{\n\tstruct xfs_buf\t\t*bp = container_of(item, struct xfs_buf, b_lru);\n\tstruct list_head\t*dispose = arg;\n\n\tif (atomic_read(&bp->b_hold) > 1) {\n\t\t/* need to wait, so skip it this pass */\n\t\ttrace_xfs_buf_wait_buftarg(bp, _RET_IP_);\n\t\treturn LRU_SKIP;\n\t}\n\tif (!spin_trylock(&bp->b_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * clear the LRU reference count so the buffer doesn't get\n\t * ignored in xfs_buf_rele().\n\t */\n\tatomic_set(&bp->b_lru_ref, 0);\n\tbp->b_state |= XFS_BSTATE_DISPOSE;\n\tlist_lru_isolate_move(lru, item, dispose);\n\tspin_unlock(&bp->b_lock);\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "item",
            "dispose"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_lru_ref",
            "0"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_wait_buftarg",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_hold"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structxfs_buf",
            "b_lru"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic enum lru_status\nxfs_buftarg_wait_rele(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n\n{\n\tstruct xfs_buf\t\t*bp = container_of(item, struct xfs_buf, b_lru);\n\tstruct list_head\t*dispose = arg;\n\n\tif (atomic_read(&bp->b_hold) > 1) {\n\t\t/* need to wait, so skip it this pass */\n\t\ttrace_xfs_buf_wait_buftarg(bp, _RET_IP_);\n\t\treturn LRU_SKIP;\n\t}\n\tif (!spin_trylock(&bp->b_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * clear the LRU reference count so the buffer doesn't get\n\t * ignored in xfs_buf_rele().\n\t */\n\tatomic_set(&bp->b_lru_ref, 0);\n\tbp->b_state |= XFS_BSTATE_DISPOSE;\n\tlist_lru_isolate_move(lru, item, dispose);\n\tspin_unlock(&bp->b_lock);\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "xfs_buf_iomove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1440-1477",
    "snippet": "void\nxfs_buf_iomove(\n\txfs_buf_t\t\t*bp,\t/* buffer to process\t\t*/\n\tsize_t\t\t\tboff,\t/* starting buffer offset\t*/\n\tsize_t\t\t\tbsize,\t/* length to copy\t\t*/\n\tvoid\t\t\t*data,\t/* data address\t\t\t*/\n\txfs_buf_rw_t\t\tmode)\t/* read/write/zero flag\t\t*/\n{\n\tsize_t\t\t\tbend;\n\n\tbend = boff + bsize;\n\twhile (boff < bend) {\n\t\tstruct page\t*page;\n\t\tint\t\tpage_index, page_offset, csize;\n\n\t\tpage_index = (boff + bp->b_offset) >> PAGE_SHIFT;\n\t\tpage_offset = (boff + bp->b_offset) & ~PAGE_MASK;\n\t\tpage = bp->b_pages[page_index];\n\t\tcsize = min_t(size_t, PAGE_SIZE - page_offset,\n\t\t\t\t      BBTOB(bp->b_io_length) - boff);\n\n\t\tASSERT((csize + page_offset) <= PAGE_SIZE);\n\n\t\tswitch (mode) {\n\t\tcase XBRW_ZERO:\n\t\t\tmemset(page_address(page) + page_offset, 0, csize);\n\t\t\tbreak;\n\t\tcase XBRW_READ:\n\t\t\tmemcpy(data, page_address(page) + page_offset, csize);\n\t\t\tbreak;\n\t\tcase XBRW_WRITE:\n\t\t\tmemcpy(page_address(page) + page_offset, data, csize);\n\t\t}\n\n\t\tboff += csize;\n\t\tdata += csize;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page_address(page) + page_offset",
            "data",
            "csize"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "page_address(page) + page_offset",
            "csize"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page) + page_offset",
            "0",
            "csize"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(csize + page_offset) <= PAGE_SIZE"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - page_offset",
            "BBTOB(bp->b_io_length) - boff"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_iomove(\n\txfs_buf_t\t\t*bp,\t/* buffer to process\t\t*/\n\tsize_t\t\t\tboff,\t/* starting buffer offset\t*/\n\tsize_t\t\t\tbsize,\t/* length to copy\t\t*/\n\tvoid\t\t\t*data,\t/* data address\t\t\t*/\n\txfs_buf_rw_t\t\tmode)\t/* read/write/zero flag\t\t*/\n{\n\tsize_t\t\t\tbend;\n\n\tbend = boff + bsize;\n\twhile (boff < bend) {\n\t\tstruct page\t*page;\n\t\tint\t\tpage_index, page_offset, csize;\n\n\t\tpage_index = (boff + bp->b_offset) >> PAGE_SHIFT;\n\t\tpage_offset = (boff + bp->b_offset) & ~PAGE_MASK;\n\t\tpage = bp->b_pages[page_index];\n\t\tcsize = min_t(size_t, PAGE_SIZE - page_offset,\n\t\t\t\t      BBTOB(bp->b_io_length) - boff);\n\n\t\tASSERT((csize + page_offset) <= PAGE_SIZE);\n\n\t\tswitch (mode) {\n\t\tcase XBRW_ZERO:\n\t\t\tmemset(page_address(page) + page_offset, 0, csize);\n\t\t\tbreak;\n\t\tcase XBRW_READ:\n\t\t\tmemcpy(data, page_address(page) + page_offset, csize);\n\t\t\tbreak;\n\t\tcase XBRW_WRITE:\n\t\t\tmemcpy(page_address(page) + page_offset, data, csize);\n\t\t}\n\n\t\tboff += csize;\n\t\tdata += csize;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1422-1435",
    "snippet": "xfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_caddr_t\nxfs_buf_offset(\n\txfs_buf_t\t\t*bp,\n\tsize_t\t\t\toffset)\n{\n\tstruct page\t\t*page;\n\n\tif (bp->b_addr)\n\t\treturn bp->b_addr + offset;\n\n\toffset += bp->b_offset;\n\tpage = bp->b_pages[offset >> PAGE_SHIFT];\n\treturn (xfs_caddr_t)page_address(page) + (offset & (PAGE_SIZE-1));\n}"
  },
  {
    "function_name": "xfs_buf_submit_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1362-1420",
    "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_iowait_done",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&bp->b_iowait"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_iowait",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bp->b_io_remaining"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_ioapply",
          "args": [
            "bp"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_ioapply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1207-1293",
          "snippet": "STATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_io_remaining",
            "1"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_wait_unpin",
          "args": [
            "bp"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_wait_unpin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "981-999",
          "snippet": "STATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "bp->b_target->bt_mount"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC))"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_submit_wait",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_buf_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1301-1357",
    "snippet": "void\nxfs_buf_submit(\n\tstruct xfs_buf\t*bp)\n{\n\ttrace_xfs_buf_submit(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\tASSERT(bp->b_flags & XBF_ASYNC);\n\n\t/* on shutdown we stale and complete the buffer immediately */\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\treturn;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * The caller's reference is released during I/O completion.\n\t * This occurs some time after the last b_io_remaining reference is\n\t * released, so after we drop our Io reference we have to have some\n\t * other reference to ensure the buffer doesn't go away from underneath\n\t * us. Take a direct reference to ensure we have safe access to the\n\t * buffer until we are finished with it.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * If _xfs_buf_ioapply failed, we can get back here with only the IO\n\t * reference we took above. If we drop it to zero, run completion so\n\t * that we don't return to the caller with completion still pending.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1) {\n\t\tif (bp->b_error)\n\t\t\txfs_buf_ioend(bp);\n\t\telse\n\t\t\txfs_buf_ioend_async(bp);\n\t}\n\n\txfs_buf_rele(bp);\n\t/* Note: it is not safe to reference bp now we've dropped our ref */\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioend_async",
          "args": [
            "bp"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bp->b_io_remaining"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_ioapply",
          "args": [
            "bp"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_ioapply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1207-1293",
          "snippet": "STATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_io_remaining",
            "1"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_hold",
          "args": [
            "bp"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "854-860",
          "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_wait_unpin",
          "args": [
            "bp"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_wait_unpin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "981-999",
          "snippet": "STATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "bp->b_target->bt_mount"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_flags & XBF_ASYNC"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bp->b_flags & _XBF_DELWRI_Q)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_submit",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_submit(\n\tstruct xfs_buf\t*bp)\n{\n\ttrace_xfs_buf_submit(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\tASSERT(bp->b_flags & XBF_ASYNC);\n\n\t/* on shutdown we stale and complete the buffer immediately */\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\t\txfs_buf_ioend(bp);\n\t\treturn;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * The caller's reference is released during I/O completion.\n\t * This occurs some time after the last b_io_remaining reference is\n\t * released, so after we drop our Io reference we have to have some\n\t * other reference to ensure the buffer doesn't go away from underneath\n\t * us. Take a direct reference to ensure we have safe access to the\n\t * buffer until we are finished with it.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * If _xfs_buf_ioapply failed, we can get back here with only the IO\n\t * reference we took above. If we drop it to zero, run completion so\n\t * that we don't return to the caller with completion still pending.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1) {\n\t\tif (bp->b_error)\n\t\t\txfs_buf_ioend(bp);\n\t\telse\n\t\t\txfs_buf_ioend_async(bp);\n\t}\n\n\txfs_buf_rele(bp);\n\t/* Note: it is not safe to reference bp now we've dropped our ref */\n}"
  },
  {
    "function_name": "_xfs_buf_ioapply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1207-1293",
    "snippet": "STATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioapply_map",
          "args": [
            "bp",
            "i",
            "&offset",
            "&size",
            "rw"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioapply_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1123-1205",
          "snippet": "static void\nxfs_buf_ioapply_map(\n\tstruct xfs_buf\t*bp,\n\tint\t\tmap,\n\tint\t\t*buf_offset,\n\tint\t\t*count,\n\tint\t\trw)\n{\n\tint\t\tpage_index;\n\tint\t\ttotal_nr_pages = bp->b_page_count;\n\tint\t\tnr_pages;\n\tstruct bio\t*bio;\n\tsector_t\tsector =  bp->b_maps[map].bm_bn;\n\tint\t\tsize;\n\tint\t\toffset;\n\n\ttotal_nr_pages = bp->b_page_count;\n\n\t/* skip the pages in the buffer before the start offset */\n\tpage_index = 0;\n\toffset = *buf_offset;\n\twhile (offset >= PAGE_SIZE) {\n\t\tpage_index++;\n\t\toffset -= PAGE_SIZE;\n\t}\n\n\t/*\n\t * Limit the IO size to the length of the current vector, and update the\n\t * remaining IO count for the next time around.\n\t */\n\tsize = min_t(int, BBTOB(bp->b_maps[map].bm_len), *count);\n\t*count -= size;\n\t*buf_offset += size;\n\nnext_chunk:\n\tatomic_inc(&bp->b_io_remaining);\n\tnr_pages = BIO_MAX_SECTORS >> (PAGE_SHIFT - BBSHIFT);\n\tif (nr_pages > total_nr_pages)\n\t\tnr_pages = total_nr_pages;\n\n\tbio = bio_alloc(GFP_NOIO, nr_pages);\n\tbio->bi_bdev = bp->b_target->bt_bdev;\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_end_io = xfs_buf_bio_end_io;\n\tbio->bi_private = bp;\n\n\n\tfor (; size && nr_pages; nr_pages--, page_index++) {\n\t\tint\trbytes, nbytes = PAGE_SIZE - offset;\n\n\t\tif (nbytes > size)\n\t\t\tnbytes = size;\n\n\t\trbytes = bio_add_page(bio, bp->b_pages[page_index], nbytes,\n\t\t\t\t      offset);\n\t\tif (rbytes < nbytes)\n\t\t\tbreak;\n\n\t\toffset = 0;\n\t\tsector += BTOBB(nbytes);\n\t\tsize -= nbytes;\n\t\ttotal_nr_pages--;\n\t}\n\n\tif (likely(bio->bi_iter.bi_size)) {\n\t\tif (xfs_buf_is_vmapped(bp)) {\n\t\t\tflush_kernel_vmap_range(bp->b_addr,\n\t\t\t\t\t\txfs_buf_vmap_len(bp));\n\t\t}\n\t\tsubmit_bio(rw, bio);\n\t\tif (size)\n\t\t\tgoto next_chunk;\n\t} else {\n\t\t/*\n\t\t * This is guaranteed not to be the last io reference count\n\t\t * because the caller (xfs_buf_submit) holds a count itself.\n\t\t */\n\t\tatomic_dec(&bp->b_io_remaining);\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbio_put(bio);\n\t}\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_ioapply_map(\n\tstruct xfs_buf\t*bp,\n\tint\t\tmap,\n\tint\t\t*buf_offset,\n\tint\t\t*count,\n\tint\t\trw)\n{\n\tint\t\tpage_index;\n\tint\t\ttotal_nr_pages = bp->b_page_count;\n\tint\t\tnr_pages;\n\tstruct bio\t*bio;\n\tsector_t\tsector =  bp->b_maps[map].bm_bn;\n\tint\t\tsize;\n\tint\t\toffset;\n\n\ttotal_nr_pages = bp->b_page_count;\n\n\t/* skip the pages in the buffer before the start offset */\n\tpage_index = 0;\n\toffset = *buf_offset;\n\twhile (offset >= PAGE_SIZE) {\n\t\tpage_index++;\n\t\toffset -= PAGE_SIZE;\n\t}\n\n\t/*\n\t * Limit the IO size to the length of the current vector, and update the\n\t * remaining IO count for the next time around.\n\t */\n\tsize = min_t(int, BBTOB(bp->b_maps[map].bm_len), *count);\n\t*count -= size;\n\t*buf_offset += size;\n\nnext_chunk:\n\tatomic_inc(&bp->b_io_remaining);\n\tnr_pages = BIO_MAX_SECTORS >> (PAGE_SHIFT - BBSHIFT);\n\tif (nr_pages > total_nr_pages)\n\t\tnr_pages = total_nr_pages;\n\n\tbio = bio_alloc(GFP_NOIO, nr_pages);\n\tbio->bi_bdev = bp->b_target->bt_bdev;\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_end_io = xfs_buf_bio_end_io;\n\tbio->bi_private = bp;\n\n\n\tfor (; size && nr_pages; nr_pages--, page_index++) {\n\t\tint\trbytes, nbytes = PAGE_SIZE - offset;\n\n\t\tif (nbytes > size)\n\t\t\tnbytes = size;\n\n\t\trbytes = bio_add_page(bio, bp->b_pages[page_index], nbytes,\n\t\t\t\t      offset);\n\t\tif (rbytes < nbytes)\n\t\t\tbreak;\n\n\t\toffset = 0;\n\t\tsector += BTOBB(nbytes);\n\t\tsize -= nbytes;\n\t\ttotal_nr_pages--;\n\t}\n\n\tif (likely(bio->bi_iter.bi_size)) {\n\t\tif (xfs_buf_is_vmapped(bp)) {\n\t\t\tflush_kernel_vmap_range(bp->b_addr,\n\t\t\t\t\t\txfs_buf_vmap_len(bp));\n\t\t}\n\t\tsubmit_bio(rw, bio);\n\t\tif (size)\n\t\t\tgoto next_chunk;\n\t} else {\n\t\t/*\n\t\t * This is guaranteed not to be the last io reference count\n\t\t * because the caller (xfs_buf_submit) holds a count itself.\n\t\t */\n\t\tatomic_dec(&bp->b_io_remaining);\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbio_put(bio);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_io_length"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_hex_dump",
          "args": [
            "bp->b_addr",
            "64"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_hex_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "109-113",
          "snippet": "void\nxfs_hex_dump(void *p, int length)\n{\n\tprint_hex_dump(KERN_ALERT, \"\", DUMP_PREFIX_ADDRESS, 16, 1, p, length, 1);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_hex_dump(void *p, int length)\n{\n\tprint_hex_dump(KERN_ALERT, \"\", DUMP_PREFIX_ADDRESS, 16, 1, p, length, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: no ops on block 0x%llx/0x%x\"",
            "__func__",
            "bp->b_bn",
            "bp->b_length"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "bp->b_target->bt_mount",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bp->b_ops->verify_write",
          "args": [
            "bp"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_ioapply(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct blk_plug\tplug;\n\tint\t\trw;\n\tint\t\toffset;\n\tint\t\tsize;\n\tint\t\ti;\n\n\t/*\n\t * Make sure we capture only current IO errors rather than stale errors\n\t * left over from previous use of the buffer (e.g. failed readahead).\n\t */\n\tbp->b_error = 0;\n\n\t/*\n\t * Initialize the I/O completion workqueue if we haven't yet or the\n\t * submitter has not opted to specify a custom one.\n\t */\n\tif (!bp->b_ioend_wq)\n\t\tbp->b_ioend_wq = bp->b_target->bt_mount->m_buf_workqueue;\n\n\tif (bp->b_flags & XBF_WRITE) {\n\t\tif (bp->b_flags & XBF_SYNCIO)\n\t\t\trw = WRITE_SYNC;\n\t\telse\n\t\t\trw = WRITE;\n\t\tif (bp->b_flags & XBF_FUA)\n\t\t\trw |= REQ_FUA;\n\t\tif (bp->b_flags & XBF_FLUSH)\n\t\t\trw |= REQ_FLUSH;\n\n\t\t/*\n\t\t * Run the write verifier callback function if it exists. If\n\t\t * this function fails it will mark the buffer with an error and\n\t\t * the IO should not be dispatched.\n\t\t */\n\t\tif (bp->b_ops) {\n\t\t\tbp->b_ops->verify_write(bp);\n\t\t\tif (bp->b_error) {\n\t\t\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {\n\t\t\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\t\t\t/*\n\t\t\t * non-crc filesystems don't attach verifiers during\n\t\t\t * log recovery, so don't warn for such filesystems.\n\t\t\t */\n\t\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\txfs_warn(mp,\n\t\t\t\t\t\"%s: no ops on block 0x%llx/0x%x\",\n\t\t\t\t\t__func__, bp->b_bn, bp->b_length);\n\t\t\t\txfs_hex_dump(bp->b_addr, 64);\n\t\t\t\tdump_stack();\n\t\t\t}\n\t\t}\n\t} else if (bp->b_flags & XBF_READ_AHEAD) {\n\t\trw = READA;\n\t} else {\n\t\trw = READ;\n\t}\n\n\t/* we only use the buffer cache for meta-data */\n\trw |= REQ_META;\n\n\t/*\n\t * Walk all the vectors issuing IO on them. Set up the initial offset\n\t * into the buffer and the desired IO size before we start -\n\t * _xfs_buf_ioapply_vec() will modify them appropriately for each\n\t * subsequent call.\n\t */\n\toffset = bp->b_offset;\n\tsize = BBTOB(bp->b_io_length);\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < bp->b_map_count; i++) {\n\t\txfs_buf_ioapply_map(bp, i, &offset, &size, rw);\n\t\tif (bp->b_error)\n\t\t\tbreak;\n\t\tif (size <= 0)\n\t\t\tbreak;\t/* all done */\n\t}\n\tblk_finish_plug(&plug);\n}"
  },
  {
    "function_name": "xfs_buf_ioapply_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1123-1205",
    "snippet": "static void\nxfs_buf_ioapply_map(\n\tstruct xfs_buf\t*bp,\n\tint\t\tmap,\n\tint\t\t*buf_offset,\n\tint\t\t*count,\n\tint\t\trw)\n{\n\tint\t\tpage_index;\n\tint\t\ttotal_nr_pages = bp->b_page_count;\n\tint\t\tnr_pages;\n\tstruct bio\t*bio;\n\tsector_t\tsector =  bp->b_maps[map].bm_bn;\n\tint\t\tsize;\n\tint\t\toffset;\n\n\ttotal_nr_pages = bp->b_page_count;\n\n\t/* skip the pages in the buffer before the start offset */\n\tpage_index = 0;\n\toffset = *buf_offset;\n\twhile (offset >= PAGE_SIZE) {\n\t\tpage_index++;\n\t\toffset -= PAGE_SIZE;\n\t}\n\n\t/*\n\t * Limit the IO size to the length of the current vector, and update the\n\t * remaining IO count for the next time around.\n\t */\n\tsize = min_t(int, BBTOB(bp->b_maps[map].bm_len), *count);\n\t*count -= size;\n\t*buf_offset += size;\n\nnext_chunk:\n\tatomic_inc(&bp->b_io_remaining);\n\tnr_pages = BIO_MAX_SECTORS >> (PAGE_SHIFT - BBSHIFT);\n\tif (nr_pages > total_nr_pages)\n\t\tnr_pages = total_nr_pages;\n\n\tbio = bio_alloc(GFP_NOIO, nr_pages);\n\tbio->bi_bdev = bp->b_target->bt_bdev;\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_end_io = xfs_buf_bio_end_io;\n\tbio->bi_private = bp;\n\n\n\tfor (; size && nr_pages; nr_pages--, page_index++) {\n\t\tint\trbytes, nbytes = PAGE_SIZE - offset;\n\n\t\tif (nbytes > size)\n\t\t\tnbytes = size;\n\n\t\trbytes = bio_add_page(bio, bp->b_pages[page_index], nbytes,\n\t\t\t\t      offset);\n\t\tif (rbytes < nbytes)\n\t\t\tbreak;\n\n\t\toffset = 0;\n\t\tsector += BTOBB(nbytes);\n\t\tsize -= nbytes;\n\t\ttotal_nr_pages--;\n\t}\n\n\tif (likely(bio->bi_iter.bi_size)) {\n\t\tif (xfs_buf_is_vmapped(bp)) {\n\t\t\tflush_kernel_vmap_range(bp->b_addr,\n\t\t\t\t\t\txfs_buf_vmap_len(bp));\n\t\t}\n\t\tsubmit_bio(rw, bio);\n\t\tif (size)\n\t\t\tgoto next_chunk;\n\t} else {\n\t\t/*\n\t\t * This is guaranteed not to be the last io reference count\n\t\t * because the caller (xfs_buf_submit) holds a count itself.\n\t\t */\n\t\tatomic_dec(&bp->b_io_remaining);\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbio_put(bio);\n\t}\n\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EIO"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bp->b_io_remaining"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_kernel_vmap_range",
          "args": [
            "bp->b_addr",
            "xfs_buf_vmap_len(bp)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_vmap_len",
          "args": [
            "bp"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_vmap_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "75-80",
          "snippet": "static inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_is_vmapped",
          "args": [
            "bp"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_is_vmapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "61-73",
          "snippet": "static inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bio->bi_iter.bi_size"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "nbytes"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "bp->b_pages[page_index]",
            "nbytes",
            "offset"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "nr_pages"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bp->b_io_remaining"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "BBTOB(bp->b_maps[map].bm_len)",
            "*count"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[map].bm_len"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_ioapply_map(\n\tstruct xfs_buf\t*bp,\n\tint\t\tmap,\n\tint\t\t*buf_offset,\n\tint\t\t*count,\n\tint\t\trw)\n{\n\tint\t\tpage_index;\n\tint\t\ttotal_nr_pages = bp->b_page_count;\n\tint\t\tnr_pages;\n\tstruct bio\t*bio;\n\tsector_t\tsector =  bp->b_maps[map].bm_bn;\n\tint\t\tsize;\n\tint\t\toffset;\n\n\ttotal_nr_pages = bp->b_page_count;\n\n\t/* skip the pages in the buffer before the start offset */\n\tpage_index = 0;\n\toffset = *buf_offset;\n\twhile (offset >= PAGE_SIZE) {\n\t\tpage_index++;\n\t\toffset -= PAGE_SIZE;\n\t}\n\n\t/*\n\t * Limit the IO size to the length of the current vector, and update the\n\t * remaining IO count for the next time around.\n\t */\n\tsize = min_t(int, BBTOB(bp->b_maps[map].bm_len), *count);\n\t*count -= size;\n\t*buf_offset += size;\n\nnext_chunk:\n\tatomic_inc(&bp->b_io_remaining);\n\tnr_pages = BIO_MAX_SECTORS >> (PAGE_SHIFT - BBSHIFT);\n\tif (nr_pages > total_nr_pages)\n\t\tnr_pages = total_nr_pages;\n\n\tbio = bio_alloc(GFP_NOIO, nr_pages);\n\tbio->bi_bdev = bp->b_target->bt_bdev;\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_end_io = xfs_buf_bio_end_io;\n\tbio->bi_private = bp;\n\n\n\tfor (; size && nr_pages; nr_pages--, page_index++) {\n\t\tint\trbytes, nbytes = PAGE_SIZE - offset;\n\n\t\tif (nbytes > size)\n\t\t\tnbytes = size;\n\n\t\trbytes = bio_add_page(bio, bp->b_pages[page_index], nbytes,\n\t\t\t\t      offset);\n\t\tif (rbytes < nbytes)\n\t\t\tbreak;\n\n\t\toffset = 0;\n\t\tsector += BTOBB(nbytes);\n\t\tsize -= nbytes;\n\t\ttotal_nr_pages--;\n\t}\n\n\tif (likely(bio->bi_iter.bi_size)) {\n\t\tif (xfs_buf_is_vmapped(bp)) {\n\t\t\tflush_kernel_vmap_range(bp->b_addr,\n\t\t\t\t\t\txfs_buf_vmap_len(bp));\n\t\t}\n\t\tsubmit_bio(rw, bio);\n\t\tif (size)\n\t\t\tgoto next_chunk;\n\t} else {\n\t\t/*\n\t\t * This is guaranteed not to be the last io reference count\n\t\t * because the caller (xfs_buf_submit) holds a count itself.\n\t\t */\n\t\tatomic_dec(&bp->b_io_remaining);\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\tbio_put(bio);\n\t}\n\n}"
  },
  {
    "function_name": "xfs_buf_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1097-1121",
    "snippet": "STATIC void\nxfs_buf_bio_end_io(\n\tstruct bio\t\t*bio,\n\tint\t\t\terror)\n{\n\txfs_buf_t\t\t*bp = (xfs_buf_t *)bio->bi_private;\n\n\t/*\n\t * don't overwrite existing errors - otherwise we can lose errors on\n\t * buffers that require multiple bios to complete.\n\t */\n\tif (error) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!bp->b_io_error)\n\t\t\tbp->b_io_error = error;\n\t\tspin_unlock(&bp->b_lock);\n\t}\n\n\tif (!bp->b_error && xfs_buf_is_vmapped(bp) && (bp->b_flags & XBF_READ))\n\t\tinvalidate_kernel_vmap_range(bp->b_addr, xfs_buf_vmap_len(bp));\n\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend_async(bp);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioend_async",
          "args": [
            "bp"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bp->b_io_remaining"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_kernel_vmap_range",
          "args": [
            "bp->b_addr",
            "xfs_buf_vmap_len(bp)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_vmap_len",
          "args": [
            "bp"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_vmap_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "75-80",
          "snippet": "static inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_is_vmapped",
          "args": [
            "bp"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_is_vmapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "61-73",
          "snippet": "static inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_bio_end_io(\n\tstruct bio\t\t*bio,\n\tint\t\t\terror)\n{\n\txfs_buf_t\t\t*bp = (xfs_buf_t *)bio->bi_private;\n\n\t/*\n\t * don't overwrite existing errors - otherwise we can lose errors on\n\t * buffers that require multiple bios to complete.\n\t */\n\tif (error) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!bp->b_io_error)\n\t\t\tbp->b_io_error = error;\n\t\tspin_unlock(&bp->b_lock);\n\t}\n\n\tif (!bp->b_error && xfs_buf_is_vmapped(bp) && (bp->b_flags & XBF_READ))\n\t\tinvalidate_kernel_vmap_range(bp->b_addr, xfs_buf_vmap_len(bp));\n\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend_async(bp);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "xfs_bwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1077-1095",
    "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "bp->b_target->bt_mount",
            "SHUTDOWN_META_IO_ERROR"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit_wait",
          "args": [
            "bp"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_buf_ioerror_alert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1067-1075",
    "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "bp->b_target->bt_mount",
            "\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\"",
            "(__uint64_t)XFS_BUF_ADDR(bp)",
            "func",
            "-bp->b_error",
            "bp->b_length"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
  },
  {
    "function_name": "xfs_buf_ioerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1057-1065",
    "snippet": "void\nxfs_buf_ioerror(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\terror)\n{\n\tASSERT(error <= 0 && error >= -1000);\n\tbp->b_error = error;\n\ttrace_xfs_buf_ioerror(bp, error, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_ioerror",
          "args": [
            "bp",
            "error",
            "_RET_IP_"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error <= 0 && error >= -1000"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\terror)\n{\n\tASSERT(error <= 0 && error >= -1000);\n\tbp->b_error = error;\n\ttrace_xfs_buf_ioerror(bp, error, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_buf_ioend_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1049-1055",
    "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "bp->b_ioend_wq",
            "&bp->b_ioend_work"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&bp->b_ioend_work",
            "xfs_buf_ioend_work"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
  },
  {
    "function_name": "xfs_buf_ioend_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1039-1047",
    "snippet": "static void\nxfs_buf_ioend_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_buf\t\t*bp =\n\t\tcontainer_of(work, xfs_buf_t, b_ioend_work);\n\n\txfs_buf_ioend(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioend",
          "args": [
            "bp"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioend_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1049-1055",
          "snippet": "void\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend_async(\n\tstruct xfs_buf\t*bp)\n{\n\tINIT_WORK(&bp->b_ioend_work, xfs_buf_ioend_work);\n\tqueue_work(bp->b_ioend_wq, &bp->b_ioend_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "xfs_buf_t",
            "b_ioend_work"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_ioend_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_buf\t\t*bp =\n\t\tcontainer_of(work, xfs_buf_t, b_ioend_work);\n\n\txfs_buf_ioend(bp);\n}"
  },
  {
    "function_name": "xfs_buf_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "1005-1037",
    "snippet": "void\nxfs_buf_ioend(\n\tstruct xfs_buf\t*bp)\n{\n\tbool\t\tread = bp->b_flags & XBF_READ;\n\n\ttrace_xfs_buf_iodone(bp, _RET_IP_);\n\n\tbp->b_flags &= ~(XBF_READ | XBF_WRITE | XBF_READ_AHEAD);\n\n\t/*\n\t * Pull in IO completion errors now. We are guaranteed to be running\n\t * single threaded, so we don't need the lock to read b_io_error.\n\t */\n\tif (!bp->b_error && bp->b_io_error)\n\t\txfs_buf_ioerror(bp, bp->b_io_error);\n\n\t/* Only validate buffers that were read without errors */\n\tif (read && !bp->b_error && bp->b_ops) {\n\t\tASSERT(!bp->b_iodone);\n\t\tbp->b_ops->verify_read(bp);\n\t}\n\n\tif (!bp->b_error)\n\t\tbp->b_flags |= XBF_DONE;\n\n\tif (bp->b_iodone)\n\t\t(*(bp->b_iodone))(bp);\n\telse if (bp->b_flags & XBF_ASYNC)\n\t\txfs_buf_relse(bp);\n\telse\n\t\tcomplete(&bp->b_iowait);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&bp->b_iowait"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "bp"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bp->b_ops->verify_read",
          "args": [
            "bp"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bp->b_iodone"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "bp->b_io_error"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_iodone",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioend(\n\tstruct xfs_buf\t*bp)\n{\n\tbool\t\tread = bp->b_flags & XBF_READ;\n\n\ttrace_xfs_buf_iodone(bp, _RET_IP_);\n\n\tbp->b_flags &= ~(XBF_READ | XBF_WRITE | XBF_READ_AHEAD);\n\n\t/*\n\t * Pull in IO completion errors now. We are guaranteed to be running\n\t * single threaded, so we don't need the lock to read b_io_error.\n\t */\n\tif (!bp->b_error && bp->b_io_error)\n\t\txfs_buf_ioerror(bp, bp->b_io_error);\n\n\t/* Only validate buffers that were read without errors */\n\tif (read && !bp->b_error && bp->b_ops) {\n\t\tASSERT(!bp->b_iodone);\n\t\tbp->b_ops->verify_read(bp);\n\t}\n\n\tif (!bp->b_error)\n\t\tbp->b_flags |= XBF_DONE;\n\n\tif (bp->b_iodone)\n\t\t(*(bp->b_iodone))(bp);\n\telse if (bp->b_flags & XBF_ASYNC)\n\t\txfs_buf_relse(bp);\n\telse\n\t\tcomplete(&bp->b_iowait);\n}"
  },
  {
    "function_name": "xfs_buf_wait_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "981-999",
    "snippet": "STATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&bp->b_waiters",
            "&wait"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_pin_count"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&bp->b_waiters",
            "&wait"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_pin_count"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\nxfs_buf_wait_unpin(\n\txfs_buf_t\t\t*bp)\n{\n\tDECLARE_WAITQUEUE\t(wait, current);\n\n\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\treturn;\n\n\tadd_wait_queue(&bp->b_waiters, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&bp->b_pin_count) == 0)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\tremove_wait_queue(&bp->b_waiters, &wait);\n\tset_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "xfs_buf_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "971-979",
    "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_unlock",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&bp->b_sema"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "116-152",
          "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XB_CLEAR_OWNER",
          "args": [
            "bp"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_buf_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "957-969",
    "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_lock_done",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XB_SET_OWNER",
          "args": [
            "bp"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down",
          "args": [
            "&bp->b_sema"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1233-1275",
          "snippet": "int follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "bp->b_target->bt_mount",
            "0"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_pin_count"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_lock",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_buf_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "934-946",
    "snippet": "int\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_trylock",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XB_SET_OWNER",
          "args": [
            "bp"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_trylock",
          "args": [
            "&bp->b_sema"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}"
  },
  {
    "function_name": "xfs_buf_rele",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "866-920",
    "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_free",
          "args": [
            "bp"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "255-280",
          "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_buf_lock"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&bp->b_rbnode",
            "&pag->pag_buf_tree"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bp->b_flags & _XBF_DELWRI_Q)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&bp->b_lru)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bp->b_lru"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&bp->b_target->bt_lru",
            "&bp->b_lru"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bp->b_hold"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&bp->b_target->bt_lru",
            "&bp->b_lru"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_lru_ref"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&bp->b_hold",
            "&pag->pag_buf_lock"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bp->b_hold) > 0"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_hold"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!RB_EMPTY_NODE(&bp->b_rbnode)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&bp->b_rbnode"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&bp->b_hold"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "RB_EMPTY_NODE(&bp->b_rbnode)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&bp->b_rbnode"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&bp->b_lru)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_rele",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "854-860",
    "snippet": "void\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bp->b_hold"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_hold",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_hold(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_hold(bp, _RET_IP_);\n\tatomic_inc(&bp->b_hold);\n}"
  },
  {
    "function_name": "xfs_buf_get_uncached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "801-847",
    "snippet": "xfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_buf_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_buf_zone",
            "bp"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_free_maps",
          "args": [
            "bp"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "138-146",
          "snippet": "static void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_free_pages",
          "args": [
            "bp"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "bp->b_pages[i]"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_get_uncached",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "target->bt_mount",
            "\"%s: failed to map pages\"",
            "__func__"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_map_pages",
          "args": [
            "bp",
            "0"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "383-422",
          "snippet": "STATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "xb_to_gfp(flags)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xb_to_gfp",
          "args": [
            "flags"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_get_pages",
          "args": [
            "bp",
            "page_count"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "214-233",
          "snippet": "STATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "numblks << BBSHIFT"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bp == NULL"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_alloc",
          "args": [
            "target",
            "&map",
            "1",
            "0"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "148-208",
          "snippet": "struct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nstruct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "XFS_BUF_DADDR_NULL",
            "numblks"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nxfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_buf_associate_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "759-799",
    "snippet": "int\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "buflen"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "len"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_to_page",
          "args": [
            "(void *)pageaddr"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "mem_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "748-757",
          "snippet": "static inline struct page *\nmem_to_page(\n\tvoid\t\t\t*addr)\n{\n\tif ((!is_vmalloc_addr(addr))) {\n\t\treturn virt_to_page(addr);\n\t} else {\n\t\treturn vmalloc_to_page(addr);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline struct page *\nmem_to_page(\n\tvoid\t\t\t*addr)\n{\n\tif ((!is_vmalloc_addr(addr))) {\n\t\treturn virt_to_page(addr);\n\t} else {\n\t\treturn vmalloc_to_page(addr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_get_pages",
          "args": [
            "bp",
            "page_count"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "214-233",
          "snippet": "STATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_free_pages",
          "args": [
            "bp"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len + offset"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "748-757",
    "snippet": "static inline struct page *\nmem_to_page(\n\tvoid\t\t\t*addr)\n{\n\tif ((!is_vmalloc_addr(addr))) {\n\t\treturn virt_to_page(addr);\n\t} else {\n\t\treturn vmalloc_to_page(addr);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline struct page *\nmem_to_page(\n\tvoid\t\t\t*addr)\n{\n\tif ((!is_vmalloc_addr(addr))) {\n\t\treturn virt_to_page(addr);\n\t} else {\n\t\treturn vmalloc_to_page(addr);\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_set_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "728-746",
    "snippet": "void\nxfs_buf_set_empty(\n\tstruct xfs_buf\t\t*bp,\n\tsize_t\t\t\tnumblks)\n{\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_page_count = 0;\n\tbp->b_addr = NULL;\n\tbp->b_length = numblks;\n\tbp->b_io_length = numblks;\n\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_len = bp->b_length;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_map_count == 1"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_free_pages",
          "args": [
            "bp"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_set_empty(\n\tstruct xfs_buf\t\t*bp,\n\tsize_t\t\t\tnumblks)\n{\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_page_count = 0;\n\tbp->b_addr = NULL;\n\tbp->b_length = numblks;\n\tbp->b_io_length = numblks;\n\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_bn = XFS_BUF_DADDR_NULL;\n\tbp->b_maps[0].bm_len = bp->b_length;\n}"
  },
  {
    "function_name": "xfs_buf_read_uncached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "689-722",
    "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_submit_wait",
          "args": [
            "bp"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_map_count == 1"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_uncached",
          "args": [
            "target",
            "numblks",
            "flags"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "801-847",
          "snippet": "xfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nxfs_buf_t *\nxfs_buf_get_uncached(\n\tstruct xfs_buftarg\t*target,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags)\n{\n\tunsigned long\t\tpage_count;\n\tint\t\t\terror, i;\n\tstruct xfs_buf\t\t*bp;\n\tDEFINE_SINGLE_BUF_MAP(map, XFS_BUF_DADDR_NULL, numblks);\n\n\tbp = _xfs_buf_alloc(target, &map, 1, 0);\n\tif (unlikely(bp == NULL))\n\t\tgoto fail;\n\n\tpage_count = PAGE_ALIGN(numblks << BBSHIFT) >> PAGE_SHIFT;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (error)\n\t\tgoto fail_free_buf;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbp->b_pages[i] = alloc_page(xb_to_gfp(flags));\n\t\tif (!bp->b_pages[i])\n\t\t\tgoto fail_free_mem;\n\t}\n\tbp->b_flags |= _XBF_PAGES;\n\n\terror = _xfs_buf_map_pages(bp, 0);\n\tif (unlikely(error)) {\n\t\txfs_warn(target->bt_mount,\n\t\t\t\"%s: failed to map pages\", __func__);\n\t\tgoto fail_free_mem;\n\t}\n\n\ttrace_xfs_buf_get_uncached(bp, _RET_IP_);\n\treturn bp;\n\n fail_free_mem:\n\twhile (--i >= 0)\n\t\t__free_page(bp->b_pages[i]);\n\t_xfs_buf_free_pages(bp);\n fail_free_buf:\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n fail:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_buf_readahead_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "671-683",
    "snippet": "void\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_read_map",
          "args": [
            "target",
            "map",
            "nmaps",
            "XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD",
            "ops"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "631-665",
          "snippet": "xfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_read_congested",
          "args": [
            "target->bt_bdi"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}"
  },
  {
    "function_name": "xfs_buf_read_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "631-665",
    "snippet": "xfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_read",
          "args": [
            "bp",
            "flags"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "613-629",
          "snippet": "STATIC int\n_xfs_buf_read(\n\txfs_buf_t\t\t*bp,\n\txfs_buf_flags_t\t\tflags)\n{\n\tASSERT(!(flags & XBF_WRITE));\n\tASSERT(bp->b_maps[0].bm_bn != XFS_BUF_DADDR_NULL);\n\n\tbp->b_flags &= ~(XBF_WRITE | XBF_ASYNC | XBF_READ_AHEAD);\n\tbp->b_flags |= flags & (XBF_READ | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tif (flags & XBF_ASYNC) {\n\t\txfs_buf_submit(bp);\n\t\treturn 0;\n\t}\n\treturn xfs_buf_submit_wait(bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_read(\n\txfs_buf_t\t\t*bp,\n\txfs_buf_flags_t\t\tflags)\n{\n\tASSERT(!(flags & XBF_WRITE));\n\tASSERT(bp->b_maps[0].bm_bn != XFS_BUF_DADDR_NULL);\n\n\tbp->b_flags &= ~(XBF_WRITE | XBF_ASYNC | XBF_READ_AHEAD);\n\tbp->b_flags |= flags & (XBF_READ | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tif (flags & XBF_ASYNC) {\n\t\txfs_buf_submit(bp);\n\t\treturn 0;\n\t}\n\treturn xfs_buf_submit_wait(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_get_read"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISDONE",
          "args": [
            "bp"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_read",
          "args": [
            "bp",
            "flags",
            "_RET_IP_"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_map",
          "args": [
            "target",
            "map",
            "nmaps",
            "flags"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "563-611",
          "snippet": "struct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}"
  },
  {
    "function_name": "_xfs_buf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "613-629",
    "snippet": "STATIC int\n_xfs_buf_read(\n\txfs_buf_t\t\t*bp,\n\txfs_buf_flags_t\t\tflags)\n{\n\tASSERT(!(flags & XBF_WRITE));\n\tASSERT(bp->b_maps[0].bm_bn != XFS_BUF_DADDR_NULL);\n\n\tbp->b_flags &= ~(XBF_WRITE | XBF_ASYNC | XBF_READ_AHEAD);\n\tbp->b_flags |= flags & (XBF_READ | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tif (flags & XBF_ASYNC) {\n\t\txfs_buf_submit(bp);\n\t\treturn 0;\n\t}\n\treturn xfs_buf_submit_wait(bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_submit_wait",
          "args": [
            "bp"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_submit_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1362-1420",
          "snippet": "int\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_submit_wait(\n\tstruct xfs_buf\t*bp)\n{\n\tint\t\terror;\n\n\ttrace_xfs_buf_submit_wait(bp, _RET_IP_);\n\n\tASSERT(!(bp->b_flags & (_XBF_DELWRI_Q | XBF_ASYNC)));\n\n\tif (XFS_FORCED_SHUTDOWN(bp->b_target->bt_mount)) {\n\t\txfs_buf_ioerror(bp, -EIO);\n\t\txfs_buf_stale(bp);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\treturn -EIO;\n\t}\n\n\tif (bp->b_flags & XBF_WRITE)\n\t\txfs_buf_wait_unpin(bp);\n\n\t/* clear the internal error state to avoid spurious errors */\n\tbp->b_io_error = 0;\n\n\t/*\n\t * For synchronous IO, the IO does not inherit the submitters reference\n\t * count, nor the buffer lock. Hence we cannot release the reference we\n\t * are about to take until we've waited for all IO completion to occur,\n\t * including any xfs_buf_ioend_async() work that may be pending.\n\t */\n\txfs_buf_hold(bp);\n\n\t/*\n\t * Set the count to 1 initially, this will stop an I/O completion\n\t * callout which happens before we have started all the I/O from calling\n\t * xfs_buf_ioend too early.\n\t */\n\tatomic_set(&bp->b_io_remaining, 1);\n\t_xfs_buf_ioapply(bp);\n\n\t/*\n\t * make sure we run completion synchronously if it raced with us and is\n\t * already complete.\n\t */\n\tif (atomic_dec_and_test(&bp->b_io_remaining) == 1)\n\t\txfs_buf_ioend(bp);\n\n\t/* wait for completion before gathering the error from the buffer */\n\ttrace_xfs_buf_iowait(bp, _RET_IP_);\n\twait_for_completion(&bp->b_iowait);\n\ttrace_xfs_buf_iowait_done(bp, _RET_IP_);\n\terror = bp->b_error;\n\n\t/*\n\t * all done now, we can release the hold that keeps the buffer\n\t * referenced for the entire IO.\n\t */\n\txfs_buf_rele(bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_maps[0].bm_bn != XFS_BUF_DADDR_NULL"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XBF_WRITE)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_read(\n\txfs_buf_t\t\t*bp,\n\txfs_buf_flags_t\t\tflags)\n{\n\tASSERT(!(flags & XBF_WRITE));\n\tASSERT(bp->b_maps[0].bm_bn != XFS_BUF_DADDR_NULL);\n\n\tbp->b_flags &= ~(XBF_WRITE | XBF_ASYNC | XBF_READ_AHEAD);\n\tbp->b_flags |= flags & (XBF_READ | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tif (flags & XBF_ASYNC) {\n\t\txfs_buf_submit(bp);\n\t\treturn 0;\n\t}\n\treturn xfs_buf_submit_wait(bp);\n}"
  },
  {
    "function_name": "xfs_buf_get_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "563-611",
    "snippet": "struct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_get",
          "args": [
            "bp",
            "flags",
            "_RET_IP_"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_get"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "target->bt_mount",
            "\"%s: failed to map pagesn\"",
            "__func__"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_map_pages",
          "args": [
            "bp",
            "flags"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "383-422",
          "snippet": "STATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_free",
          "args": [
            "new_bp"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "255-280",
          "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_find",
          "args": [
            "target",
            "map",
            "nmaps",
            "flags",
            "new_bp"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "433-556",
          "snippet": "xfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_allocate_memory",
          "args": [
            "new_bp",
            "flags"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_allocate_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "285-378",
          "snippet": "STATIC int\nxfs_buf_allocate_memory(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tsize_t\t\t\tsize;\n\tsize_t\t\t\tnbytes, offset;\n\tgfp_t\t\t\tgfp_mask = xb_to_gfp(flags);\n\tunsigned short\t\tpage_count, i;\n\txfs_off_t\t\tstart, end;\n\tint\t\t\terror;\n\n\t/*\n\t * for buffers that are contained within a single page, just allocate\n\t * the memory from the heap - there's no need for the complexity of\n\t * page arrays to keep allocation down to order 0.\n\t */\n\tsize = BBTOB(bp->b_length);\n\tif (size < PAGE_SIZE) {\n\t\tbp->b_addr = kmem_alloc(size, KM_NOFS);\n\t\tif (!bp->b_addr) {\n\t\t\t/* low memory - use alloc_page loop instead */\n\t\t\tgoto use_alloc_page;\n\t\t}\n\n\t\tif (((unsigned long)(bp->b_addr + size - 1) & PAGE_MASK) !=\n\t\t    ((unsigned long)bp->b_addr & PAGE_MASK)) {\n\t\t\t/* b_addr spans two pages - use alloc_page instead */\n\t\t\tkmem_free(bp->b_addr);\n\t\t\tbp->b_addr = NULL;\n\t\t\tgoto use_alloc_page;\n\t\t}\n\t\tbp->b_offset = offset_in_page(bp->b_addr);\n\t\tbp->b_pages = bp->b_page_array;\n\t\tbp->b_pages[0] = virt_to_page(bp->b_addr);\n\t\tbp->b_page_count = 1;\n\t\tbp->b_flags |= _XBF_KMEM;\n\t\treturn 0;\n\t}\n\nuse_alloc_page:\n\tstart = BBTOB(bp->b_maps[0].bm_bn) >> PAGE_SHIFT;\n\tend = (BBTOB(bp->b_maps[0].bm_bn + bp->b_length) + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\tpage_count = end - start;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (unlikely(error))\n\t\treturn error;\n\n\toffset = bp->b_offset;\n\tbp->b_flags |= _XBF_PAGES;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tstruct page\t*page;\n\t\tuint\t\tretries = 0;\nretry:\n\t\tpage = alloc_page(gfp_mask);\n\t\tif (unlikely(page == NULL)) {\n\t\t\tif (flags & XBF_READ_AHEAD) {\n\t\t\t\tbp->b_page_count = i;\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_free_pages;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This could deadlock.\n\t\t\t *\n\t\t\t * But until all the XFS lowlevel code is revamped to\n\t\t\t * handle buffer allocation failures we can't do much.\n\t\t\t */\n\t\t\tif (!(++retries % 100))\n\t\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, gfp_mask);\n\n\t\t\tXFS_STATS_INC(xb_page_retries);\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tXFS_STATS_INC(xb_page_found);\n\n\t\tnbytes = min_t(size_t, size, PAGE_SIZE - offset);\n\t\tsize -= nbytes;\n\t\tbp->b_pages[i] = page;\n\t\toffset = 0;\n\t}\n\treturn 0;\n\nout_free_pages:\n\tfor (i = 0; i < bp->b_page_count; i++)\n\t\t__free_page(bp->b_pages[i]);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_buf_allocate_memory(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tsize_t\t\t\tsize;\n\tsize_t\t\t\tnbytes, offset;\n\tgfp_t\t\t\tgfp_mask = xb_to_gfp(flags);\n\tunsigned short\t\tpage_count, i;\n\txfs_off_t\t\tstart, end;\n\tint\t\t\terror;\n\n\t/*\n\t * for buffers that are contained within a single page, just allocate\n\t * the memory from the heap - there's no need for the complexity of\n\t * page arrays to keep allocation down to order 0.\n\t */\n\tsize = BBTOB(bp->b_length);\n\tif (size < PAGE_SIZE) {\n\t\tbp->b_addr = kmem_alloc(size, KM_NOFS);\n\t\tif (!bp->b_addr) {\n\t\t\t/* low memory - use alloc_page loop instead */\n\t\t\tgoto use_alloc_page;\n\t\t}\n\n\t\tif (((unsigned long)(bp->b_addr + size - 1) & PAGE_MASK) !=\n\t\t    ((unsigned long)bp->b_addr & PAGE_MASK)) {\n\t\t\t/* b_addr spans two pages - use alloc_page instead */\n\t\t\tkmem_free(bp->b_addr);\n\t\t\tbp->b_addr = NULL;\n\t\t\tgoto use_alloc_page;\n\t\t}\n\t\tbp->b_offset = offset_in_page(bp->b_addr);\n\t\tbp->b_pages = bp->b_page_array;\n\t\tbp->b_pages[0] = virt_to_page(bp->b_addr);\n\t\tbp->b_page_count = 1;\n\t\tbp->b_flags |= _XBF_KMEM;\n\t\treturn 0;\n\t}\n\nuse_alloc_page:\n\tstart = BBTOB(bp->b_maps[0].bm_bn) >> PAGE_SHIFT;\n\tend = (BBTOB(bp->b_maps[0].bm_bn + bp->b_length) + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\tpage_count = end - start;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (unlikely(error))\n\t\treturn error;\n\n\toffset = bp->b_offset;\n\tbp->b_flags |= _XBF_PAGES;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tstruct page\t*page;\n\t\tuint\t\tretries = 0;\nretry:\n\t\tpage = alloc_page(gfp_mask);\n\t\tif (unlikely(page == NULL)) {\n\t\t\tif (flags & XBF_READ_AHEAD) {\n\t\t\t\tbp->b_page_count = i;\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_free_pages;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This could deadlock.\n\t\t\t *\n\t\t\t * But until all the XFS lowlevel code is revamped to\n\t\t\t * handle buffer allocation failures we can't do much.\n\t\t\t */\n\t\t\tif (!(++retries % 100))\n\t\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, gfp_mask);\n\n\t\t\tXFS_STATS_INC(xb_page_retries);\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tXFS_STATS_INC(xb_page_found);\n\n\t\tnbytes = min_t(size_t, size, PAGE_SIZE - offset);\n\t\tsize -= nbytes;\n\t\tbp->b_pages[i] = page;\n\t\toffset = 0;\n\t}\n\treturn 0;\n\nout_free_pages:\n\tfor (i = 0; i < bp->b_page_count; i++)\n\t\t__free_page(bp->b_pages[i]);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_bp"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_alloc",
          "args": [
            "target",
            "map",
            "nmaps",
            "flags"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "148-208",
          "snippet": "struct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nstruct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bp"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}"
  },
  {
    "function_name": "_xfs_buf_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "433-556",
    "snippet": "xfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_get_locked"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_find",
          "args": [
            "bp",
            "flags",
            "_RET_IP_"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_iodone == NULL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(bp->b_flags & _XBF_DELWRI_Q) == 0"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_get_locked_waited"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_lock",
          "args": [
            "bp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "957-969",
          "snippet": "void\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_lock(\n\tstruct xfs_buf\t\t*bp)\n{\n\ttrace_xfs_buf_lock(bp, _RET_IP_);\n\n\tif (atomic_read(&bp->b_pin_count) && (bp->b_flags & XBF_STALE))\n\t\txfs_log_force(bp->b_target->bt_mount, 0);\n\tdown(&bp->b_sema);\n\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_lock_done(bp, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_busy_locked"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_trylock",
          "args": [
            "bp"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "934-946",
          "snippet": "int\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_trylock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\tlocked;\n\n\tlocked = down_trylock(&bp->b_sema) == 0;\n\tif (locked)\n\t\tXB_SET_OWNER(bp);\n\n\ttrace_xfs_buf_trylock(bp, _RET_IP_);\n\treturn locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pag_buf_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_miss_locked"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_bp->b_rbnode",
            "&pag->pag_buf_tree"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_bp->b_rbnode",
            "parent",
            "rbp"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bp->b_hold"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_flags & XBF_STALE"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structxfs_buf",
            "b_rbnode"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pag_buf_lock"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "btp->bt_mount",
            "xfs_daddr_to_agno(btp->bt_mount, blkno)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_daddr_to_agno",
          "args": [
            "btp->bt_mount",
            "blkno"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_daddr_to_agno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.h",
          "lines": "288-294",
          "snippet": "static inline xfs_agnumber_t\nxfs_daddr_to_agno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\tdo_div(ld, mp->m_sb.sb_agblocks);\n\treturn (xfs_agnumber_t) ld;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_agnumber_t\nxfs_daddr_to_agno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\tdo_div(ld, mp->m_sb.sb_agblocks);\n\treturn (xfs_agnumber_t) ld;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "btp->bt_mount",
            "\"%s: Block out of range: block 0x%llx, EOFS 0x%llx \"",
            "__func__",
            "blkno",
            "eofs"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "btp->bt_mount",
            "btp->bt_mount->m_sb.sb_dblocks"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "blkno"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(numbytes < btp->bt_meta_sectorsize)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "numblks"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}"
  },
  {
    "function_name": "_xfs_buf_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "383-422",
    "snippet": "STATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memalloc_noio_restore",
          "args": [
            "noio_flag"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unmap_aliases",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_map_ram",
          "args": [
            "bp->b_pages",
            "bp->b_page_count",
            "-1",
            "PAGE_KERNEL"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_noio_save",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "bp->b_pages[0]"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_flags & _XBF_PAGES"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_map_pages(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tASSERT(bp->b_flags & _XBF_PAGES);\n\tif (bp->b_page_count == 1) {\n\t\t/* A single page buffer is always mappable */\n\t\tbp->b_addr = page_address(bp->b_pages[0]) + bp->b_offset;\n\t} else if (flags & XBF_UNMAPPED) {\n\t\tbp->b_addr = NULL;\n\t} else {\n\t\tint retried = 0;\n\t\tunsigned noio_flag;\n\n\t\t/*\n\t\t * vm_map_ram() will allocate auxillary structures (e.g.\n\t\t * pagetables) with GFP_KERNEL, yet we are likely to be under\n\t\t * GFP_NOFS context here. Hence we need to tell memory reclaim\n\t\t * that we are in such a context via PF_MEMALLOC_NOIO to prevent\n\t\t * memory reclaim re-entering the filesystem here and\n\t\t * potentially deadlocking.\n\t\t */\n\t\tnoio_flag = memalloc_noio_save();\n\t\tdo {\n\t\t\tbp->b_addr = vm_map_ram(bp->b_pages, bp->b_page_count,\n\t\t\t\t\t\t-1, PAGE_KERNEL);\n\t\t\tif (bp->b_addr)\n\t\t\t\tbreak;\n\t\t\tvm_unmap_aliases();\n\t\t} while (retried++ <= 1);\n\t\tmemalloc_noio_restore(noio_flag);\n\n\t\tif (!bp->b_addr)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_addr += bp->b_offset;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_buf_allocate_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "285-378",
    "snippet": "STATIC int\nxfs_buf_allocate_memory(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tsize_t\t\t\tsize;\n\tsize_t\t\t\tnbytes, offset;\n\tgfp_t\t\t\tgfp_mask = xb_to_gfp(flags);\n\tunsigned short\t\tpage_count, i;\n\txfs_off_t\t\tstart, end;\n\tint\t\t\terror;\n\n\t/*\n\t * for buffers that are contained within a single page, just allocate\n\t * the memory from the heap - there's no need for the complexity of\n\t * page arrays to keep allocation down to order 0.\n\t */\n\tsize = BBTOB(bp->b_length);\n\tif (size < PAGE_SIZE) {\n\t\tbp->b_addr = kmem_alloc(size, KM_NOFS);\n\t\tif (!bp->b_addr) {\n\t\t\t/* low memory - use alloc_page loop instead */\n\t\t\tgoto use_alloc_page;\n\t\t}\n\n\t\tif (((unsigned long)(bp->b_addr + size - 1) & PAGE_MASK) !=\n\t\t    ((unsigned long)bp->b_addr & PAGE_MASK)) {\n\t\t\t/* b_addr spans two pages - use alloc_page instead */\n\t\t\tkmem_free(bp->b_addr);\n\t\t\tbp->b_addr = NULL;\n\t\t\tgoto use_alloc_page;\n\t\t}\n\t\tbp->b_offset = offset_in_page(bp->b_addr);\n\t\tbp->b_pages = bp->b_page_array;\n\t\tbp->b_pages[0] = virt_to_page(bp->b_addr);\n\t\tbp->b_page_count = 1;\n\t\tbp->b_flags |= _XBF_KMEM;\n\t\treturn 0;\n\t}\n\nuse_alloc_page:\n\tstart = BBTOB(bp->b_maps[0].bm_bn) >> PAGE_SHIFT;\n\tend = (BBTOB(bp->b_maps[0].bm_bn + bp->b_length) + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\tpage_count = end - start;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (unlikely(error))\n\t\treturn error;\n\n\toffset = bp->b_offset;\n\tbp->b_flags |= _XBF_PAGES;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tstruct page\t*page;\n\t\tuint\t\tretries = 0;\nretry:\n\t\tpage = alloc_page(gfp_mask);\n\t\tif (unlikely(page == NULL)) {\n\t\t\tif (flags & XBF_READ_AHEAD) {\n\t\t\t\tbp->b_page_count = i;\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_free_pages;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This could deadlock.\n\t\t\t *\n\t\t\t * But until all the XFS lowlevel code is revamped to\n\t\t\t * handle buffer allocation failures we can't do much.\n\t\t\t */\n\t\t\tif (!(++retries % 100))\n\t\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, gfp_mask);\n\n\t\t\tXFS_STATS_INC(xb_page_retries);\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tXFS_STATS_INC(xb_page_found);\n\n\t\tnbytes = min_t(size_t, size, PAGE_SIZE - offset);\n\t\tsize -= nbytes;\n\t\tbp->b_pages[i] = page;\n\t\toffset = 0;\n\t}\n\treturn 0;\n\nout_free_pages:\n\tfor (i = 0; i < bp->b_page_count; i++)\n\t\t__free_page(bp->b_pages[i]);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "bp->b_pages[i]"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "size",
            "PAGE_SIZE - offset"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_page_found"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_page_retries"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_err",
          "args": [
            "NULL",
            "\"possible memory allocation deadlock in %s (mode:0x%x)\"",
            "__func__",
            "gfp_mask"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page == NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_mask"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_buf_get_pages",
          "args": [
            "bp",
            "page_count"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "214-233",
          "snippet": "STATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[0].bm_bn + bp->b_length"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_maps[0].bm_bn"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "bp->b_addr"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "bp->b_addr"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bp->b_addr"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "size",
            "KM_NOFS"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xb_to_gfp",
          "args": [
            "flags"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_buf_allocate_memory(\n\txfs_buf_t\t\t*bp,\n\tuint\t\t\tflags)\n{\n\tsize_t\t\t\tsize;\n\tsize_t\t\t\tnbytes, offset;\n\tgfp_t\t\t\tgfp_mask = xb_to_gfp(flags);\n\tunsigned short\t\tpage_count, i;\n\txfs_off_t\t\tstart, end;\n\tint\t\t\terror;\n\n\t/*\n\t * for buffers that are contained within a single page, just allocate\n\t * the memory from the heap - there's no need for the complexity of\n\t * page arrays to keep allocation down to order 0.\n\t */\n\tsize = BBTOB(bp->b_length);\n\tif (size < PAGE_SIZE) {\n\t\tbp->b_addr = kmem_alloc(size, KM_NOFS);\n\t\tif (!bp->b_addr) {\n\t\t\t/* low memory - use alloc_page loop instead */\n\t\t\tgoto use_alloc_page;\n\t\t}\n\n\t\tif (((unsigned long)(bp->b_addr + size - 1) & PAGE_MASK) !=\n\t\t    ((unsigned long)bp->b_addr & PAGE_MASK)) {\n\t\t\t/* b_addr spans two pages - use alloc_page instead */\n\t\t\tkmem_free(bp->b_addr);\n\t\t\tbp->b_addr = NULL;\n\t\t\tgoto use_alloc_page;\n\t\t}\n\t\tbp->b_offset = offset_in_page(bp->b_addr);\n\t\tbp->b_pages = bp->b_page_array;\n\t\tbp->b_pages[0] = virt_to_page(bp->b_addr);\n\t\tbp->b_page_count = 1;\n\t\tbp->b_flags |= _XBF_KMEM;\n\t\treturn 0;\n\t}\n\nuse_alloc_page:\n\tstart = BBTOB(bp->b_maps[0].bm_bn) >> PAGE_SHIFT;\n\tend = (BBTOB(bp->b_maps[0].bm_bn + bp->b_length) + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\tpage_count = end - start;\n\terror = _xfs_buf_get_pages(bp, page_count);\n\tif (unlikely(error))\n\t\treturn error;\n\n\toffset = bp->b_offset;\n\tbp->b_flags |= _XBF_PAGES;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tstruct page\t*page;\n\t\tuint\t\tretries = 0;\nretry:\n\t\tpage = alloc_page(gfp_mask);\n\t\tif (unlikely(page == NULL)) {\n\t\t\tif (flags & XBF_READ_AHEAD) {\n\t\t\t\tbp->b_page_count = i;\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_free_pages;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This could deadlock.\n\t\t\t *\n\t\t\t * But until all the XFS lowlevel code is revamped to\n\t\t\t * handle buffer allocation failures we can't do much.\n\t\t\t */\n\t\t\tif (!(++retries % 100))\n\t\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, gfp_mask);\n\n\t\t\tXFS_STATS_INC(xb_page_retries);\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tXFS_STATS_INC(xb_page_found);\n\n\t\tnbytes = min_t(size_t, size, PAGE_SIZE - offset);\n\t\tsize -= nbytes;\n\t\tbp->b_pages[i] = page;\n\t\toffset = 0;\n\t}\n\treturn 0;\n\nout_free_pages:\n\tfor (i = 0; i < bp->b_page_count; i++)\n\t\t__free_page(bp->b_pages[i]);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_buf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "255-280",
    "snippet": "void\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_buf_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_buf_zone",
            "bp"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_free_maps",
          "args": [
            "bp"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_free_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "138-146",
          "snippet": "static void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_xfs_buf_free_pages",
          "args": [
            "bp"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bp->b_addr"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unmap_ram",
          "args": [
            "bp->b_addr - bp->b_offset",
            "bp->b_page_count"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_is_vmapped",
          "args": [
            "bp"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_is_vmapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "61-73",
          "snippet": "static inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&bp->b_lru)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bp->b_lru"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_buf_free",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nvoid\nxfs_buf_free(\n\txfs_buf_t\t\t*bp)\n{\n\ttrace_xfs_buf_free(bp, _RET_IP_);\n\n\tASSERT(list_empty(&bp->b_lru));\n\n\tif (bp->b_flags & _XBF_PAGES) {\n\t\tuint\t\ti;\n\n\t\tif (xfs_buf_is_vmapped(bp))\n\t\t\tvm_unmap_ram(bp->b_addr - bp->b_offset,\n\t\t\t\t\tbp->b_page_count);\n\n\t\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\t\tstruct page\t*page = bp->b_pages[i];\n\n\t\t\t__free_page(page);\n\t\t}\n\t} else if (bp->b_flags & _XBF_KMEM)\n\t\tkmem_free(bp->b_addr);\n\t_xfs_buf_free_pages(bp);\n\txfs_buf_free_maps(bp);\n\tkmem_zone_free(xfs_buf_zone, bp);\n}"
  },
  {
    "function_name": "_xfs_buf_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "238-246",
    "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bp->b_pages"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
  },
  {
    "function_name": "_xfs_buf_get_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "214-233",
    "snippet": "STATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_pages",
            "0",
            "sizeof(struct page *) * page_count"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(struct page *) *\n\t\t\t\t\t\t page_count",
            "KM_NOFS"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC int\n_xfs_buf_get_pages(\n\txfs_buf_t\t\t*bp,\n\tint\t\t\tpage_count)\n{\n\t/* Make sure that we have a page list */\n\tif (bp->b_pages == NULL) {\n\t\tbp->b_page_count = page_count;\n\t\tif (page_count <= XB_PAGES) {\n\t\t\tbp->b_pages = bp->b_page_array;\n\t\t} else {\n\t\t\tbp->b_pages = kmem_alloc(sizeof(struct page *) *\n\t\t\t\t\t\t page_count, KM_NOFS);\n\t\t\tif (bp->b_pages == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(bp->b_pages, 0, sizeof(struct page *) * page_count);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "_xfs_buf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "148-208",
    "snippet": "struct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kmem_zone_t *xfs_buf_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_init",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xb_create"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&bp->b_waiters"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_pin_count",
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_buf_zone",
            "bp"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_maps",
          "args": [
            "bp",
            "nmaps"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "115-133",
          "snippet": "static int\nxfs_buf_get_maps(\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tmap_count)\n{\n\tASSERT(bp->b_maps == NULL);\n\tbp->b_map_count = map_count;\n\n\tif (map_count == 1) {\n\t\tbp->b_maps = &bp->__b_map;\n\t\treturn 0;\n\t}\n\n\tbp->b_maps = kmem_zalloc(map_count * sizeof(struct xfs_buf_map),\n\t\t\t\tKM_NOFS);\n\tif (!bp->b_maps)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\nxfs_buf_get_maps(\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tmap_count)\n{\n\tASSERT(bp->b_maps == NULL);\n\tbp->b_map_count = map_count;\n\n\tif (map_count == 1) {\n\t\tbp->b_maps = &bp->__b_map;\n\t\treturn 0;\n\t}\n\n\tbp->b_maps = kmem_zalloc(map_count * sizeof(struct xfs_buf_map),\n\t\t\t\tKM_NOFS);\n\tif (!bp->b_maps)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XB_SET_OWNER",
          "args": [
            "bp"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&bp->b_lock"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&bp->b_sema",
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&bp->b_rbnode"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bp->b_list"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bp->b_lru"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&bp->b_iowait"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_lru_ref",
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_hold",
            "1"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_buf_zone",
            "KM_NOFS"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nstruct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}"
  },
  {
    "function_name": "xfs_buf_free_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "138-146",
    "snippet": "static void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "bp->b_maps"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic void\nxfs_buf_free_maps(\n\tstruct xfs_buf\t*bp)\n{\n\tif (bp->b_maps != &bp->__b_map) {\n\t\tkmem_free(bp->b_maps);\n\t\tbp->b_maps = NULL;\n\t}\n}"
  },
  {
    "function_name": "xfs_buf_get_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "115-133",
    "snippet": "static int\nxfs_buf_get_maps(\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tmap_count)\n{\n\tASSERT(bp->b_maps == NULL);\n\tbp->b_map_count = map_count;\n\n\tif (map_count == 1) {\n\t\tbp->b_maps = &bp->__b_map;\n\t\treturn 0;\n\t}\n\n\tbp->b_maps = kmem_zalloc(map_count * sizeof(struct xfs_buf_map),\n\t\t\t\tKM_NOFS);\n\tif (!bp->b_maps)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "map_count * sizeof(struct xfs_buf_map)",
            "KM_NOFS"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_maps == NULL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic int\nxfs_buf_get_maps(\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tmap_count)\n{\n\tASSERT(bp->b_maps == NULL);\n\tbp->b_map_count = map_count;\n\n\tif (map_count == 1) {\n\t\tbp->b_maps = &bp->__b_map;\n\t\treturn 0;\n\t}\n\n\tbp->b_maps = kmem_zalloc(map_count * sizeof(struct xfs_buf_map),\n\t\t\t\tKM_NOFS);\n\tif (!bp->b_maps)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_buf_stale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "90-113",
    "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bp->b_hold) >= 1"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_hold"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bp->b_hold"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&bp->b_target->bt_lru",
            "&bp->b_lru"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_lru_ref",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bp->b_lock"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
  },
  {
    "function_name": "xfs_buf_vmap_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "75-80",
    "snippet": "static inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_vmap_len(\n\tstruct xfs_buf\t*bp)\n{\n\treturn (bp->b_page_count * PAGE_SIZE) - bp->b_offset;\n}"
  },
  {
    "function_name": "xfs_buf_is_vmapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
    "lines": "61-73",
    "snippet": "static inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/migrate.h>",
      "#include <linux/kthread.h>",
      "#include <linux/hash.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/percpu.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/bio.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic inline int\nxfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}"
  }
]