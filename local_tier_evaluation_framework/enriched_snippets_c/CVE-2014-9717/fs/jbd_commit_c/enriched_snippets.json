[
  {
    "function_name": "journal_commit_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "296-1021",
    "snippet": "void journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: commit %d complete, head %d\\n\"",
            "journal->j_commit_sequence",
            "journal->j_tail_sequence"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_end_commit",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_drop_transaction",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_drop_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "753-782",
          "snippet": "void __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "journal->j_average_commit_time"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(), start_time)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "start_time"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction == journal->j_committing_transaction"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_COMMIT_RECORD"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 8\\n\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "bh"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "53-80",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_refile_buffer",
          "args": [
            "jh"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_refile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2177-2217",
          "snippet": "void __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__journal_unfile_buffer(jh);\n\t\treturn;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__journal_temp_unlink_buffer(jh);\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __journal_file_buffer() must not take a\n\t * new one.\n\t */\n\tjh->b_transaction = jh->b_next_transaction;\n\tjh->b_next_transaction = NULL;\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"refile or unfile freed buffer\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_dirty(bh)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_insert_checkpoint",
          "args": [
            "jh",
            "commit_transaction"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_insert_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "721-741",
          "snippet": "void __journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjournal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjournal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"add to new checkpointing trans\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_freed",
          "args": [
            "bh"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "665-711",
          "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"remove from old cp transaction\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "jh->b_frozen_data",
            "bh->b_size"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "jh->b_committed_data",
            "bh->b_size"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_log_list == NULL"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_shadow_list == NULL"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_iobuf_list == NULL"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_checkpoint_list == NULL"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_buffers == NULL"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_sync_datalist == NULL"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 7\\n\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_abort",
          "args": [
            "journal",
            "err"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1759-1762",
          "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_write_commit_record",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_commit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "122-156",
          "snippet": "static int journal_write_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction)\n{\n\tstruct journal_head *descriptor;\n\tstruct buffer_head *bh;\n\tjournal_header_t *header;\n\tint ret;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tdescriptor = journal_get_descriptor_buffer(journal);\n\tif (!descriptor)\n\t\treturn 1;\n\n\tbh = jh2bh(descriptor);\n\n\theader = (journal_header_t *)(bh->b_data);\n\theader->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);\n\theader->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);\n\theader->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\n\tJBUFFER_TRACE(descriptor, \"write commit block\");\n\tset_buffer_dirty(bh);\n\n\tif (journal->j_flags & JFS_BARRIER)\n\t\tret = __sync_dirty_buffer(bh, WRITE_SYNC | WRITE_FLUSH_FUA);\n\telse\n\t\tret = sync_dirty_buffer(bh);\n\n\tput_bh(bh);\t\t/* One for getblk() */\n\tjournal_put_journal_head(descriptor);\n\n\treturn (ret == -EIO);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_write_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction)\n{\n\tstruct journal_head *descriptor;\n\tstruct buffer_head *bh;\n\tjournal_header_t *header;\n\tint ret;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tdescriptor = journal_get_descriptor_buffer(journal);\n\tif (!descriptor)\n\t\treturn 1;\n\n\tbh = jh2bh(descriptor);\n\n\theader = (journal_header_t *)(bh->b_data);\n\theader->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);\n\theader->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);\n\theader->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\n\tJBUFFER_TRACE(descriptor, \"write commit block\");\n\tset_buffer_dirty(bh);\n\n\tif (journal->j_flags & JFS_BARRIER)\n\t\tret = __sync_dirty_buffer(bh, WRITE_SYNC | WRITE_FLUSH_FUA);\n\telse\n\t\tret = sync_dirty_buffer(bh);\n\n\tput_bh(bh);\t\t/* One for getblk() */\n\tjournal_put_journal_head(descriptor);\n\n\treturn (ret == -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_COMMIT"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 6\\n\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unfile_buffer",
          "args": [
            "journal",
            "jh"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1637-1649",
          "snippet": "void journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"ph5: control buffer writeout done: unfile\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 5\\n\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_shadow_list == NULL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"brelse shadowed buffer\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&bh->b_state",
            "BH_Unshadow"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_file_buffer",
          "args": [
            "jh",
            "commit_transaction",
            "BJ_Forget"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2156-2164",
          "snippet": "void journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"file as BJ_Forget\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "buffer_jbddirty(bh)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "atomic_read(&bh->b_count) == 0"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"dumping temporary bh\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"ph4: unfile after journal write\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 4\\n\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_submit_bh",
          "args": [
            "write_op",
            "bh",
            "1 << BIO_SNAP_STABLE"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "_submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3000-3052",
          "snippet": "int _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_FLAG_LAST_TAG"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD: Submit %d IOs\\n\"",
            "bufs"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tagp",
            "journal->j_uuid",
            "16"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tag_flag"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "jh2bh(jh)->b_blocknr"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "new_jh"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "jh2bh(new_jh)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "new_jh"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_write_metadata_buffer",
          "args": [
            "commit_transaction",
            "jh",
            "&new_jh",
            "blocknr"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_metadata_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "302-419",
          "snippet": "int journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct journal_head **jh_out,\n\t\t\t\t  unsigned int blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct journal_head *new_jh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\n\tnew_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\tnew_jh = journal_add_journal_head(new_bh);\t/* This sleeps */\n\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd_alloc(bh_in->b_size, GFP_NOFS);\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_jh->b_transaction = NULL;\n\tnew_bh->b_size = jh2bh(jh_in)->b_size;\n\tnew_bh->b_bdev = transaction->t_journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*jh_out = new_jh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh_in);\n\n\tJBUFFER_TRACE(new_jh, \"file as BJ_IO\");\n\tjournal_file_buffer(new_jh, transaction, BJ_IO);\n\n\treturn do_escape | (done_copy_out << 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nint journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct journal_head **jh_out,\n\t\t\t\t  unsigned int blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct journal_head *new_jh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\n\tnew_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\tnew_jh = journal_add_journal_head(new_bh);\t/* This sleeps */\n\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd_alloc(bh_in->b_size, GFP_NOFS);\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, jh2bh(jh_in)->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_jh->b_transaction = NULL;\n\tnew_bh->b_size = jh2bh(jh_in)->b_size;\n\tnew_bh->b_bdev = transaction->t_journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*jh_out = new_jh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh_in);\n\n\tJBUFFER_TRACE(new_jh, \"file as BJ_IO\");\n\tjournal_file_buffer(new_jh, transaction, BJ_IO);\n\n\treturn do_escape | (done_copy_out << 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"ph3: write metadata\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_next_log_block",
          "args": [
            "journal",
            "&blocknr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "journal_next_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "648-662",
          "snippet": "int journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_next_log_block(journal_t *journal, unsigned int *retp)\n{\n\tunsigned int blocknr;\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\tspin_unlock(&journal->j_state_lock);\n\treturn journal_bmap(journal, blocknr, retp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"ph3: file as descriptor\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "commit_transaction->t_tid"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_DESCRIPTOR_BLOCK"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD: got buffer %llu (%p)\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "bh->b_data"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "708-728",
          "snippet": "struct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstruct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"JBD: get descriptor\\n\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "bufs == 0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_refile_buffer",
          "args": [
            "journal",
            "jh"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "journal_refile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2225-2237",
          "snippet": "void journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\t__journal_refile_buffer(jh);\n\tjbd_unlock_bh_state(bh);\n\tspin_unlock(&journal->j_list_lock);\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"journal is aborting: refile\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbddirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_commit_logging",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 3\\n\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_sync_datalist == NULL"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_write_revoke_records",
          "args": [
            "journal",
            "commit_transaction",
            "write_op"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "journal_write_revoke_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "530-564",
          "snippet": "void journal_write_revoke_records(journal_t *journal,\n\t\t\t\t  transaction_t *transaction, int write_op)\n{\n\tstruct journal_head *descriptor;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nvoid journal_write_revoke_records(journal_t *journal,\n\t\t\t\t  transaction_t *transaction, int write_op)\n{\n\tstruct journal_head *descriptor;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\"",
            "bdevname(journal->j_fs_dev, b)"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_fs_dev",
            "b"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_data_buffer",
          "args": [
            "bh"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "release_data_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "86-98",
          "snippet": "static void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inverted_lock",
          "args": [
            "journal",
            "bh"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "inverted_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "105-113",
          "snippet": "static int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "bh->b_page"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&bh->b_page->mapping->flags"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_submit_data_buffers",
          "args": [
            "journal",
            "commit_transaction",
            "write_op"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "journal_submit_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "182-288",
          "snippet": "static int journal_submit_data_buffers(journal_t *journal,\n\t\t\t\t       transaction_t *commit_transaction,\n\t\t\t\t       int write_op)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\tint locked;\n\tint bufs = 0;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint err = 0;\n\n\t/*\n\t * Whenever we unlock the journal and sleep, things can get added\n\t * onto ->t_sync_datalist, so we have to keep looping back to\n\t * write_out_data until we *know* that the list is empty.\n\t *\n\t * Cleanup any flushed data buffers from the data list.  Even in\n\t * abort mode, we want to flush this out as soon as possible.\n\t */\nwrite_out_data:\n\tcond_resched();\n\tspin_lock(&journal->j_list_lock);\n\n\twhile (commit_transaction->t_sync_datalist) {\n\t\tjh = commit_transaction->t_sync_datalist;\n\t\tbh = jh2bh(jh);\n\t\tlocked = 0;\n\n\t\t/* Get reference just to make sure buffer does not disappear\n\t\t * when we are forced to drop various locks */\n\t\tget_bh(bh);\n\t\t/* If the buffer is dirty, we need to submit IO and hence\n\t\t * we need the buffer lock. We try to lock the buffer without\n\t\t * blocking. If we fail, we need to drop j_list_lock and do\n\t\t * blocking lock_buffer().\n\t\t */\n\t\tif (buffer_dirty(bh)) {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tBUFFER_TRACE(bh, \"needs blocking lock\");\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\t/* Write out all data to prevent deadlocks */\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tlocked = 1;\n\t\t}\n\t\t/* We have to get bh_state lock. Again out of order, sigh. */\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\t/* Someone already cleaned up the buffer? */\n\t\tif (!buffer_jbd(bh) || bh2jh(bh) != jh\n\t\t\t|| jh->b_transaction != commit_transaction\n\t\t\t|| jh->b_jlist != BJ_SyncData) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"already cleaned up\");\n\t\t\trelease_data_buffer(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (locked && test_clear_buffer_dirty(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"needs writeout, adding to array\");\n\t\t\twbuf[bufs++] = bh;\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (bufs == journal->j_wbufsize) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tgoto write_out_data;\n\t\t\t}\n\t\t} else if (!locked && buffer_locked(bh)) {\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tput_bh(bh);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"writeout complete: unfile\");\n\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\terr = -EIO;\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\trelease_data_buffer(bh);\n\t\t}\n\n\t\tif (need_resched() || spin_needbreak(&journal->j_list_lock)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto write_out_data;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\ttrace_jbd_do_submit_data(journal, commit_transaction);\n\tjournal_do_submit_data(wbuf, bufs, write_op);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_data_buffers(journal_t *journal,\n\t\t\t\t       transaction_t *commit_transaction,\n\t\t\t\t       int write_op)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\tint locked;\n\tint bufs = 0;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint err = 0;\n\n\t/*\n\t * Whenever we unlock the journal and sleep, things can get added\n\t * onto ->t_sync_datalist, so we have to keep looping back to\n\t * write_out_data until we *know* that the list is empty.\n\t *\n\t * Cleanup any flushed data buffers from the data list.  Even in\n\t * abort mode, we want to flush this out as soon as possible.\n\t */\nwrite_out_data:\n\tcond_resched();\n\tspin_lock(&journal->j_list_lock);\n\n\twhile (commit_transaction->t_sync_datalist) {\n\t\tjh = commit_transaction->t_sync_datalist;\n\t\tbh = jh2bh(jh);\n\t\tlocked = 0;\n\n\t\t/* Get reference just to make sure buffer does not disappear\n\t\t * when we are forced to drop various locks */\n\t\tget_bh(bh);\n\t\t/* If the buffer is dirty, we need to submit IO and hence\n\t\t * we need the buffer lock. We try to lock the buffer without\n\t\t * blocking. If we fail, we need to drop j_list_lock and do\n\t\t * blocking lock_buffer().\n\t\t */\n\t\tif (buffer_dirty(bh)) {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tBUFFER_TRACE(bh, \"needs blocking lock\");\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\t/* Write out all data to prevent deadlocks */\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tlocked = 1;\n\t\t}\n\t\t/* We have to get bh_state lock. Again out of order, sigh. */\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\t/* Someone already cleaned up the buffer? */\n\t\tif (!buffer_jbd(bh) || bh2jh(bh) != jh\n\t\t\t|| jh->b_transaction != commit_transaction\n\t\t\t|| jh->b_jlist != BJ_SyncData) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"already cleaned up\");\n\t\t\trelease_data_buffer(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (locked && test_clear_buffer_dirty(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"needs writeout, adding to array\");\n\t\t\twbuf[bufs++] = bh;\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (bufs == journal->j_wbufsize) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tgoto write_out_data;\n\t\t\t}\n\t\t} else if (!locked && buffer_locked(bh)) {\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tput_bh(bh);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"writeout complete: unfile\");\n\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\terr = -EIO;\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\trelease_data_buffer(bh);\n\t\t}\n\n\t\tif (need_resched() || spin_needbreak(&journal->j_list_lock)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto write_out_data;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\ttrace_jbd_do_submit_data(journal, commit_transaction);\n\tjournal_do_submit_data(wbuf, bufs, write_op);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_waited",
            "commit_transaction->t_tid"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 2\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_commit_flushing",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_switch_revoke_table",
          "args": [
            "journal"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "journal_switch_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "513-524",
          "snippet": "void journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_clear_buffer_revoked_flags",
          "args": [
            "journal"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "484-507",
          "snippet": "void journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: commit phase 1\\n\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_clean_checkpoint_list",
          "args": [
            "journal"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_clean_checkpoint_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "605-643",
          "snippet": "int __journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret = 0;\n\tint released;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\tgoto out;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_list, &released);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t\tif (released)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list, &released);\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t} while (transaction != last_transaction);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret = 0;\n\tint released;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\tgoto out;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_list, &released);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t\tif (released)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list, &released);\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t} while (transaction != last_transaction);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_free",
          "args": [
            "jh->b_committed_data",
            "bh->b_size"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"reserved, unused: refile\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_updates",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_commit_locking",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "commit_transaction->t_state == T_RUNNING"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: starting commit of transaction %d\\n\"",
            "commit_transaction->t_tid"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_start_commit",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction == NULL"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction != NULL"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"superblock not updated\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_update_sb_log_tail",
          "args": [
            "journal",
            "journal->j_tail_sequence",
            "journal->j_tail",
            "WRITE_SYNC"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1108-1127",
          "snippet": "void journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nvoid journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"super block updated\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_commit_transaction(journal_t *journal)\n{\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh, *new_jh, *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned int blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tstruct blk_plug plug;\n\tint write_op = WRITE;\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior journal_flush? */\n\tif (journal->j_flags & JFS_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjournal_update_sb_log_tail(journal, journal->j_tail_sequence,\n\t\t\t\t\t   journal->j_tail, WRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd_commit_locking(journal, commit_transaction);\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (commit_transaction->t_updates) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (commit_transaction->t_updates) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (commit_transaction->t_outstanding_credits <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A journal_get_undo_access()+journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjournal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjournal_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjournal_switch_revoke_table(journal);\n\n\ttrace_jbd_commit_flushing(journal, commit_transaction);\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\tspin_unlock(&journal->j_state_lock);\n\n\tjbd_debug (3, \"JBD: commit phase 2\\n\");\n\n\tif (tid_geq(journal->j_commit_waited, commit_transaction->t_tid))\n\t\twrite_op = WRITE_SYNC;\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\tblk_start_plug(&plug);\n\terr = journal_submit_data_buffers(journal, commit_transaction,\n\t\t\t\t\t  write_op);\n\tblk_finish_plug(&plug);\n\n\t/*\n\t * Wait for all previously submitted IO to complete.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_locked_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_locked_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(bh))) {\n\t\t\tif (!trylock_page(bh->b_page)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tlock_page(bh->b_page);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tif (bh->b_page->mapping)\n\t\t\t\tset_bit(AS_EIO, &bh->b_page->mapping->flags);\n\n\t\t\tunlock_page(bh->b_page);\n\t\t\tSetPageError(bh->b_page);\n\t\t\terr = -EIO;\n\t\t}\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tput_bh(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_jbd(bh) && bh2jh(bh) == jh &&\n\t\t    jh->b_transaction == commit_transaction &&\n\t\t    jh->b_jlist == BJ_Locked)\n\t\t\t__journal_unfile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\trelease_data_buffer(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (err) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD: Detected IO errors while flushing file data \"\n\t\t\t\"on %s\\n\", bdevname(journal->j_fs_dev, b));\n\t\tif (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjournal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\tblk_start_plug(&plug);\n\n\tjournal_write_revoke_records(journal, commit_transaction, write_op);\n\n\t/*\n\t * If we found any dirty or locked buffers, then we should have\n\t * looped back up to the write_out_data label.  If there weren't\n\t * any then journal_clean_data_list should have wiped the list\n\t * clean by now, so check that it is in fact empty.\n\t */\n\tJ_ASSERT (commit_transaction->t_sync_datalist == NULL);\n\n\tjbd_debug (3, \"JBD: commit phase 3\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\tspin_unlock(&journal->j_state_lock);\n\n\ttrace_jbd_commit_logging(journal, commit_transaction);\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t commit_transaction->t_outstanding_credits);\n\n\tdescriptor = NULL;\n\tbufs = 0;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjournal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD: get descriptor\\n\");\n\n\t\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjournal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbh = jh2bh(descriptor);\n\t\t\tjbd_debug(4, \"JBD: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)bh->b_blocknr, bh->b_data);\n\t\t\theader = (journal_header_t *)&bh->b_data[0];\n\t\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = bh->b_size - sizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(bh);\n\t\t\tset_buffer_dirty(bh);\n\t\t\twbuf[bufs++] = bh;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(bh, \"ph3: file as descriptor\");\n\t\t\tjournal_file_buffer(descriptor, commit_transaction,\n\t\t\t\t\tBJ_LogCtl);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjournal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by journal_next_log_block() also.\n\t\t */\n\t\tcommit_transaction->t_outstanding_credits--;\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */\n\t\tget_bh(jh2bh(jh));\n\n\t\t/* Make a temporary IO buffer with which to write it out\n                   (this will requeue both the metadata buffer and the\n                   temporary IO buffer). new_bh goes on BJ_IO*/\n\n\t\tset_buffer_jwrite(jh2bh(jh));\n\t\t/*\n\t\t * akpm: journal_write_metadata_buffer() sets\n\t\t * new_bh->b_transaction to commit_transaction.\n\t\t * We need to clean this up before we release new_bh\n\t\t * (which is of type BJ_IO)\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\t      jh, &new_jh, blocknr);\n\t\tset_buffer_jwrite(jh2bh(new_jh));\n\t\twbuf[bufs++] = jh2bh(new_jh);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JFS_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JFS_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\ttag->t_blocknr = cpu_to_be32(jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be32(tag_flag);\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tspace_left -= sizeof(journal_block_tag_t);\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < sizeof(journal_block_tag_t) + 16) {\n\n\t\t\tjbd_debug(4, \"JBD: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);\n\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\t/*\n\t\t\t\t * In data=journal mode, here we can end up\n\t\t\t\t * writing pagecache data that might be\n\t\t\t\t * mmapped. Since we can't afford to clean the\n\t\t\t\t * page and set PageWriteback (see the comment\n\t\t\t\t * near the other use of _submit_bh()), the\n\t\t\t\t * data can change while the write is in\n\t\t\t\t * flight.  Tell the block layer to bounce the\n\t\t\t\t * bio pages if stable pages are required.\n\t\t\t\t */\n\t\t\t\t_submit_bh(write_op, bh, 1 << BIO_SNAP_STABLE);\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the t_iobuf_list queue.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD: commit phase 4\\n\");\n\n\t/*\n\t * akpm: these are BJ_IO, and j_list_lock is not needed.\n\t * See __journal_try_to_free_buffer.\n\t */\nwait_for_iobuf:\n\twhile (commit_transaction->t_iobuf_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_iobuf_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_iobuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_iobuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tclear_buffer_jwrite(bh);\n\n\t\tJBUFFER_TRACE(jh, \"ph4: unfile after journal write\");\n\t\tjournal_unfile_buffer(journal, jh);\n\n\t\t/*\n\t\t * ->t_iobuf_list should contain only dummy buffer_heads\n\t\t * which were created by journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to unlock and free the corresponding\n                   shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjournal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\t/*\n\t\t * Wake up any transactions which were waiting for this\n\t\t * IO to complete. The barrier must be here so that changes\n\t\t * by journal_file_buffer() take effect before wake_up_bit()\n\t\t * does the waitqueue check.\n\t\t */\n\t\tsmp_mb();\n\t\twake_up_bit(&bh->b_state, BH_Unshadow);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD: commit phase 5\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n wait_for_ctlbuf:\n\twhile (commit_transaction->t_log_list != NULL) {\n\t\tstruct buffer_head *bh;\n\n\t\tjh = commit_transaction->t_log_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\twait_on_buffer(bh);\n\t\t\tgoto wait_for_ctlbuf;\n\t\t}\n\t\tif (cond_resched())\n\t\t\tgoto wait_for_ctlbuf;\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjournal_unfile_buffer(journal, jh);\n\t\tjournal_put_journal_head(jh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD: commit phase 6\\n\");\n\n\t/* All metadata is written, now write commit record and do cleanup */\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_RECORD;\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (journal_write_commit_record(journal, commit_transaction))\n\t\terr = -EIO;\n\n\tif (err)\n\t\tjournal_abort(journal, err);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\tJ_ASSERT(commit_transaction->t_log_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction ||\n\t\t\tjh->b_transaction == journal->j_running_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\t__journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t * A buffer which has been freed while still being journaled by\n\t\t * a previous transaction.\n\t\t */\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather throughout in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile freed buffer\");\n\t\t__journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD: commit phase 8\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_RECORD);\n\n\tcommit_transaction->t_state = T_FINISHED;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time*3 +\n\t\t\t\tjournal->j_average_commit_time) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__journal_drop_transaction(journal, commit_transaction);\n\t} else {\n\t\tif (journal->j_checkpoint_transactions == NULL) {\n\t\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t\t} else {\n\t\t\tcommit_transaction->t_cpnext =\n\t\t\t\tjournal->j_checkpoint_transactions;\n\t\t\tcommit_transaction->t_cpprev =\n\t\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\t\tcommit_transaction;\n\t\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\ttrace_jbd_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twake_up(&journal->j_wait_done_commit);\n}"
  },
  {
    "function_name": "journal_submit_data_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "182-288",
    "snippet": "static int journal_submit_data_buffers(journal_t *journal,\n\t\t\t\t       transaction_t *commit_transaction,\n\t\t\t\t       int write_op)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\tint locked;\n\tint bufs = 0;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint err = 0;\n\n\t/*\n\t * Whenever we unlock the journal and sleep, things can get added\n\t * onto ->t_sync_datalist, so we have to keep looping back to\n\t * write_out_data until we *know* that the list is empty.\n\t *\n\t * Cleanup any flushed data buffers from the data list.  Even in\n\t * abort mode, we want to flush this out as soon as possible.\n\t */\nwrite_out_data:\n\tcond_resched();\n\tspin_lock(&journal->j_list_lock);\n\n\twhile (commit_transaction->t_sync_datalist) {\n\t\tjh = commit_transaction->t_sync_datalist;\n\t\tbh = jh2bh(jh);\n\t\tlocked = 0;\n\n\t\t/* Get reference just to make sure buffer does not disappear\n\t\t * when we are forced to drop various locks */\n\t\tget_bh(bh);\n\t\t/* If the buffer is dirty, we need to submit IO and hence\n\t\t * we need the buffer lock. We try to lock the buffer without\n\t\t * blocking. If we fail, we need to drop j_list_lock and do\n\t\t * blocking lock_buffer().\n\t\t */\n\t\tif (buffer_dirty(bh)) {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tBUFFER_TRACE(bh, \"needs blocking lock\");\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\t/* Write out all data to prevent deadlocks */\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tlocked = 1;\n\t\t}\n\t\t/* We have to get bh_state lock. Again out of order, sigh. */\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\t/* Someone already cleaned up the buffer? */\n\t\tif (!buffer_jbd(bh) || bh2jh(bh) != jh\n\t\t\t|| jh->b_transaction != commit_transaction\n\t\t\t|| jh->b_jlist != BJ_SyncData) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"already cleaned up\");\n\t\t\trelease_data_buffer(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (locked && test_clear_buffer_dirty(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"needs writeout, adding to array\");\n\t\t\twbuf[bufs++] = bh;\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (bufs == journal->j_wbufsize) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tgoto write_out_data;\n\t\t\t}\n\t\t} else if (!locked && buffer_locked(bh)) {\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tput_bh(bh);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"writeout complete: unfile\");\n\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\terr = -EIO;\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\trelease_data_buffer(bh);\n\t\t}\n\n\t\tif (need_resched() || spin_needbreak(&journal->j_list_lock)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto write_out_data;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\ttrace_jbd_do_submit_data(journal, commit_transaction);\n\tjournal_do_submit_data(wbuf, bufs, write_op);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_do_submit_data",
          "args": [
            "wbuf",
            "bufs",
            "write_op"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "journal_do_submit_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "158-177",
          "snippet": "static void journal_do_submit_data(struct buffer_head **wbuf, int bufs,\n\t\t\t\t   int write_op)\n{\n\tint i;\n\n\tfor (i = 0; i < bufs; i++) {\n\t\twbuf[i]->b_end_io = end_buffer_write_sync;\n\t\t/*\n\t\t * Here we write back pagecache data that may be mmaped. Since\n\t\t * we cannot afford to clean the page and set PageWriteback\n\t\t * here due to lock ordering (page lock ranks above transaction\n\t\t * start), the data can change while IO is in flight. Tell the\n\t\t * block layer it should bounce the bio pages if stable data\n\t\t * during write is required.\n\t\t *\n\t\t * We use up our safety reference in submit_bh().\n\t\t */\n\t\t_submit_bh(write_op, wbuf[i], 1 << BIO_SNAP_STABLE);\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void journal_do_submit_data(struct buffer_head **wbuf, int bufs,\n\t\t\t\t   int write_op)\n{\n\tint i;\n\n\tfor (i = 0; i < bufs; i++) {\n\t\twbuf[i]->b_end_io = end_buffer_write_sync;\n\t\t/*\n\t\t * Here we write back pagecache data that may be mmaped. Since\n\t\t * we cannot afford to clean the page and set PageWriteback\n\t\t * here due to lock ordering (page lock ranks above transaction\n\t\t * start), the data can change while IO is in flight. Tell the\n\t\t * block layer it should bounce the bio pages if stable data\n\t\t * during write is required.\n\t\t *\n\t\t * We use up our safety reference in submit_bh().\n\t\t */\n\t\t_submit_bh(write_op, wbuf[i], 1 << BIO_SNAP_STABLE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd_do_submit_data",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_data_buffer",
          "args": [
            "bh"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "release_data_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "86-98",
          "snippet": "static void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_unfile_buffer",
          "args": [
            "jh"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_unfile_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1630-1635",
          "snippet": "void __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_unfile_buffer(struct journal_head *jh)\n{\n\t__journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n\tjournal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"writeout complete: unfile\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_file_buffer",
          "args": [
            "jh",
            "commit_transaction",
            "BJ_Locked"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2078-2154",
          "snippet": "void __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid __journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__journal_temp_unlink_buffer(jh);\n\telse\n\t\tjournal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_SyncData:\n\t\tlist = &transaction->t_sync_datalist;\n\t\tbreak;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_IO:\n\t\tlist = &transaction->t_iobuf_list;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_LogCtl:\n\t\tlist = &transaction->t_log_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\tcase BJ_Locked:\n\t\tlist =  &transaction->t_locked_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_do_submit_data",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"needs writeout, adding to array\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"already cleaned up\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inverted_lock",
          "args": [
            "journal",
            "bh"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "inverted_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "105-113",
          "snippet": "static int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd_do_submit_data",
          "args": [
            "journal",
            "commit_transaction"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"needs blocking lock\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_submit_data_buffers(journal_t *journal,\n\t\t\t\t       transaction_t *commit_transaction,\n\t\t\t\t       int write_op)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\tint locked;\n\tint bufs = 0;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint err = 0;\n\n\t/*\n\t * Whenever we unlock the journal and sleep, things can get added\n\t * onto ->t_sync_datalist, so we have to keep looping back to\n\t * write_out_data until we *know* that the list is empty.\n\t *\n\t * Cleanup any flushed data buffers from the data list.  Even in\n\t * abort mode, we want to flush this out as soon as possible.\n\t */\nwrite_out_data:\n\tcond_resched();\n\tspin_lock(&journal->j_list_lock);\n\n\twhile (commit_transaction->t_sync_datalist) {\n\t\tjh = commit_transaction->t_sync_datalist;\n\t\tbh = jh2bh(jh);\n\t\tlocked = 0;\n\n\t\t/* Get reference just to make sure buffer does not disappear\n\t\t * when we are forced to drop various locks */\n\t\tget_bh(bh);\n\t\t/* If the buffer is dirty, we need to submit IO and hence\n\t\t * we need the buffer lock. We try to lock the buffer without\n\t\t * blocking. If we fail, we need to drop j_list_lock and do\n\t\t * blocking lock_buffer().\n\t\t */\n\t\tif (buffer_dirty(bh)) {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tBUFFER_TRACE(bh, \"needs blocking lock\");\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\t/* Write out all data to prevent deadlocks */\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\t}\n\t\t\tlocked = 1;\n\t\t}\n\t\t/* We have to get bh_state lock. Again out of order, sigh. */\n\t\tif (!inverted_lock(journal, bh)) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t}\n\t\t/* Someone already cleaned up the buffer? */\n\t\tif (!buffer_jbd(bh) || bh2jh(bh) != jh\n\t\t\t|| jh->b_transaction != commit_transaction\n\t\t\t|| jh->b_jlist != BJ_SyncData) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\tBUFFER_TRACE(bh, \"already cleaned up\");\n\t\t\trelease_data_buffer(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (locked && test_clear_buffer_dirty(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"needs writeout, adding to array\");\n\t\t\twbuf[bufs++] = bh;\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (bufs == journal->j_wbufsize) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\ttrace_jbd_do_submit_data(journal,\n\t\t\t\t\t\t     commit_transaction);\n\t\t\t\tjournal_do_submit_data(wbuf, bufs, write_op);\n\t\t\t\tbufs = 0;\n\t\t\t\tgoto write_out_data;\n\t\t\t}\n\t\t} else if (!locked && buffer_locked(bh)) {\n\t\t\t__journal_file_buffer(jh, commit_transaction,\n\t\t\t\t\t\tBJ_Locked);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tput_bh(bh);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"writeout complete: unfile\");\n\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\terr = -EIO;\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tif (locked)\n\t\t\t\tunlock_buffer(bh);\n\t\t\trelease_data_buffer(bh);\n\t\t}\n\n\t\tif (need_resched() || spin_needbreak(&journal->j_list_lock)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto write_out_data;\n\t\t}\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\ttrace_jbd_do_submit_data(journal, commit_transaction);\n\tjournal_do_submit_data(wbuf, bufs, write_op);\n\n\treturn err;\n}"
  },
  {
    "function_name": "journal_do_submit_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "158-177",
    "snippet": "static void journal_do_submit_data(struct buffer_head **wbuf, int bufs,\n\t\t\t\t   int write_op)\n{\n\tint i;\n\n\tfor (i = 0; i < bufs; i++) {\n\t\twbuf[i]->b_end_io = end_buffer_write_sync;\n\t\t/*\n\t\t * Here we write back pagecache data that may be mmaped. Since\n\t\t * we cannot afford to clean the page and set PageWriteback\n\t\t * here due to lock ordering (page lock ranks above transaction\n\t\t * start), the data can change while IO is in flight. Tell the\n\t\t * block layer it should bounce the bio pages if stable data\n\t\t * during write is required.\n\t\t *\n\t\t * We use up our safety reference in submit_bh().\n\t\t */\n\t\t_submit_bh(write_op, wbuf[i], 1 << BIO_SNAP_STABLE);\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_submit_bh",
          "args": [
            "write_op",
            "wbuf[i]",
            "1 << BIO_SNAP_STABLE"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "_submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3000-3052",
          "snippet": "int _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void journal_do_submit_data(struct buffer_head **wbuf, int bufs,\n\t\t\t\t   int write_op)\n{\n\tint i;\n\n\tfor (i = 0; i < bufs; i++) {\n\t\twbuf[i]->b_end_io = end_buffer_write_sync;\n\t\t/*\n\t\t * Here we write back pagecache data that may be mmaped. Since\n\t\t * we cannot afford to clean the page and set PageWriteback\n\t\t * here due to lock ordering (page lock ranks above transaction\n\t\t * start), the data can change while IO is in flight. Tell the\n\t\t * block layer it should bounce the bio pages if stable data\n\t\t * during write is required.\n\t\t *\n\t\t * We use up our safety reference in submit_bh().\n\t\t */\n\t\t_submit_bh(write_op, wbuf[i], 1 << BIO_SNAP_STABLE);\n\t}\n}"
  },
  {
    "function_name": "journal_write_commit_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "122-156",
    "snippet": "static int journal_write_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction)\n{\n\tstruct journal_head *descriptor;\n\tstruct buffer_head *bh;\n\tjournal_header_t *header;\n\tint ret;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tdescriptor = journal_get_descriptor_buffer(journal);\n\tif (!descriptor)\n\t\treturn 1;\n\n\tbh = jh2bh(descriptor);\n\n\theader = (journal_header_t *)(bh->b_data);\n\theader->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);\n\theader->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);\n\theader->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\n\tJBUFFER_TRACE(descriptor, \"write commit block\");\n\tset_buffer_dirty(bh);\n\n\tif (journal->j_flags & JFS_BARRIER)\n\t\tret = __sync_dirty_buffer(bh, WRITE_SYNC | WRITE_FLUSH_FUA);\n\telse\n\t\tret = sync_dirty_buffer(bh);\n\n\tput_bh(bh);\t\t/* One for getblk() */\n\tjournal_put_journal_head(descriptor);\n\n\treturn (ret == -EIO);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "descriptor"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "bh",
            "WRITE_SYNC | WRITE_FLUSH_FUA"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3133-3150",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "descriptor",
            "\"write commit block\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "commit_transaction->t_tid"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_COMMIT_BLOCK"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "708-728",
          "snippet": "struct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstruct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_write_commit_record(journal_t *journal,\n\t\t\t\t\ttransaction_t *commit_transaction)\n{\n\tstruct journal_head *descriptor;\n\tstruct buffer_head *bh;\n\tjournal_header_t *header;\n\tint ret;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 0;\n\n\tdescriptor = journal_get_descriptor_buffer(journal);\n\tif (!descriptor)\n\t\treturn 1;\n\n\tbh = jh2bh(descriptor);\n\n\theader = (journal_header_t *)(bh->b_data);\n\theader->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);\n\theader->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);\n\theader->h_sequence = cpu_to_be32(commit_transaction->t_tid);\n\n\tJBUFFER_TRACE(descriptor, \"write commit block\");\n\tset_buffer_dirty(bh);\n\n\tif (journal->j_flags & JFS_BARRIER)\n\t\tret = __sync_dirty_buffer(bh, WRITE_SYNC | WRITE_FLUSH_FUA);\n\telse\n\t\tret = sync_dirty_buffer(bh);\n\n\tput_bh(bh);\t\t/* One for getblk() */\n\tjournal_put_journal_head(descriptor);\n\n\treturn (ret == -EIO);\n}"
  },
  {
    "function_name": "inverted_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "105-113",
    "snippet": "static int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_trylock_bh_state",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int inverted_lock(journal_t *journal, struct buffer_head *bh)\n{\n\tif (!jbd_trylock_bh_state(bh)) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "release_data_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "86-98",
    "snippet": "static void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "bh"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
          "lines": "53-80",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_freed",
          "args": [
            "bh"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "buffer_dirty(bh)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_data_buffer(struct buffer_head *bh)\n{\n\tif (buffer_freed(bh)) {\n\t\tWARN_ON_ONCE(buffer_dirty(bh));\n\t\tclear_buffer_freed(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_req(bh);\n\t\tbh->b_bdev = NULL;\n\t\trelease_buffer_page(bh);\n\t} else\n\t\tput_bh(bh);\n}"
  },
  {
    "function_name": "release_buffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "53-80",
    "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page;\n\n\tif (buffer_dirty(bh))\n\t\tgoto nope;\n\tif (atomic_read(&bh->b_count) != 1)\n\t\tgoto nope;\n\tpage = bh->b_page;\n\tif (!page)\n\t\tgoto nope;\n\tif (page->mapping)\n\t\tgoto nope;\n\n\t/* OK, it's a truncated page */\n\tif (!trylock_page(page))\n\t\tgoto nope;\n\n\tpage_cache_get(page);\n\t__brelse(bh);\n\ttry_to_free_buffers(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn;\n\nnope:\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "journal_end_buffer_io_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/commit.c",
    "lines": "29-37",
    "snippet": "static void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void journal_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n}"
  }
]