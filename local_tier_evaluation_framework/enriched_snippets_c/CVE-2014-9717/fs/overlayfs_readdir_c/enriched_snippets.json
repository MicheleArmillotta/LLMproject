[
  {
    "function_name": "ovl_cleanup_whiteouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "535-557",
    "snippet": "void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&upper->d_inode->i_mutex"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "upper->d_inode",
            "dentry"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup_whiteouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "535-557",
          "snippet": "void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\"",
            "upper->d_name.name",
            "p->len",
            "p->name",
            "(int) PTR_ERR(dentry)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "p->name",
            "upper",
            "p->len"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "list",
            "l_node"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&upper->d_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}"
  },
  {
    "function_name": "ovl_check_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "507-533",
    "snippet": "int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct ovl_cache_entry *p;\n\n\terr = ovl_dir_read_merged(dentry, list);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\n\tlist_for_each_entry(p, list, l_node) {\n\t\tif (p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = -ENOTEMPTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "list",
            "l_node"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dir_read_merged",
          "args": [
            "dentry",
            "list"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_read_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "263-294",
          "snippet": "static int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct ovl_cache_entry *p;\n\n\terr = ovl_dir_read_merged(dentry, list);\n\tif (err)\n\t\treturn err;\n\n\terr = 0;\n\n\tlist_for_each_entry(p, list, l_node) {\n\t\tif (p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tif (p->name[0] == '.') {\n\t\t\tif (p->len == 1)\n\t\t\t\tcontinue;\n\t\t\tif (p->len == 2 && p->name[1] == '.')\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = -ENOTEMPTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "473-496",
    "snippet": "static int ovl_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct path realpath;\n\tstruct file *realfile;\n\tstruct ovl_dir_file *od;\n\tenum ovl_path_type type;\n\n\tod = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\ttype = ovl_path_real(file->f_path.dentry, &realpath);\n\trealfile = ovl_path_open(&realpath, file->f_flags);\n\tif (IS_ERR(realfile)) {\n\t\tkfree(od);\n\t\treturn PTR_ERR(realfile);\n\t}\n\tod->realfile = realfile;\n\tod->is_real = !OVL_TYPE_MERGE(type);\n\tod->is_upper = OVL_TYPE_UPPER(type);\n\tfile->private_data = od;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE",
          "args": [
            "type"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realfile"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "od"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realfile"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_open",
          "args": [
            "&realpath",
            "file->f_flags"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "462-465",
          "snippet": "struct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "file->f_path.dentry",
            "&realpath"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ovl_dir_file)",
            "GFP_KERNEL"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct path realpath;\n\tstruct file *realfile;\n\tstruct ovl_dir_file *od;\n\tenum ovl_path_type type;\n\n\tod = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\ttype = ovl_path_real(file->f_path.dentry, &realpath);\n\trealfile = ovl_path_open(&realpath, file->f_flags);\n\tif (IS_ERR(realfile)) {\n\t\tkfree(od);\n\t\treturn PTR_ERR(realfile);\n\t}\n\tod->realfile = realfile;\n\tod->is_real = !OVL_TYPE_MERGE(type);\n\tod->is_upper = OVL_TYPE_UPPER(type);\n\tfile->private_data = od;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "456-471",
    "snippet": "static int ovl_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tif (od->cache) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tovl_cache_put(od, file->f_path.dentry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tfput(od->realfile);\n\tif (od->upperfile)\n\t\tfput(od->upperfile);\n\tkfree(od);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "od"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "od->upperfile"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_put",
          "args": [
            "od",
            "file->f_path.dentry"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "193-206",
          "snippet": "static void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tif (od->cache) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tovl_cache_put(od, file->f_path.dentry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tfput(od->realfile);\n\tif (od->upperfile)\n\t\tfput(od->upperfile);\n\tkfree(od);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_dir_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "416-454",
    "snippet": "static int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct file *realfile = od->realfile;\n\n\t/*\n\t * Need to check if we started out being a lower dir, but got copied up\n\t */\n\tif (!od->is_upper && OVL_TYPE_UPPER(ovl_path_type(dentry))) {\n\t\tstruct inode *inode = file_inode(file);\n\n\t\trealfile = lockless_dereference(od->upperfile);\n\t\tif (!realfile) {\n\t\t\tstruct path upperpath;\n\n\t\t\tovl_path_upper(dentry, &upperpath);\n\t\t\trealfile = ovl_path_open(&upperpath, O_RDONLY);\n\t\t\tsmp_mb__before_spinlock();\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\tif (!od->upperfile) {\n\t\t\t\tif (IS_ERR(realfile)) {\n\t\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\t\treturn PTR_ERR(realfile);\n\t\t\t\t}\n\t\t\t\tod->upperfile = realfile;\n\t\t\t} else {\n\t\t\t\t/* somebody has beaten us to it */\n\t\t\t\tif (!IS_ERR(realfile))\n\t\t\t\t\tfput(realfile);\n\t\t\t\trealfile = od->upperfile;\n\t\t\t}\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t}\n\t}\n\n\treturn vfs_fsync_range(realfile, start, end, datasync);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_fsync_range",
          "args": [
            "realfile",
            "start",
            "end",
            "datasync"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "178-191",
          "snippet": "int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tspin_unlock(&inode->i_lock);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n\treturn file->f_op->fsync(file, start, end, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tspin_unlock(&inode->i_lock);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n\treturn file->f_op->fsync(file, start, end, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "realfile"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realfile"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realfile"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realfile"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_spinlock",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_open",
          "args": [
            "&upperpath",
            "O_RDONLY"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "462-465",
          "snippet": "struct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "&upperpath"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockless_dereference",
          "args": [
            "od->upperfile"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "ovl_path_type(dentry)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "dentry"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct file *realfile = od->realfile;\n\n\t/*\n\t * Need to check if we started out being a lower dir, but got copied up\n\t */\n\tif (!od->is_upper && OVL_TYPE_UPPER(ovl_path_type(dentry))) {\n\t\tstruct inode *inode = file_inode(file);\n\n\t\trealfile = lockless_dereference(od->upperfile);\n\t\tif (!realfile) {\n\t\t\tstruct path upperpath;\n\n\t\t\tovl_path_upper(dentry, &upperpath);\n\t\t\trealfile = ovl_path_open(&upperpath, O_RDONLY);\n\t\t\tsmp_mb__before_spinlock();\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\tif (!od->upperfile) {\n\t\t\t\tif (IS_ERR(realfile)) {\n\t\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\t\treturn PTR_ERR(realfile);\n\t\t\t\t}\n\t\t\t\tod->upperfile = realfile;\n\t\t\t} else {\n\t\t\t\t/* somebody has beaten us to it */\n\t\t\t\tif (!IS_ERR(realfile))\n\t\t\t\t\tfput(realfile);\n\t\t\t\trealfile = od->upperfile;\n\t\t\t}\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t}\n\t}\n\n\treturn vfs_fsync_range(realfile, start, end, datasync);\n}"
  },
  {
    "function_name": "ovl_dir_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "376-414",
    "snippet": "static loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)\n{\n\tloff_t res;\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tmutex_lock(&file_inode(file)->i_mutex);\n\tif (!file->f_pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real) {\n\t\tres = vfs_llseek(od->realfile, offset, origin);\n\t\tfile->f_pos = od->realfile->f_pos;\n\t} else {\n\t\tres = -EINVAL;\n\n\t\tswitch (origin) {\n\t\tcase SEEK_CUR:\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_SET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (offset < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tif (od->cache)\n\t\t\t\tovl_seek_cursor(od, offset);\n\t\t}\n\t\tres = offset;\n\t}\nout_unlock:\n\tmutex_unlock(&file_inode(file)->i_mutex);\n\n\treturn res;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file_inode(file)->i_mutex"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_seek_cursor",
          "args": [
            "od",
            "offset"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_seek_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "296-308",
          "snippet": "static void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_llseek",
          "args": [
            "od->realfile",
            "offset",
            "origin"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "255-265",
          "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dir_reset",
          "args": [
            "file"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "246-261",
          "snippet": "static void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file_inode(file)->i_mutex"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)\n{\n\tloff_t res;\n\tstruct ovl_dir_file *od = file->private_data;\n\n\tmutex_lock(&file_inode(file)->i_mutex);\n\tif (!file->f_pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real) {\n\t\tres = vfs_llseek(od->realfile, offset, origin);\n\t\tfile->f_pos = od->realfile->f_pos;\n\t} else {\n\t\tres = -EINVAL;\n\n\t\tswitch (origin) {\n\t\tcase SEEK_CUR:\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_SET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (offset < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tif (od->cache)\n\t\t\t\tovl_seek_cursor(od, offset);\n\t\t}\n\t\tres = offset;\n\t}\nout_unlock:\n\tmutex_unlock(&file_inode(file)->i_mutex);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ovl_iterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "342-374",
    "snippet": "static int ovl_iterate(struct file *file, struct dir_context *ctx)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct ovl_cache_entry *p;\n\n\tif (!ctx->pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real)\n\t\treturn iterate_dir(od->realfile, ctx);\n\n\tif (!od->cache) {\n\t\tstruct ovl_dir_cache *cache;\n\n\t\tcache = ovl_cache_get(dentry);\n\t\tif (IS_ERR(cache))\n\t\t\treturn PTR_ERR(cache);\n\n\t\tod->cache = cache;\n\t\tovl_seek_cursor(od, ctx->pos);\n\t}\n\n\twhile (od->cursor != &od->cache->entries) {\n\t\tp = list_entry(od->cursor, struct ovl_cache_entry, l_node);\n\t\tif (!p->is_whiteout)\n\t\t\tif (!dir_emit(ctx, p->name, p->len, p->ino, p->type))\n\t\t\t\tbreak;\n\t\tod->cursor = p->l_node.next;\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "p->name",
            "p->len",
            "p->ino",
            "p->type"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "od->cursor",
            "structovl_cache_entry",
            "l_node"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_seek_cursor",
          "args": [
            "od",
            "ctx->pos"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_seek_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "296-308",
          "snippet": "static void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cache"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cache"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_get",
          "args": [
            "dentry"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "310-340",
          "snippet": "static struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\n{\n\tint res;\n\tstruct ovl_dir_cache *cache;\n\n\tcache = ovl_dir_cache(dentry);\n\tif (cache && ovl_dentry_version_get(dentry) == cache->version) {\n\t\tcache->refcount++;\n\t\treturn cache;\n\t}\n\tovl_set_dir_cache(dentry, NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcache->refcount = 1;\n\tINIT_LIST_HEAD(&cache->entries);\n\n\tres = ovl_dir_read_merged(dentry, &cache->entries);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\n\tcache->version = ovl_dentry_version_get(dentry);\n\tovl_set_dir_cache(dentry, cache);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\n{\n\tint res;\n\tstruct ovl_dir_cache *cache;\n\n\tcache = ovl_dir_cache(dentry);\n\tif (cache && ovl_dentry_version_get(dentry) == cache->version) {\n\t\tcache->refcount++;\n\t\treturn cache;\n\t}\n\tovl_set_dir_cache(dentry, NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcache->refcount = 1;\n\tINIT_LIST_HEAD(&cache->entries);\n\n\tres = ovl_dir_read_merged(dentry, &cache->entries);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\n\tcache->version = ovl_dentry_version_get(dentry);\n\tovl_set_dir_cache(dentry, cache);\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "od->realfile",
            "ctx"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dir_reset",
          "args": [
            "file"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "246-261",
          "snippet": "static void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_iterate(struct file *file, struct dir_context *ctx)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct ovl_cache_entry *p;\n\n\tif (!ctx->pos)\n\t\tovl_dir_reset(file);\n\n\tif (od->is_real)\n\t\treturn iterate_dir(od->realfile, ctx);\n\n\tif (!od->cache) {\n\t\tstruct ovl_dir_cache *cache;\n\n\t\tcache = ovl_cache_get(dentry);\n\t\tif (IS_ERR(cache))\n\t\t\treturn PTR_ERR(cache);\n\n\t\tod->cache = cache;\n\t\tovl_seek_cursor(od, ctx->pos);\n\t}\n\n\twhile (od->cursor != &od->cache->entries) {\n\t\tp = list_entry(od->cursor, struct ovl_cache_entry, l_node);\n\t\tif (!p->is_whiteout)\n\t\t\tif (!dir_emit(ctx, p->name, p->len, p->ino, p->type))\n\t\t\t\tbreak;\n\t\tod->cursor = p->l_node.next;\n\t\tctx->pos++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_cache_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "310-340",
    "snippet": "static struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\n{\n\tint res;\n\tstruct ovl_dir_cache *cache;\n\n\tcache = ovl_dir_cache(dentry);\n\tif (cache && ovl_dentry_version_get(dentry) == cache->version) {\n\t\tcache->refcount++;\n\t\treturn cache;\n\t}\n\tovl_set_dir_cache(dentry, NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcache->refcount = 1;\n\tINIT_LIST_HEAD(&cache->entries);\n\n\tres = ovl_dir_read_merged(dentry, &cache->entries);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\n\tcache->version = ovl_dentry_version_get(dentry);\n\tovl_set_dir_cache(dentry, cache);\n\n\treturn cache;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_set_dir_cache",
          "args": [
            "dentry",
            "cache"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_dir_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "164-169",
          "snippet": "void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_get",
          "args": [
            "dentry"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "231-237",
          "snippet": "u64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nu64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_free",
          "args": [
            "&cache->entries"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "182-191",
          "snippet": "void ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dir_read_merged",
          "args": [
            "dentry",
            "&cache->entries"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_read_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "263-294",
          "snippet": "static int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->entries"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ovl_dir_cache)",
            "GFP_KERNEL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dir_cache",
          "args": [
            "dentry"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "157-162",
          "snippet": "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\n{\n\tint res;\n\tstruct ovl_dir_cache *cache;\n\n\tcache = ovl_dir_cache(dentry);\n\tif (cache && ovl_dentry_version_get(dentry) == cache->version) {\n\t\tcache->refcount++;\n\t\treturn cache;\n\t}\n\tovl_set_dir_cache(dentry, NULL);\n\n\tcache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcache->refcount = 1;\n\tINIT_LIST_HEAD(&cache->entries);\n\n\tres = ovl_dir_read_merged(dentry, &cache->entries);\n\tif (res) {\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t\treturn ERR_PTR(res);\n\t}\n\n\tcache->version = ovl_dentry_version_get(dentry);\n\tovl_set_dir_cache(dentry, cache);\n\n\treturn cache;\n}"
  },
  {
    "function_name": "ovl_seek_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "296-308",
    "snippet": "static void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "p",
            "&od->cache->entries"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\n{\n\tstruct list_head *p;\n\tloff_t off = 0;\n\n\tlist_for_each(p, &od->cache->entries) {\n\t\tif (off >= pos)\n\t\t\tbreak;\n\t\toff++;\n\t}\n\t/* Cursor is safe since the cache is stable */\n\tod->cursor = p;\n}"
  },
  {
    "function_name": "ovl_dir_read_merged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "263-294",
    "snippet": "static int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rdd.middle"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dir_read",
          "args": [
            "&realpath",
            "&rdd"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_read_merged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "263-294",
          "snippet": "static int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rdd.middle",
            "rdd.list"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_next",
          "args": [
            "idx",
            "dentry",
            "&realpath"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "314-329",
          "snippet": "int ovl_path_next(int idx, struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tBUG_ON(idx < 0);\n\tif (idx == 0) {\n\t\tovl_path_upper(dentry, path);\n\t\tif (path->dentry)\n\t\t\treturn oe->numlower ? 1 : -1;\n\t\tidx++;\n\t}\n\tBUG_ON(idx > oe->numlower);\n\t*path = oe->lowerstack[idx - 1];\n\n\treturn (idx < oe->numlower) ? idx + 1 : -1;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_path_next(int idx, struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tBUG_ON(idx < 0);\n\tif (idx == 0) {\n\t\tovl_path_upper(dentry, path);\n\t\tif (path->dentry)\n\t\t\treturn oe->numlower ? 1 : -1;\n\t\tidx++;\n\t}\n\tBUG_ON(idx > oe->numlower);\n\t*path = oe->lowerstack[idx - 1];\n\n\treturn (idx < oe->numlower) ? idx + 1 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\n{\n\tint err;\n\tstruct path realpath;\n\tstruct ovl_readdir_data rdd = {\n\t\t.ctx.actor = ovl_fill_merge,\n\t\t.list = list,\n\t\t.root = RB_ROOT,\n\t\t.is_merge = false,\n\t};\n\tint idx, next;\n\n\tfor (idx = 0; idx != -1; idx = next) {\n\t\tnext = ovl_path_next(idx, dentry, &realpath);\n\n\t\tif (next != -1) {\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Insert lowest layer entries before upper ones, this\n\t\t\t * allows offsets to be reasonably constant\n\t\t\t */\n\t\t\tlist_add(&rdd.middle, rdd.list);\n\t\t\trdd.is_merge = true;\n\t\t\terr = ovl_dir_read(&realpath, &rdd);\n\t\t\tlist_del(&rdd.middle);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_dir_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "246-261",
    "snippet": "static void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE",
          "args": [
            "type"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!od->is_real && !OVL_TYPE_MERGE(type)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_MERGE",
          "args": [
            "type"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_put",
          "args": [
            "od",
            "dentry"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "193-206",
          "snippet": "static void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_version_get",
          "args": [
            "dentry"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_version_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "231-237",
          "snippet": "u64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nu64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "dentry"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_dir_reset(struct file *file)\n{\n\tstruct ovl_dir_file *od = file->private_data;\n\tstruct ovl_dir_cache *cache = od->cache;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (cache && ovl_dentry_version_get(dentry) != cache->version) {\n\t\tovl_cache_put(od, dentry);\n\t\tod->cache = NULL;\n\t\tod->cursor = NULL;\n\t}\n\tWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\n\tif (od->is_real && OVL_TYPE_MERGE(type))\n\t\tod->is_real = false;\n}"
  },
  {
    "function_name": "ovl_dir_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "222-244",
    "snippet": "static inline int ovl_dir_read(struct path *realpath,\n\t\t\t       struct ovl_readdir_data *rdd)\n{\n\tstruct file *realfile;\n\tint err;\n\n\trealfile = ovl_path_open(realpath, O_RDONLY | O_DIRECTORY);\n\tif (IS_ERR(realfile))\n\t\treturn PTR_ERR(realfile);\n\n\trdd->dir = realpath->dentry;\n\trdd->ctx.pos = 0;\n\tdo {\n\t\trdd->count = 0;\n\t\trdd->err = 0;\n\t\terr = iterate_dir(realfile, &rdd->ctx);\n\t\tif (err >= 0)\n\t\t\terr = rdd->err;\n\t} while (!err && rdd->count);\n\tfput(realfile);\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "realfile"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "realfile",
            "&rdd->ctx"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realfile"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realfile"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_open",
          "args": [
            "realpath",
            "O_RDONLY | O_DIRECTORY"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "462-465",
          "snippet": "struct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int ovl_dir_read(struct path *realpath,\n\t\t\t       struct ovl_readdir_data *rdd)\n{\n\tstruct file *realfile;\n\tint err;\n\n\trealfile = ovl_path_open(realpath, O_RDONLY | O_DIRECTORY);\n\tif (IS_ERR(realfile))\n\t\treturn PTR_ERR(realfile);\n\n\trdd->dir = realpath->dentry;\n\trdd->ctx.pos = 0;\n\tdo {\n\t\trdd->count = 0;\n\t\trdd->err = 0;\n\t\terr = iterate_dir(realfile, &rdd->ctx);\n\t\tif (err >= 0)\n\t\t\terr = rdd->err;\n\t} while (!err && rdd->count);\n\tfput(realfile);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_fill_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "208-220",
    "snippet": "static int ovl_fill_merge(struct dir_context *ctx, const char *name,\n\t\t\t  int namelen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\tstruct ovl_readdir_data *rdd =\n\t\tcontainer_of(ctx, struct ovl_readdir_data, ctx);\n\n\trdd->count++;\n\tif (!rdd->is_merge)\n\t\treturn ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);\n\telse\n\t\treturn ovl_fill_lower(rdd, name, namelen, offset, ino, d_type);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_fill_lower",
          "args": [
            "rdd",
            "name",
            "namelen",
            "offset",
            "ino",
            "d_type"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_fill_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "162-180",
          "snippet": "static int ovl_fill_lower(struct ovl_readdir_data *rdd,\n\t\t\t  const char *name, int namelen,\n\t\t\t  loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\n\tp = ovl_cache_entry_find(&rdd->root, name, namelen);\n\tif (p) {\n\t\tlist_move_tail(&p->l_node, &rdd->middle);\n\t} else {\n\t\tp = ovl_cache_entry_new(rdd->dir, name, namelen, ino, d_type);\n\t\tif (p == NULL)\n\t\t\trdd->err = -ENOMEM;\n\t\telse\n\t\t\tlist_add_tail(&p->l_node, &rdd->middle);\n\t}\n\n\treturn rdd->err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_fill_lower(struct ovl_readdir_data *rdd,\n\t\t\t  const char *name, int namelen,\n\t\t\t  loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\n\tp = ovl_cache_entry_find(&rdd->root, name, namelen);\n\tif (p) {\n\t\tlist_move_tail(&p->l_node, &rdd->middle);\n\t} else {\n\t\tp = ovl_cache_entry_new(rdd->dir, name, namelen, ino, d_type);\n\t\tif (p == NULL)\n\t\t\trdd->err = -ENOMEM;\n\t\telse\n\t\t\tlist_add_tail(&p->l_node, &rdd->middle);\n\t}\n\n\treturn rdd->err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_add_rb",
          "args": [
            "rdd",
            "name",
            "namelen",
            "ino",
            "d_type"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_add_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "128-160",
          "snippet": "static int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\n\t\t\t\t  const char *name, int len, u64 ino,\n\t\t\t\t  unsigned int d_type)\n{\n\tstruct rb_node **newp = &rdd->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ovl_cache_entry *p;\n\n\twhile (*newp) {\n\t\tint cmp;\n\t\tstruct ovl_cache_entry *tmp;\n\n\t\tparent = *newp;\n\t\ttmp = ovl_cache_entry_from_node(*newp);\n\t\tcmp = strncmp(name, tmp->name, len);\n\t\tif (cmp > 0)\n\t\t\tnewp = &tmp->node.rb_right;\n\t\telse if (cmp < 0 || len < tmp->len)\n\t\t\tnewp = &tmp->node.rb_left;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tp = ovl_cache_entry_new(rdd->dir, name, len, ino, d_type);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&p->l_node, rdd->list);\n\trb_link_node(&p->node, parent, newp);\n\trb_insert_color(&p->node, &rdd->root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\n\t\t\t\t  const char *name, int len, u64 ino,\n\t\t\t\t  unsigned int d_type)\n{\n\tstruct rb_node **newp = &rdd->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ovl_cache_entry *p;\n\n\twhile (*newp) {\n\t\tint cmp;\n\t\tstruct ovl_cache_entry *tmp;\n\n\t\tparent = *newp;\n\t\ttmp = ovl_cache_entry_from_node(*newp);\n\t\tcmp = strncmp(name, tmp->name, len);\n\t\tif (cmp > 0)\n\t\t\tnewp = &tmp->node.rb_right;\n\t\telse if (cmp < 0 || len < tmp->len)\n\t\t\tnewp = &tmp->node.rb_left;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tp = ovl_cache_entry_new(rdd->dir, name, len, ino, d_type);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&p->l_node, rdd->list);\n\trb_link_node(&p->node, parent, newp);\n\trb_insert_color(&p->node, &rdd->root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structovl_readdir_data",
            "ctx"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_fill_merge(struct dir_context *ctx, const char *name,\n\t\t\t  int namelen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\tstruct ovl_readdir_data *rdd =\n\t\tcontainer_of(ctx, struct ovl_readdir_data, ctx);\n\n\trdd->count++;\n\tif (!rdd->is_merge)\n\t\treturn ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);\n\telse\n\t\treturn ovl_fill_lower(rdd, name, namelen, offset, ino, d_type);\n}"
  },
  {
    "function_name": "ovl_cache_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "193-206",
    "snippet": "static void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_free",
          "args": [
            "&cache->entries"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "182-191",
          "snippet": "void ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_set_dir_cache",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_dir_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "164-169",
          "snippet": "void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dir_cache",
          "args": [
            "dentry"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dir_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "157-162",
          "snippet": "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cache->refcount <= 0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}"
  },
  {
    "function_name": "ovl_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "182-191",
    "snippet": "void ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "list",
            "l_node"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cache_free(struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\tstruct ovl_cache_entry *n;\n\n\tlist_for_each_entry_safe(p, n, list, l_node)\n\t\tkfree(p);\n\n\tINIT_LIST_HEAD(list);\n}"
  },
  {
    "function_name": "ovl_fill_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "162-180",
    "snippet": "static int ovl_fill_lower(struct ovl_readdir_data *rdd,\n\t\t\t  const char *name, int namelen,\n\t\t\t  loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\n\tp = ovl_cache_entry_find(&rdd->root, name, namelen);\n\tif (p) {\n\t\tlist_move_tail(&p->l_node, &rdd->middle);\n\t} else {\n\t\tp = ovl_cache_entry_new(rdd->dir, name, namelen, ino, d_type);\n\t\tif (p == NULL)\n\t\t\trdd->err = -ENOMEM;\n\t\telse\n\t\t\tlist_add_tail(&p->l_node, &rdd->middle);\n\t}\n\n\treturn rdd->err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&p->l_node",
            "&rdd->middle"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_new",
          "args": [
            "rdd->dir",
            "name",
            "namelen",
            "ino",
            "d_type"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "82-126",
          "snippet": "static struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&p->l_node",
            "&rdd->middle"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_find",
          "args": [
            "&rdd->root",
            "name",
            "namelen"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "61-80",
          "snippet": "static struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\n\t\t\t\t\t\t    const char *name, int len)\n{\n\tstruct rb_node *node = root->rb_node;\n\tint cmp;\n\n\twhile (node) {\n\t\tstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\n\n\t\tcmp = strncmp(name, p->name, len);\n\t\tif (cmp > 0)\n\t\t\tnode = p->node.rb_right;\n\t\telse if (cmp < 0 || len < p->len)\n\t\t\tnode = p->node.rb_left;\n\t\telse\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\n\t\t\t\t\t\t    const char *name, int len)\n{\n\tstruct rb_node *node = root->rb_node;\n\tint cmp;\n\n\twhile (node) {\n\t\tstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\n\n\t\tcmp = strncmp(name, p->name, len);\n\t\tif (cmp > 0)\n\t\t\tnode = p->node.rb_right;\n\t\telse if (cmp < 0 || len < p->len)\n\t\t\tnode = p->node.rb_left;\n\t\telse\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_fill_lower(struct ovl_readdir_data *rdd,\n\t\t\t  const char *name, int namelen,\n\t\t\t  loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\n\tp = ovl_cache_entry_find(&rdd->root, name, namelen);\n\tif (p) {\n\t\tlist_move_tail(&p->l_node, &rdd->middle);\n\t} else {\n\t\tp = ovl_cache_entry_new(rdd->dir, name, namelen, ino, d_type);\n\t\tif (p == NULL)\n\t\t\trdd->err = -ENOMEM;\n\t\telse\n\t\t\tlist_add_tail(&p->l_node, &rdd->middle);\n\t}\n\n\treturn rdd->err;\n}"
  },
  {
    "function_name": "ovl_cache_entry_add_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "128-160",
    "snippet": "static int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\n\t\t\t\t  const char *name, int len, u64 ino,\n\t\t\t\t  unsigned int d_type)\n{\n\tstruct rb_node **newp = &rdd->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ovl_cache_entry *p;\n\n\twhile (*newp) {\n\t\tint cmp;\n\t\tstruct ovl_cache_entry *tmp;\n\n\t\tparent = *newp;\n\t\ttmp = ovl_cache_entry_from_node(*newp);\n\t\tcmp = strncmp(name, tmp->name, len);\n\t\tif (cmp > 0)\n\t\t\tnewp = &tmp->node.rb_right;\n\t\telse if (cmp < 0 || len < tmp->len)\n\t\t\tnewp = &tmp->node.rb_left;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tp = ovl_cache_entry_new(rdd->dir, name, len, ino, d_type);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&p->l_node, rdd->list);\n\trb_link_node(&p->node, parent, newp);\n\trb_insert_color(&p->node, &rdd->root);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&p->node",
            "&rdd->root"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&p->node",
            "parent",
            "newp"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&p->l_node",
            "rdd->list"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_new",
          "args": [
            "rdd->dir",
            "name",
            "len",
            "ino",
            "d_type"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "82-126",
          "snippet": "static struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "tmp->name",
            "len"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_from_node",
          "args": [
            "*newp"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_from_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "56-59",
          "snippet": "static struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\n\t\t\t\t  const char *name, int len, u64 ino,\n\t\t\t\t  unsigned int d_type)\n{\n\tstruct rb_node **newp = &rdd->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ovl_cache_entry *p;\n\n\twhile (*newp) {\n\t\tint cmp;\n\t\tstruct ovl_cache_entry *tmp;\n\n\t\tparent = *newp;\n\t\ttmp = ovl_cache_entry_from_node(*newp);\n\t\tcmp = strncmp(name, tmp->name, len);\n\t\tif (cmp > 0)\n\t\t\tnewp = &tmp->node.rb_right;\n\t\telse if (cmp < 0 || len < tmp->len)\n\t\t\tnewp = &tmp->node.rb_left;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tp = ovl_cache_entry_new(rdd->dir, name, len, ino, d_type);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&p->l_node, rdd->list);\n\trb_link_node(&p->node, parent, newp);\n\trb_insert_color(&p->node, &rdd->root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_cache_entry_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "82-126",
    "snippet": "static struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_is_whiteout",
          "args": [
            "dentry"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "239-244",
          "snippet": "bool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "dir",
            "len"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_DAC_OVERRIDE"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p->name",
            "name",
            "len"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\n\t\t\t\t\t\t   const char *name, int len,\n\t\t\t\t\t\t   u64 ino, unsigned int d_type)\n{\n\tstruct ovl_cache_entry *p;\n\tsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\n\n\tp = kmalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tmemcpy(p->name, name, len);\n\tp->name[len] = '\\0';\n\tp->len = len;\n\tp->type = d_type;\n\tp->ino = ino;\n\tp->is_whiteout = false;\n\n\tif (d_type == DT_CHR) {\n\t\tstruct dentry *dentry;\n\t\tconst struct cred *old_cred;\n\t\tstruct cred *override_cred;\n\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred) {\n\t\t\tkfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * CAP_DAC_OVERRIDE for lookup\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\told_cred = override_creds(override_cred);\n\n\t\tdentry = lookup_one_len(name, dir, len);\n\t\tif (!IS_ERR(dentry)) {\n\t\t\tp->is_whiteout = ovl_is_whiteout(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "ovl_cache_entry_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "61-80",
    "snippet": "static struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\n\t\t\t\t\t\t    const char *name, int len)\n{\n\tstruct rb_node *node = root->rb_node;\n\tint cmp;\n\n\twhile (node) {\n\t\tstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\n\n\t\tcmp = strncmp(name, p->name, len);\n\t\tif (cmp > 0)\n\t\t\tnode = p->node.rb_right;\n\t\telse if (cmp < 0 || len < p->len)\n\t\t\tnode = p->node.rb_left;\n\t\telse\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "p->name",
            "len"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_cache_entry_from_node",
          "args": [
            "node"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_entry_from_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "56-59",
          "snippet": "static struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\n\t\t\t\t\t\t    const char *name, int len)\n{\n\tstruct rb_node *node = root->rb_node;\n\tint cmp;\n\n\twhile (node) {\n\t\tstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\n\n\t\tcmp = strncmp(name, p->name, len);\n\t\tif (cmp > 0)\n\t\t\tnode = p->node.rb_right;\n\t\telse if (cmp < 0 || len < p->len)\n\t\t\tnode = p->node.rb_left;\n\t\telse\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ovl_cache_entry_from_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
    "lines": "56-59",
    "snippet": "static struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "n",
            "structovl_cache_entry",
            "node"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\n{\n\treturn container_of(n, struct ovl_cache_entry, node);\n}"
  }
]