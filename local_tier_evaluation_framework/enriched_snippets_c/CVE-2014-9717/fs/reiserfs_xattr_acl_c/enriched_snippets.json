[
  {
    "function_name": "reiserfs_acl_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "398-407",
    "snippet": "int reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_posixacl",
          "args": [
            "inode->i_sb"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}"
  },
  {
    "function_name": "reiserfs_cache_default_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "365-393",
    "snippet": "int reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_nblocks",
          "args": [
            "inode",
            "size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "53-61",
          "snippet": "static inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOURNAL_BLOCKS_PER_OBJECT",
          "args": [
            "inode->i_sb"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_jcreate_nblocks",
          "args": [
            "inode"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_jcreate_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "75-86",
          "snippet": "static inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_acl_size",
          "args": [
            "acl->a_count"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_acl_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/acl.h",
          "lines": "21-31",
          "snippet": "static inline size_t reiserfs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    count * sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    4 * sizeof(reiserfs_acl_entry_short) +\n\t\t    (count - 4) * sizeof(reiserfs_acl_entry);\n\t}\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/init.h>\n\nstatic inline size_t reiserfs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    count * sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    4 * sizeof(reiserfs_acl_entry_short) +\n\t\t    (count - 4) * sizeof(reiserfs_acl_entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "180-228",
          "snippet": "struct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS) {\n\t\t\tset_cached_acl(inode, type, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\tkfree(value);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS) {\n\t\t\tset_cached_acl(inode, type, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\tkfree(value);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}"
  },
  {
    "function_name": "reiserfs_inherit_default_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "301-352",
    "snippet": "int\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reiserfs_set_acl",
          "args": [
            "th",
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "236-295",
          "snippet": "static int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dir"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dir"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}"
  },
  {
    "function_name": "__reiserfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "236-295",
    "snippet": "static int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_set_handle",
          "args": [
            "th",
            "inode",
            "name",
            "value",
            "size",
            "0"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "497-594",
          "snippet": "int\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "value"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "value"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_posix_acl_to_disk",
          "args": [
            "acl",
            "&size"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_posix_acl_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "124-172",
          "snippet": "static void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
  },
  {
    "function_name": "reiserfs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "180-228",
    "snippet": "struct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS) {\n\t\t\tset_cached_acl(inode, type, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\tkfree(value);\n\treturn acl;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_posix_acl_from_disk",
          "args": [
            "value",
            "retval"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_posix_acl_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "54-119",
          "snippet": "static struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_get",
          "args": [
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "630-732",
          "snippet": "int\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "size"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\n{\n\tchar *name, *value;\n\tstruct posix_acl *acl;\n\tint size;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = reiserfs_xattr_get(inode, name, NULL, 0);\n\tif (size < 0) {\n\t\tif (size == -ENODATA || size == -ENOSYS) {\n\t\t\tset_cached_acl(inode, type, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_PTR(size);\n\t}\n\n\tvalue = kmalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretval = reiserfs_xattr_get(inode, name, value, size);\n\tif (retval == -ENODATA || retval == -ENOSYS) {\n\t\t/*\n\t\t * This shouldn't actually happen as it should have\n\t\t * been caught above.. but just in case\n\t\t */\n\t\tacl = NULL;\n\t} else if (retval < 0) {\n\t\tacl = ERR_PTR(retval);\n\t} else {\n\t\tacl = reiserfs_posix_acl_from_disk(value, retval);\n\t}\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\tkfree(value);\n\treturn acl;\n}"
  },
  {
    "function_name": "reiserfs_posix_acl_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "124-172",
    "snippet": "static void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext_acl"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns, acl_e->e_gid)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "acl_e->e_gid"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns, acl_e->e_uid)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "acl_e->e_uid"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[n].e_perm"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[n].e_tag"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REISERFS_ACL_VERSION"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry)",
            "GFP_NOFS"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_acl_size",
          "args": [
            "acl->a_count"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_acl_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/acl.h",
          "lines": "21-31",
          "snippet": "static inline size_t reiserfs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    count * sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    4 * sizeof(reiserfs_acl_entry_short) +\n\t\t    (count - 4) * sizeof(reiserfs_acl_entry);\n\t}\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/init.h>\n\nstatic inline size_t reiserfs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    count * sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(reiserfs_acl_header) +\n\t\t    4 * sizeof(reiserfs_acl_entry_short) +\n\t\t    (count - 4) * sizeof(reiserfs_acl_entry);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic void *reiserfs_posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\n{\n\treiserfs_acl_header *ext_acl;\n\tchar *e;\n\tint n;\n\n\t*size = reiserfs_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(reiserfs_acl_header) +\n\t\t\t\t\t\t  acl->a_count *\n\t\t\t\t\t\t  sizeof(reiserfs_acl_entry),\n\t\t\t\t\t\t  GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(reiserfs_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\n\t\tentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(reiserfs_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "reiserfs_posix_acl_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "54-119",
    "snippet": "static struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_perm"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_NOFS"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_acl_count",
          "args": [
            "size"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_acl_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/acl.h",
          "lines": "33-47",
          "snippet": "static inline int reiserfs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(reiserfs_acl_header);\n\ts = size - 4 * sizeof(reiserfs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(reiserfs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(reiserfs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(reiserfs_acl_entry) + 4;\n\t}\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/init.h>\n\nstatic inline int reiserfs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(reiserfs_acl_header);\n\ts = size - 4 * sizeof(reiserfs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(reiserfs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(reiserfs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(reiserfs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(reiserfs_acl_entry) + 4;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REISERFS_ACL_VERSION"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic struct posix_acl *reiserfs_posix_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(reiserfs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (((reiserfs_acl_header *) value)->a_version !=\n\t    cpu_to_le32(REISERFS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(reiserfs_acl_header);\n\tcount = reiserfs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\treiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\n\t\tif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t    sizeof(reiserfs_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid = \n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(reiserfs_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "reiserfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
    "lines": "19-49",
    "snippet": "int\nreiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error, error2;\n\tstruct reiserfs_transaction_handle th;\n\tsize_t jcreate_blocks;\n\tint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\n\n\n\t/*\n\t * Pessimism: We can't assume that anything from the xattr root up\n\t * has been created.\n\t */\n\n\tjcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, size) * 2;\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jcreate_blocks);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0) {\n\t\terror = __reiserfs_set_acl(&th, inode, type, acl);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror2 = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error2)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reiserfs_set_acl",
          "args": [
            "&th",
            "inode",
            "type",
            "acl"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "236-295",
          "snippet": "static int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nstatic int\n__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\n\t/*\n\t * Ensure that the inode gets dirtied if we're only using\n\t * the mode bits and an old ACL didn't exist. We don't need\n\t * to check if the inode is hashed here since we won't get\n\t * called by reiserfs_inherit_default_acl().\n\t */\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\n\tkfree(value);\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jcreate_blocks"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_nblocks",
          "args": [
            "inode",
            "size"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "53-61",
          "snippet": "static inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_jcreate_nblocks",
          "args": [
            "inode"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_jcreate_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "75-86",
          "snippet": "static inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint\nreiserfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error, error2;\n\tstruct reiserfs_transaction_handle th;\n\tsize_t jcreate_blocks;\n\tint size = acl ? posix_acl_xattr_size(acl->a_count) : 0;\n\n\n\t/*\n\t * Pessimism: We can't assume that anything from the xattr root up\n\t * has been created.\n\t */\n\n\tjcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, size) * 2;\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jcreate_blocks);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0) {\n\t\terror = __reiserfs_set_acl(&th, inode, type, acl);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror2 = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error2)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
  }
]