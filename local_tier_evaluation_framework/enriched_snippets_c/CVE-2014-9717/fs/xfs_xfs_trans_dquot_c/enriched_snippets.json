[
  {
    "function_name": "xfs_trans_free_dqinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "879-887",
    "snippet": "void\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_qm_dqtrxzone",
            "tp->t_dqinfo"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}"
  },
  {
    "function_name": "xfs_trans_alloc_dqinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "872-877",
    "snippet": "STATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_qm_dqtrxzone",
            "KM_SLEEP"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}"
  },
  {
    "function_name": "xfs_trans_log_quotaoff_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "863-870",
    "snippet": "void\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_quotaoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*qlp)\n{\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tqlp->qql_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
  },
  {
    "function_name": "xfs_trans_get_qoff_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "837-855",
    "snippet": "xfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_add_item",
          "args": [
            "tp",
            "&q->qql_item"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "651-668",
          "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "q != NULL"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_qoff_logitem_init",
          "args": [
            "tp->t_mountp",
            "startqoff",
            "flags"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_qoff_logitem_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "427-443",
          "snippet": "struct xfs_qoff_logitem *\nxfs_qm_qoff_logitem_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_qoff_logitem\t*start,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_qoff_logitem\t*qf;\n\n\tqf = kmem_zalloc(sizeof(struct xfs_qoff_logitem), KM_SLEEP);\n\n\txfs_log_item_init(mp, &qf->qql_item, XFS_LI_QUOTAOFF, start ?\n\t\t\t&xfs_qm_qoffend_logitem_ops : &xfs_qm_qoff_logitem_ops);\n\tqf->qql_item.li_mountp = mp;\n\tqf->qql_start_lip = start;\n\tqf->qql_flags = flags;\n\treturn qf;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_item_ops xfs_qm_qoffend_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoffend_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};",
            "static const struct xfs_item_ops xfs_qm_qoff_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoff_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_item_ops xfs_qm_qoffend_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoffend_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};\nstatic const struct xfs_item_ops xfs_qm_qoff_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoff_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};\n\nstruct xfs_qoff_logitem *\nxfs_qm_qoff_logitem_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_qoff_logitem\t*start,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_qoff_logitem\t*qf;\n\n\tqf = kmem_zalloc(sizeof(struct xfs_qoff_logitem), KM_SLEEP);\n\n\txfs_log_item_init(mp, &qf->qql_item, XFS_LI_QUOTAOFF, start ?\n\t\t\t&xfs_qm_qoffend_logitem_ops : &xfs_qm_qoff_logitem_ops);\n\tqf->qql_item.li_mountp = mp;\n\tqf->qql_start_lip = start;\n\tqf->qql_flags = flags;\n\treturn qf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp != NULL"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nxfs_qoff_logitem_t *\nxfs_trans_get_qoff_item(\n\txfs_trans_t\t\t*tp,\n\txfs_qoff_logitem_t\t*startqoff,\n\tuint\t\t\tflags)\n{\n\txfs_qoff_logitem_t\t*q;\n\n\tASSERT(tp != NULL);\n\n\tq = xfs_qm_qoff_logitem_init(tp->t_mountp, startqoff, flags);\n\tASSERT(q != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &q->qql_item);\n\treturn q;\n}"
  },
  {
    "function_name": "xfs_trans_reserve_quota_nblks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "802-832",
    "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_bydquots",
          "args": [
            "tp",
            "mp",
            "ip->i_udquot",
            "ip->i_gdquot",
            "ip->i_pdquot",
            "nblks",
            "ninos",
            "flags"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_is_quota_inode(&mp->m_sb, ip->i_ino)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&mp->m_sb",
            "ip->i_ino"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
  },
  {
    "function_name": "xfs_trans_reserve_quota_bydquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "740-794",
    "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_dqresv",
          "args": [
            "tp",
            "mp",
            "udqp",
            "-nblks",
            "-ninos",
            "flags"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dqresv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "585-725",
          "snippet": "STATIC int\nxfs_trans_dqresv(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\tlong\t\tnblks,\n\tlong\t\tninos,\n\tuint\t\tflags)\n{\n\txfs_qcnt_t\thardlimit;\n\txfs_qcnt_t\tsoftlimit;\n\ttime_t\t\ttimer;\n\txfs_qwarncnt_t\twarns;\n\txfs_qwarncnt_t\twarnlimit;\n\txfs_qcnt_t\ttotal_count;\n\txfs_qcnt_t\t*resbcountp;\n\txfs_quotainfo_t\t*q = mp->m_quotainfo;\n\n\n\txfs_dqlock(dqp);\n\n\tif (flags & XFS_TRANS_DQ_RES_BLKS) {\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_bhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_bsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_btimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_bwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_bwarnlimit;\n\t\tresbcountp = &dqp->q_res_bcount;\n\t} else {\n\t\tASSERT(flags & XFS_TRANS_DQ_RES_RTBLKS);\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_rtb_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_rtbhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_rtb_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_rtbsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_rtbwarnlimit;\n\t\tresbcountp = &dqp->q_res_rtbcount;\n\t}\n\n\tif ((flags & XFS_QMOPT_FORCE_RES) == 0 &&\n\t    dqp->q_core.d_id &&\n\t    ((XFS_IS_UQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISUDQ(dqp)) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISGDQ(dqp)) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISPDQ(dqp)))) {\n\t\tif (nblks > 0) {\n\t\t\t/*\n\t\t\t * dquot is locked already. See if we'd go over the\n\t\t\t * hardlimit or exceed the timelimit if we allocate\n\t\t\t * nblks.\n\t\t\t */\n\t\t\ttotal_count = *resbcountp + nblks;\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t    (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_BSOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BSOFTWARN);\n\t\t\t}\n\t\t}\n\t\tif (ninos > 0) {\n\t\t\ttotal_count = be64_to_cpu(dqp->q_core.d_icount) + ninos;\n\t\t\ttimer = be32_to_cpu(dqp->q_core.d_itimer);\n\t\t\twarns = be16_to_cpu(dqp->q_core.d_iwarns);\n\t\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_iwarnlimit;\n\t\t\thardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\t\t\tif (!hardlimit)\n\t\t\t\thardlimit = q->qi_ihardlimit;\n\t\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\t\t\tif (!softlimit)\n\t\t\t\tsoftlimit = q->qi_isoftlimit;\n\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif  ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t     (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_ISOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_ISOFTWARN);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Change the reservation, but not the actual usage.\n\t * Note that q_res_bcount = q_core.d_bcount + resv\n\t */\n\t(*resbcountp) += (xfs_qcnt_t)nblks;\n\tif (ninos != 0)\n\t\tdqp->q_res_icount += (xfs_qcnt_t)ninos;\n\n\t/*\n\t * note the reservation amt in the trans struct too,\n\t * so that the transaction knows how much was reserved by\n\t * it against this particular dquot.\n\t * We don't do this when we are reserving for a delayed allocation,\n\t * because we don't have the luxury of a transaction envelope then.\n\t */\n\tif (tp) {\n\t\tASSERT(tp->t_dqinfo);\n\t\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\t\tif (nblks != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    flags & XFS_QMOPT_RESBLK_MASK,\n\t\t\t\t\t    nblks);\n\t\tif (ninos != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    XFS_TRANS_DQ_RES_INOS,\n\t\t\t\t\t    ninos);\n\t}\n\tASSERT(dqp->q_res_bcount >= be64_to_cpu(dqp->q_core.d_bcount));\n\tASSERT(dqp->q_res_rtbcount >= be64_to_cpu(dqp->q_core.d_rtbcount));\n\tASSERT(dqp->q_res_icount >= be64_to_cpu(dqp->q_core.d_icount));\n\n\txfs_dqunlock(dqp);\n\treturn 0;\n\nerror_return:\n\txfs_dqunlock(dqp);\n\tif (flags & XFS_QMOPT_ENOSPC)\n\t\treturn -ENOSPC;\n\treturn -EDQUOT;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\nSTATIC struct;\n\nSTATIC int\nxfs_trans_dqresv(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\tlong\t\tnblks,\n\tlong\t\tninos,\n\tuint\t\tflags)\n{\n\txfs_qcnt_t\thardlimit;\n\txfs_qcnt_t\tsoftlimit;\n\ttime_t\t\ttimer;\n\txfs_qwarncnt_t\twarns;\n\txfs_qwarncnt_t\twarnlimit;\n\txfs_qcnt_t\ttotal_count;\n\txfs_qcnt_t\t*resbcountp;\n\txfs_quotainfo_t\t*q = mp->m_quotainfo;\n\n\n\txfs_dqlock(dqp);\n\n\tif (flags & XFS_TRANS_DQ_RES_BLKS) {\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_bhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_bsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_btimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_bwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_bwarnlimit;\n\t\tresbcountp = &dqp->q_res_bcount;\n\t} else {\n\t\tASSERT(flags & XFS_TRANS_DQ_RES_RTBLKS);\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_rtb_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_rtbhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_rtb_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_rtbsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_rtbwarnlimit;\n\t\tresbcountp = &dqp->q_res_rtbcount;\n\t}\n\n\tif ((flags & XFS_QMOPT_FORCE_RES) == 0 &&\n\t    dqp->q_core.d_id &&\n\t    ((XFS_IS_UQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISUDQ(dqp)) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISGDQ(dqp)) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISPDQ(dqp)))) {\n\t\tif (nblks > 0) {\n\t\t\t/*\n\t\t\t * dquot is locked already. See if we'd go over the\n\t\t\t * hardlimit or exceed the timelimit if we allocate\n\t\t\t * nblks.\n\t\t\t */\n\t\t\ttotal_count = *resbcountp + nblks;\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t    (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_BSOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BSOFTWARN);\n\t\t\t}\n\t\t}\n\t\tif (ninos > 0) {\n\t\t\ttotal_count = be64_to_cpu(dqp->q_core.d_icount) + ninos;\n\t\t\ttimer = be32_to_cpu(dqp->q_core.d_itimer);\n\t\t\twarns = be16_to_cpu(dqp->q_core.d_iwarns);\n\t\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_iwarnlimit;\n\t\t\thardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\t\t\tif (!hardlimit)\n\t\t\t\thardlimit = q->qi_ihardlimit;\n\t\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\t\t\tif (!softlimit)\n\t\t\t\tsoftlimit = q->qi_isoftlimit;\n\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif  ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t     (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_ISOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_ISOFTWARN);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Change the reservation, but not the actual usage.\n\t * Note that q_res_bcount = q_core.d_bcount + resv\n\t */\n\t(*resbcountp) += (xfs_qcnt_t)nblks;\n\tif (ninos != 0)\n\t\tdqp->q_res_icount += (xfs_qcnt_t)ninos;\n\n\t/*\n\t * note the reservation amt in the trans struct too,\n\t * so that the transaction knows how much was reserved by\n\t * it against this particular dquot.\n\t * We don't do this when we are reserving for a delayed allocation,\n\t * because we don't have the luxury of a transaction envelope then.\n\t */\n\tif (tp) {\n\t\tASSERT(tp->t_dqinfo);\n\t\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\t\tif (nblks != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    flags & XFS_QMOPT_RESBLK_MASK,\n\t\t\t\t\t    nblks);\n\t\tif (ninos != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    XFS_TRANS_DQ_RES_INOS,\n\t\t\t\t\t    ninos);\n\t}\n\tASSERT(dqp->q_res_bcount >= be64_to_cpu(dqp->q_core.d_bcount));\n\tASSERT(dqp->q_res_rtbcount >= be64_to_cpu(dqp->q_core.d_rtbcount));\n\tASSERT(dqp->q_res_icount >= be64_to_cpu(dqp->q_core.d_icount));\n\n\txfs_dqunlock(dqp);\n\treturn 0;\n\nerror_return:\n\txfs_dqunlock(dqp);\n\tif (flags & XFS_QMOPT_ENOSPC)\n\t\treturn -ENOSPC;\n\treturn -EDQUOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_QMOPT_RESBLK_MASK"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc_dqinfo",
          "args": [
            "tp"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "872-877",
          "snippet": "STATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_trans_dqresv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "585-725",
    "snippet": "STATIC int\nxfs_trans_dqresv(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\tlong\t\tnblks,\n\tlong\t\tninos,\n\tuint\t\tflags)\n{\n\txfs_qcnt_t\thardlimit;\n\txfs_qcnt_t\tsoftlimit;\n\ttime_t\t\ttimer;\n\txfs_qwarncnt_t\twarns;\n\txfs_qwarncnt_t\twarnlimit;\n\txfs_qcnt_t\ttotal_count;\n\txfs_qcnt_t\t*resbcountp;\n\txfs_quotainfo_t\t*q = mp->m_quotainfo;\n\n\n\txfs_dqlock(dqp);\n\n\tif (flags & XFS_TRANS_DQ_RES_BLKS) {\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_bhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_bsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_btimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_bwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_bwarnlimit;\n\t\tresbcountp = &dqp->q_res_bcount;\n\t} else {\n\t\tASSERT(flags & XFS_TRANS_DQ_RES_RTBLKS);\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_rtb_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_rtbhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_rtb_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_rtbsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_rtbwarnlimit;\n\t\tresbcountp = &dqp->q_res_rtbcount;\n\t}\n\n\tif ((flags & XFS_QMOPT_FORCE_RES) == 0 &&\n\t    dqp->q_core.d_id &&\n\t    ((XFS_IS_UQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISUDQ(dqp)) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISGDQ(dqp)) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISPDQ(dqp)))) {\n\t\tif (nblks > 0) {\n\t\t\t/*\n\t\t\t * dquot is locked already. See if we'd go over the\n\t\t\t * hardlimit or exceed the timelimit if we allocate\n\t\t\t * nblks.\n\t\t\t */\n\t\t\ttotal_count = *resbcountp + nblks;\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t    (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_BSOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BSOFTWARN);\n\t\t\t}\n\t\t}\n\t\tif (ninos > 0) {\n\t\t\ttotal_count = be64_to_cpu(dqp->q_core.d_icount) + ninos;\n\t\t\ttimer = be32_to_cpu(dqp->q_core.d_itimer);\n\t\t\twarns = be16_to_cpu(dqp->q_core.d_iwarns);\n\t\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_iwarnlimit;\n\t\t\thardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\t\t\tif (!hardlimit)\n\t\t\t\thardlimit = q->qi_ihardlimit;\n\t\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\t\t\tif (!softlimit)\n\t\t\t\tsoftlimit = q->qi_isoftlimit;\n\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif  ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t     (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_ISOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_ISOFTWARN);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Change the reservation, but not the actual usage.\n\t * Note that q_res_bcount = q_core.d_bcount + resv\n\t */\n\t(*resbcountp) += (xfs_qcnt_t)nblks;\n\tif (ninos != 0)\n\t\tdqp->q_res_icount += (xfs_qcnt_t)ninos;\n\n\t/*\n\t * note the reservation amt in the trans struct too,\n\t * so that the transaction knows how much was reserved by\n\t * it against this particular dquot.\n\t * We don't do this when we are reserving for a delayed allocation,\n\t * because we don't have the luxury of a transaction envelope then.\n\t */\n\tif (tp) {\n\t\tASSERT(tp->t_dqinfo);\n\t\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\t\tif (nblks != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    flags & XFS_QMOPT_RESBLK_MASK,\n\t\t\t\t\t    nblks);\n\t\tif (ninos != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    XFS_TRANS_DQ_RES_INOS,\n\t\t\t\t\t    ninos);\n\t}\n\tASSERT(dqp->q_res_bcount >= be64_to_cpu(dqp->q_core.d_bcount));\n\tASSERT(dqp->q_res_rtbcount >= be64_to_cpu(dqp->q_core.d_rtbcount));\n\tASSERT(dqp->q_res_icount >= be64_to_cpu(dqp->q_core.d_icount));\n\n\txfs_dqunlock(dqp);\n\treturn 0;\n\nerror_return:\n\txfs_dqunlock(dqp);\n\tif (flags & XFS_QMOPT_ENOSPC)\n\t\treturn -ENOSPC;\n\treturn -EDQUOT;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_icount >= be64_to_cpu(dqp->q_core.d_icount)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_icount"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_rtbcount >= be64_to_cpu(dqp->q_core.d_rtbcount)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtbcount"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_bcount >= be64_to_cpu(dqp->q_core.d_bcount)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_bcount"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot",
          "args": [
            "tp",
            "dqp",
            "XFS_TRANS_DQ_RES_INOS",
            "ninos"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "198-290",
          "snippet": "void\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_QMOPT_RESBLK_MASK"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_dqinfo"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_quota_warn",
          "args": [
            "mp",
            "dqp",
            "QUOTA_NL_ISOFTWARN"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quota_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "563-577",
          "snippet": "STATIC void\nxfs_quota_warn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dqp,\n\tint\t\t\ttype)\n{\n\t/* no warnings for project quotas - we just return ENOSPC later */\n\tif (dqp->dq_flags & XFS_DQ_PROJ)\n\t\treturn;\n\tquota_send_warning(make_kqid(&init_user_ns,\n\t\t\t\t     (dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA,\n\t\t\t\t     be32_to_cpu(dqp->q_core.d_id)),\n\t\t\t   mp->m_super->s_dev, type);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_quota_warn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dqp,\n\tint\t\t\ttype)\n{\n\t/* no warnings for project quotas - we just return ENOSPC later */\n\tif (dqp->dq_flags & XFS_DQ_PROJ)\n\t\treturn;\n\tquota_send_warning(make_kqid(&init_user_ns,\n\t\t\t\t     (dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA,\n\t\t\t\t     be32_to_cpu(dqp->q_core.d_id)),\n\t\t\t   mp->m_super->s_dev, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_softlimit"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_hardlimit"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_iwarns"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_itimer"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_icount"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_QM_ISPDQ",
          "args": [
            "dqp"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ENFORCED",
          "args": [
            "dqp->q_mount"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_QM_ISGDQ",
          "args": [
            "dqp"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ENFORCED",
          "args": [
            "dqp->q_mount"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_QM_ISUDQ",
          "args": [
            "dqp"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ENFORCED",
          "args": [
            "dqp->q_mount"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_rtbwarns"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_rtbtimer"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtb_softlimit"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtb_hardlimit"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_TRANS_DQ_RES_RTBLKS"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dqp->q_core.d_bwarns"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_btimer"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_softlimit"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_hardlimit"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\nSTATIC struct;\n\nSTATIC int\nxfs_trans_dqresv(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\tlong\t\tnblks,\n\tlong\t\tninos,\n\tuint\t\tflags)\n{\n\txfs_qcnt_t\thardlimit;\n\txfs_qcnt_t\tsoftlimit;\n\ttime_t\t\ttimer;\n\txfs_qwarncnt_t\twarns;\n\txfs_qwarncnt_t\twarnlimit;\n\txfs_qcnt_t\ttotal_count;\n\txfs_qcnt_t\t*resbcountp;\n\txfs_quotainfo_t\t*q = mp->m_quotainfo;\n\n\n\txfs_dqlock(dqp);\n\n\tif (flags & XFS_TRANS_DQ_RES_BLKS) {\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_bhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_bsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_btimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_bwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_bwarnlimit;\n\t\tresbcountp = &dqp->q_res_bcount;\n\t} else {\n\t\tASSERT(flags & XFS_TRANS_DQ_RES_RTBLKS);\n\t\thardlimit = be64_to_cpu(dqp->q_core.d_rtb_hardlimit);\n\t\tif (!hardlimit)\n\t\t\thardlimit = q->qi_rtbhardlimit;\n\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_rtb_softlimit);\n\t\tif (!softlimit)\n\t\t\tsoftlimit = q->qi_rtbsoftlimit;\n\t\ttimer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\t\twarns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_rtbwarnlimit;\n\t\tresbcountp = &dqp->q_res_rtbcount;\n\t}\n\n\tif ((flags & XFS_QMOPT_FORCE_RES) == 0 &&\n\t    dqp->q_core.d_id &&\n\t    ((XFS_IS_UQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISUDQ(dqp)) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISGDQ(dqp)) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(dqp->q_mount) && XFS_QM_ISPDQ(dqp)))) {\n\t\tif (nblks > 0) {\n\t\t\t/*\n\t\t\t * dquot is locked already. See if we'd go over the\n\t\t\t * hardlimit or exceed the timelimit if we allocate\n\t\t\t * nblks.\n\t\t\t */\n\t\t\ttotal_count = *resbcountp + nblks;\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t    (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_BSOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_BSOFTWARN);\n\t\t\t}\n\t\t}\n\t\tif (ninos > 0) {\n\t\t\ttotal_count = be64_to_cpu(dqp->q_core.d_icount) + ninos;\n\t\t\ttimer = be32_to_cpu(dqp->q_core.d_itimer);\n\t\t\twarns = be16_to_cpu(dqp->q_core.d_iwarns);\n\t\t\twarnlimit = dqp->q_mount->m_quotainfo->qi_iwarnlimit;\n\t\t\thardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\t\t\tif (!hardlimit)\n\t\t\t\thardlimit = q->qi_ihardlimit;\n\t\t\tsoftlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\t\t\tif (!softlimit)\n\t\t\t\tsoftlimit = q->qi_isoftlimit;\n\n\t\t\tif (hardlimit && total_count > hardlimit) {\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t\tif (softlimit && total_count > softlimit) {\n\t\t\t\tif  ((timer != 0 && get_seconds() > timer) ||\n\t\t\t\t     (warns != 0 && warns >= warnlimit)) {\n\t\t\t\t\txfs_quota_warn(mp, dqp,\n\t\t\t\t\t\t       QUOTA_NL_ISOFTLONGWARN);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t\txfs_quota_warn(mp, dqp, QUOTA_NL_ISOFTWARN);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Change the reservation, but not the actual usage.\n\t * Note that q_res_bcount = q_core.d_bcount + resv\n\t */\n\t(*resbcountp) += (xfs_qcnt_t)nblks;\n\tif (ninos != 0)\n\t\tdqp->q_res_icount += (xfs_qcnt_t)ninos;\n\n\t/*\n\t * note the reservation amt in the trans struct too,\n\t * so that the transaction knows how much was reserved by\n\t * it against this particular dquot.\n\t * We don't do this when we are reserving for a delayed allocation,\n\t * because we don't have the luxury of a transaction envelope then.\n\t */\n\tif (tp) {\n\t\tASSERT(tp->t_dqinfo);\n\t\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\t\tif (nblks != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    flags & XFS_QMOPT_RESBLK_MASK,\n\t\t\t\t\t    nblks);\n\t\tif (ninos != 0)\n\t\t\txfs_trans_mod_dquot(tp, dqp,\n\t\t\t\t\t    XFS_TRANS_DQ_RES_INOS,\n\t\t\t\t\t    ninos);\n\t}\n\tASSERT(dqp->q_res_bcount >= be64_to_cpu(dqp->q_core.d_bcount));\n\tASSERT(dqp->q_res_rtbcount >= be64_to_cpu(dqp->q_core.d_rtbcount));\n\tASSERT(dqp->q_res_icount >= be64_to_cpu(dqp->q_core.d_icount));\n\n\txfs_dqunlock(dqp);\n\treturn 0;\n\nerror_return:\n\txfs_dqunlock(dqp);\n\tif (flags & XFS_QMOPT_ENOSPC)\n\t\treturn -ENOSPC;\n\treturn -EDQUOT;\n}"
  },
  {
    "function_name": "xfs_quota_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "563-577",
    "snippet": "STATIC void\nxfs_quota_warn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dqp,\n\tint\t\t\ttype)\n{\n\t/* no warnings for project quotas - we just return ENOSPC later */\n\tif (dqp->dq_flags & XFS_DQ_PROJ)\n\t\treturn;\n\tquota_send_warning(make_kqid(&init_user_ns,\n\t\t\t\t     (dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA,\n\t\t\t\t     be32_to_cpu(dqp->q_core.d_id)),\n\t\t\t   mp->m_super->s_dev, type);\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "quota_send_warning",
          "args": [
            "make_kqid(&init_user_ns,\n\t\t\t\t     (dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA,\n\t\t\t\t     be32_to_cpu(dqp->q_core.d_id))",
            "mp->m_super->s_dev",
            "type"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "quota_send_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/netlink.c",
          "lines": "44-98",
          "snippet": "void quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}",
          "includes": [
            "#include <net/genetlink.h>",
            "#include <net/netlink.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cred.h>\n\nstatic struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};\n\nvoid quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid",
          "args": [
            "&init_user_ns",
            "(dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA",
            "be32_to_cpu(dqp->q_core.d_id)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_quota_warn(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dqp,\n\tint\t\t\ttype)\n{\n\t/* no warnings for project quotas - we just return ENOSPC later */\n\tif (dqp->dq_flags & XFS_DQ_PROJ)\n\t\treturn;\n\tquota_send_warning(make_kqid(&init_user_ns,\n\t\t\t\t     (dqp->dq_flags & XFS_DQ_USER) ?\n\t\t\t\t     USRQUOTA : GRPQUOTA,\n\t\t\t\t     be32_to_cpu(dqp->q_core.d_id)),\n\t\t\t   mp->m_super->s_dev, type);\n}"
  },
  {
    "function_name": "xfs_trans_unreserve_and_mod_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "504-561",
    "snippet": "void\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_apply_dquot_deltas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "325-495",
    "snippet": "void\nxfs_trans_apply_dquot_deltas(\n\tstruct xfs_trans\t*tp)\n{\n\tint\t\t\ti, j;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_dqtrx\t*qtrx, *qa;\n\tstruct xfs_disk_dquot\t*d;\n\tlong\t\t\ttotalbdelta;\n\tlong\t\t\ttotalrtbdelta;\n\n\tif (!(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tASSERT(tp->t_dqinfo);\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\t\tif (qa[0].qt_dquot == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Lock all of the dquots and join them to the transaction.\n\t\t */\n\t\txfs_trans_dqlockedjoin(tp, qa);\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * The array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\t\t\tASSERT(dqp->q_transp == tp);\n\n\t\t\t/*\n\t\t\t * adjust the actual number of blocks used\n\t\t\t */\n\t\t\td = &dqp->q_core;\n\n\t\t\t/*\n\t\t\t * The issue here is - sometimes we don't make a blkquota\n\t\t\t * reservation intentionally to be fair to users\n\t\t\t * (when the amount is small). On the other hand,\n\t\t\t * delayed allocs do make reservations, but that's\n\t\t\t * outside of a transaction, so we have no\n\t\t\t * idea how much was really reserved.\n\t\t\t * So, here we've accumulated delayed allocation blks and\n\t\t\t * non-delay blks. The assumption is that the\n\t\t\t * delayed ones are always reserved (outside of a\n\t\t\t * transaction), and the others may or may not have\n\t\t\t * quota reservations.\n\t\t\t */\n\t\t\ttotalbdelta = qtrx->qt_bcount_delta +\n\t\t\t\tqtrx->qt_delbcnt_delta;\n\t\t\ttotalrtbdelta = qtrx->qt_rtbcount_delta +\n\t\t\t\tqtrx->qt_delrtb_delta;\n#ifdef DEBUG\n\t\t\tif (totalbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_bcount) >=\n\t\t\t\t       -totalbdelta);\n\n\t\t\tif (totalrtbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_rtbcount) >=\n\t\t\t\t       -totalrtbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_icount) >=\n\t\t\t\t       -qtrx->qt_icount_delta);\n#endif\n\t\t\tif (totalbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_bcount, (xfs_qcnt_t)totalbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\tbe64_add_cpu(&d->d_icount, (xfs_qcnt_t)qtrx->qt_icount_delta);\n\n\t\t\tif (totalrtbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_rtbcount, (xfs_qcnt_t)totalrtbdelta);\n\n\t\t\t/*\n\t\t\t * Get any default limits in use.\n\t\t\t * Start/reset the timer(s) if needed.\n\t\t\t */\n\t\t\tif (d->d_id) {\n\t\t\t\txfs_qm_adjust_dqlimits(tp->t_mountp, dqp);\n\t\t\t\txfs_qm_adjust_dqtimers(tp->t_mountp, d);\n\t\t\t}\n\n\t\t\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\t\t\t/*\n\t\t\t * add this to the list of items to get logged\n\t\t\t */\n\t\t\txfs_trans_log_dquot(tp, dqp);\n\t\t\t/*\n\t\t\t * Take off what's left of the original reservation.\n\t\t\t * In case of delayed allocations, there's no\n\t\t\t * reservation that a transaction structure knows of.\n\t\t\t */\n\t\t\tif (qtrx->qt_blk_res != 0) {\n\t\t\t\tif (qtrx->qt_blk_res != qtrx->qt_blk_res_used) {\n\t\t\t\t\tif (qtrx->qt_blk_res >\n\t\t\t\t\t    qtrx->qt_blk_res_used)\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res -\n\t\t\t\t\t\t\t qtrx->qt_blk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res_used -\n\t\t\t\t\t\t\t qtrx->qt_blk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * These blks were never reserved, either inside\n\t\t\t\t * a transaction or outside one (in a delayed\n\t\t\t\t * allocation). Also, this isn't always a\n\t\t\t\t * negative number since we sometimes\n\t\t\t\t * deliberately skip quota reservations.\n\t\t\t\t */\n\t\t\t\tif (qtrx->qt_bcount_delta) {\n\t\t\t\t\tdqp->q_res_bcount +=\n\t\t\t\t\t      (xfs_qcnt_t)qtrx->qt_bcount_delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Adjust the RT reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_rtblk_res != 0) {\n\t\t\t\tif (qtrx->qt_rtblk_res != qtrx->qt_rtblk_res_used) {\n\t\t\t\t\tif (qtrx->qt_rtblk_res >\n\t\t\t\t\t    qtrx->qt_rtblk_res_used)\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res_used -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_rtbcount_delta)\n\t\t\t\t\tdqp->q_res_rtbcount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_rtbcount_delta;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Adjust the inode reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_ino_res != 0) {\n\t\t\t\tASSERT(qtrx->qt_ino_res >=\n\t\t\t\t       qtrx->qt_ino_res_used);\n\t\t\t\tif (qtrx->qt_ino_res > qtrx->qt_ino_res_used)\n\t\t\t\t\tdqp->q_res_icount -= (xfs_qcnt_t)\n\t\t\t\t\t\t(qtrx->qt_ino_res -\n\t\t\t\t\t\t qtrx->qt_ino_res_used);\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\t\tdqp->q_res_icount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_icount_delta;\n\t\t\t}\n\n\t\t\tASSERT(dqp->q_res_bcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_bcount));\n\t\t\tASSERT(dqp->q_res_icount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_icount));\n\t\t\tASSERT(dqp->q_res_rtbcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_rtbcount));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_rtbcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_rtbcount)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_rtbcount"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_icount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_icount)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_icount"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_res_bcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_bcount)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_bcount"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "qtrx->qt_ino_res -\n\t\t\t\t\t\t qtrx->qt_ino_res_used"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qtrx->qt_ino_res >=\n\t\t\t\t       qtrx->qt_ino_res_used"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "qtrx->qt_rtblk_res_used -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "qtrx->qt_rtblk_res -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res_used"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "qtrx->qt_blk_res_used -\n\t\t\t\t\t\t\t qtrx->qt_blk_res"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "qtrx->qt_blk_res -\n\t\t\t\t\t\t\t qtrx->qt_blk_res_used"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_dquot",
          "args": [
            "tp",
            "dqp"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_adjust_dqtimers",
          "args": [
            "tp->t_mountp",
            "d"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_adjust_dqtimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "133-220",
          "snippet": "void\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_adjust_dqlimits",
          "args": [
            "tp->t_mountp",
            "dqp"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_adjust_dqlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "88-118",
          "snippet": "void\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&d->d_rtbcount",
            "(xfs_qcnt_t)totalrtbdelta"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&d->d_icount",
            "(xfs_qcnt_t)qtrx->qt_icount_delta"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&d->d_bcount",
            "(xfs_qcnt_t)totalbdelta"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_icount) >=\n\t\t\t\t       -qtrx->qt_icount_delta"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_icount"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_rtbcount) >=\n\t\t\t\t       -totalrtbdelta"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtbcount"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_bcount) >=\n\t\t\t\t       -totalbdelta"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_bcount"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_transp == tp"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_dqlockedjoin",
          "args": [
            "tp",
            "qa"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dqlockedjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "299-314",
          "snippet": "STATIC void\nxfs_trans_dqlockedjoin(\n\txfs_trans_t\t*tp,\n\txfs_dqtrx_t\t*q)\n{\n\tASSERT(q[0].qt_dquot != NULL);\n\tif (q[1].qt_dquot == NULL) {\n\t\txfs_dqlock(q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t} else {\n\t\tASSERT(XFS_QM_TRANS_MAXDQS == 2);\n\t\txfs_dqlock2(q[0].qt_dquot, q[1].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[1].qt_dquot);\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_dqlockedjoin(\n\txfs_trans_t\t*tp,\n\txfs_dqtrx_t\t*q)\n{\n\tASSERT(q[0].qt_dquot != NULL);\n\tif (q[1].qt_dquot == NULL) {\n\t\txfs_dqlock(q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t} else {\n\t\tASSERT(XFS_QM_TRANS_MAXDQS == 2);\n\t\txfs_dqlock2(q[0].qt_dquot, q[1].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[1].qt_dquot);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_dqinfo"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_apply_dquot_deltas(\n\tstruct xfs_trans\t*tp)\n{\n\tint\t\t\ti, j;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_dqtrx\t*qtrx, *qa;\n\tstruct xfs_disk_dquot\t*d;\n\tlong\t\t\ttotalbdelta;\n\tlong\t\t\ttotalrtbdelta;\n\n\tif (!(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tASSERT(tp->t_dqinfo);\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\t\tif (qa[0].qt_dquot == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Lock all of the dquots and join them to the transaction.\n\t\t */\n\t\txfs_trans_dqlockedjoin(tp, qa);\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * The array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\t\t\tASSERT(dqp->q_transp == tp);\n\n\t\t\t/*\n\t\t\t * adjust the actual number of blocks used\n\t\t\t */\n\t\t\td = &dqp->q_core;\n\n\t\t\t/*\n\t\t\t * The issue here is - sometimes we don't make a blkquota\n\t\t\t * reservation intentionally to be fair to users\n\t\t\t * (when the amount is small). On the other hand,\n\t\t\t * delayed allocs do make reservations, but that's\n\t\t\t * outside of a transaction, so we have no\n\t\t\t * idea how much was really reserved.\n\t\t\t * So, here we've accumulated delayed allocation blks and\n\t\t\t * non-delay blks. The assumption is that the\n\t\t\t * delayed ones are always reserved (outside of a\n\t\t\t * transaction), and the others may or may not have\n\t\t\t * quota reservations.\n\t\t\t */\n\t\t\ttotalbdelta = qtrx->qt_bcount_delta +\n\t\t\t\tqtrx->qt_delbcnt_delta;\n\t\t\ttotalrtbdelta = qtrx->qt_rtbcount_delta +\n\t\t\t\tqtrx->qt_delrtb_delta;\n#ifdef DEBUG\n\t\t\tif (totalbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_bcount) >=\n\t\t\t\t       -totalbdelta);\n\n\t\t\tif (totalrtbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_rtbcount) >=\n\t\t\t\t       -totalrtbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_icount) >=\n\t\t\t\t       -qtrx->qt_icount_delta);\n#endif\n\t\t\tif (totalbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_bcount, (xfs_qcnt_t)totalbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\tbe64_add_cpu(&d->d_icount, (xfs_qcnt_t)qtrx->qt_icount_delta);\n\n\t\t\tif (totalrtbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_rtbcount, (xfs_qcnt_t)totalrtbdelta);\n\n\t\t\t/*\n\t\t\t * Get any default limits in use.\n\t\t\t * Start/reset the timer(s) if needed.\n\t\t\t */\n\t\t\tif (d->d_id) {\n\t\t\t\txfs_qm_adjust_dqlimits(tp->t_mountp, dqp);\n\t\t\t\txfs_qm_adjust_dqtimers(tp->t_mountp, d);\n\t\t\t}\n\n\t\t\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\t\t\t/*\n\t\t\t * add this to the list of items to get logged\n\t\t\t */\n\t\t\txfs_trans_log_dquot(tp, dqp);\n\t\t\t/*\n\t\t\t * Take off what's left of the original reservation.\n\t\t\t * In case of delayed allocations, there's no\n\t\t\t * reservation that a transaction structure knows of.\n\t\t\t */\n\t\t\tif (qtrx->qt_blk_res != 0) {\n\t\t\t\tif (qtrx->qt_blk_res != qtrx->qt_blk_res_used) {\n\t\t\t\t\tif (qtrx->qt_blk_res >\n\t\t\t\t\t    qtrx->qt_blk_res_used)\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res -\n\t\t\t\t\t\t\t qtrx->qt_blk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res_used -\n\t\t\t\t\t\t\t qtrx->qt_blk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * These blks were never reserved, either inside\n\t\t\t\t * a transaction or outside one (in a delayed\n\t\t\t\t * allocation). Also, this isn't always a\n\t\t\t\t * negative number since we sometimes\n\t\t\t\t * deliberately skip quota reservations.\n\t\t\t\t */\n\t\t\t\tif (qtrx->qt_bcount_delta) {\n\t\t\t\t\tdqp->q_res_bcount +=\n\t\t\t\t\t      (xfs_qcnt_t)qtrx->qt_bcount_delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Adjust the RT reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_rtblk_res != 0) {\n\t\t\t\tif (qtrx->qt_rtblk_res != qtrx->qt_rtblk_res_used) {\n\t\t\t\t\tif (qtrx->qt_rtblk_res >\n\t\t\t\t\t    qtrx->qt_rtblk_res_used)\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res_used -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_rtbcount_delta)\n\t\t\t\t\tdqp->q_res_rtbcount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_rtbcount_delta;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Adjust the inode reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_ino_res != 0) {\n\t\t\t\tASSERT(qtrx->qt_ino_res >=\n\t\t\t\t       qtrx->qt_ino_res_used);\n\t\t\t\tif (qtrx->qt_ino_res > qtrx->qt_ino_res_used)\n\t\t\t\t\tdqp->q_res_icount -= (xfs_qcnt_t)\n\t\t\t\t\t\t(qtrx->qt_ino_res -\n\t\t\t\t\t\t qtrx->qt_ino_res_used);\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\t\tdqp->q_res_icount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_icount_delta;\n\t\t\t}\n\n\t\t\tASSERT(dqp->q_res_bcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_bcount));\n\t\t\tASSERT(dqp->q_res_icount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_icount));\n\t\t\tASSERT(dqp->q_res_rtbcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_rtbcount));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_dqlockedjoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "299-314",
    "snippet": "STATIC void\nxfs_trans_dqlockedjoin(\n\txfs_trans_t\t*tp,\n\txfs_dqtrx_t\t*q)\n{\n\tASSERT(q[0].qt_dquot != NULL);\n\tif (q[1].qt_dquot == NULL) {\n\t\txfs_dqlock(q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t} else {\n\t\tASSERT(XFS_QM_TRANS_MAXDQS == 2);\n\t\txfs_dqlock2(q[0].qt_dquot, q[1].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[1].qt_dquot);\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_dqjoin",
          "args": [
            "tp",
            "q[1].qt_dquot"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dqjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "39-58",
          "snippet": "void\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqlock2",
          "args": [
            "q[0].qt_dquot",
            "q[1].qt_dquot"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "1056-1076",
          "snippet": "void\nxfs_dqlock2(\n\txfs_dquot_t\t*d1,\n\txfs_dquot_t\t*d2)\n{\n\tif (d1 && d2) {\n\t\tASSERT(d1 != d2);\n\t\tif (be32_to_cpu(d1->q_core.d_id) >\n\t\t    be32_to_cpu(d2->q_core.d_id)) {\n\t\t\tmutex_lock(&d2->q_qlock);\n\t\t\tmutex_lock_nested(&d1->q_qlock, XFS_QLOCK_NESTED);\n\t\t} else {\n\t\t\tmutex_lock(&d1->q_qlock);\n\t\t\tmutex_lock_nested(&d2->q_qlock, XFS_QLOCK_NESTED);\n\t\t}\n\t} else if (d1) {\n\t\tmutex_lock(&d1->q_qlock);\n\t} else if (d2) {\n\t\tmutex_lock(&d2->q_qlock);\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dqlock2(\n\txfs_dquot_t\t*d1,\n\txfs_dquot_t\t*d2)\n{\n\tif (d1 && d2) {\n\t\tASSERT(d1 != d2);\n\t\tif (be32_to_cpu(d1->q_core.d_id) >\n\t\t    be32_to_cpu(d2->q_core.d_id)) {\n\t\t\tmutex_lock(&d2->q_qlock);\n\t\t\tmutex_lock_nested(&d1->q_qlock, XFS_QLOCK_NESTED);\n\t\t} else {\n\t\t\tmutex_lock(&d1->q_qlock);\n\t\t\tmutex_lock_nested(&d2->q_qlock, XFS_QLOCK_NESTED);\n\t\t}\n\t} else if (d1) {\n\t\tmutex_lock(&d1->q_qlock);\n\t} else if (d2) {\n\t\tmutex_lock(&d2->q_qlock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_QM_TRANS_MAXDQS == 2"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "q[0].qt_dquot"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "q[0].qt_dquot != NULL"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_dqlockedjoin(\n\txfs_trans_t\t*tp,\n\txfs_dqtrx_t\t*q)\n{\n\tASSERT(q[0].qt_dquot != NULL);\n\tif (q[1].qt_dquot == NULL) {\n\t\txfs_dqlock(q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t} else {\n\t\tASSERT(XFS_QM_TRANS_MAXDQS == 2);\n\t\txfs_dqlock2(q[0].qt_dquot, q[1].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[0].qt_dquot);\n\t\txfs_trans_dqjoin(tp, q[1].qt_dquot);\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_mod_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "198-290",
    "snippet": "void\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qtrx->qt_ino_res >= qtrx->qt_ino_res_used"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qtrx->qt_blk_res >= qtrx->qt_blk_res_used"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qtrx"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_dqtrx",
          "args": [
            "tp",
            "dqp"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_dqtrx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "166-190",
          "snippet": "xfs_dqtrx *\nxfs_trans_get_dqtrx(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp)\n{\n\tint\t\t\ti;\n\tstruct xfs_dqtrx\t*qa;\n\n\tif (XFS_QM_ISUDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_USR];\n\telse if (XFS_QM_ISGDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_GRP];\n\telse if (XFS_QM_ISPDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_PRJ];\n\telse\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\tif (qa[i].qt_dquot == NULL ||\n\t\t    qa[i].qt_dquot == dqp)\n\t\t\treturn &qa[i];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_dqtrx *\nxfs_trans_get_dqtrx(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp)\n{\n\tint\t\t\ti;\n\tstruct xfs_dqtrx\t*qa;\n\n\tif (XFS_QM_ISUDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_USR];\n\telse if (XFS_QM_ISGDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_GRP];\n\telse if (XFS_QM_ISPDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_PRJ];\n\telse\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\tif (qa[i].qt_dquot == NULL ||\n\t\t    qa[i].qt_dquot == dqp)\n\t\t\treturn &qa[i];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc_dqinfo",
          "args": [
            "tp"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "872-877",
          "snippet": "STATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(tp->t_mountp)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "tp->t_mountp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}"
  },
  {
    "function_name": "xfs_trans_get_dqtrx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "166-190",
    "snippet": "xfs_dqtrx *\nxfs_trans_get_dqtrx(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp)\n{\n\tint\t\t\ti;\n\tstruct xfs_dqtrx\t*qa;\n\n\tif (XFS_QM_ISUDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_USR];\n\telse if (XFS_QM_ISGDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_GRP];\n\telse if (XFS_QM_ISPDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_PRJ];\n\telse\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\tif (qa[i].qt_dquot == NULL ||\n\t\t    qa[i].qt_dquot == dqp)\n\t\t\treturn &qa[i];\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_QM_ISPDQ",
          "args": [
            "dqp"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_QM_ISGDQ",
          "args": [
            "dqp"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_QM_ISUDQ",
          "args": [
            "dqp"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_dqtrx *\nxfs_trans_get_dqtrx(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp)\n{\n\tint\t\t\ti;\n\tstruct xfs_dqtrx\t*qa;\n\n\tif (XFS_QM_ISUDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_USR];\n\telse if (XFS_QM_ISGDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_GRP];\n\telse if (XFS_QM_ISPDQ(dqp))\n\t\tqa = tp->t_dqinfo->dqs[XFS_QM_TRANS_PRJ];\n\telse\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\tif (qa[i].qt_dquot == NULL ||\n\t\t    qa[i].qt_dquot == dqp)\n\t\t\treturn &qa[i];\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_trans_mod_dquot_byino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "141-164",
    "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot",
          "args": [
            "tp",
            "ip->i_pdquot",
            "field",
            "delta"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "198-290",
          "snippet": "void\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc_dqinfo",
          "args": [
            "tp"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "872-877",
          "snippet": "STATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&mp->m_sb",
            "ip->i_ino"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
  },
  {
    "function_name": "xfs_trans_dup_dqinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "87-136",
    "snippet": "void\nxfs_trans_dup_dqinfo(\n\txfs_trans_t\t*otp,\n\txfs_trans_t\t*ntp)\n{\n\txfs_dqtrx_t\t*oq, *nq;\n\tint\t\ti,j;\n\txfs_dqtrx_t\t*oqa, *nqa;\n\n\tif (!otp->t_dqinfo)\n\t\treturn;\n\n\txfs_trans_alloc_dqinfo(ntp);\n\n\t/*\n\t * Because the quota blk reservation is carried forward,\n\t * it is also necessary to carry forward the DQ_DIRTY flag.\n\t */\n\tif(otp->t_flags & XFS_TRANS_DQ_DIRTY)\n\t\tntp->t_flags |= XFS_TRANS_DQ_DIRTY;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\toqa = otp->t_dqinfo->dqs[j];\n\t\tnqa = ntp->t_dqinfo->dqs[j];\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tif (oqa[i].qt_dquot == NULL)\n\t\t\t\tbreak;\n\t\t\toq = &oqa[i];\n\t\t\tnq = &nqa[i];\n\n\t\t\tnq->qt_dquot = oq->qt_dquot;\n\t\t\tnq->qt_bcount_delta = nq->qt_icount_delta = 0;\n\t\t\tnq->qt_rtbcount_delta = 0;\n\n\t\t\t/*\n\t\t\t * Transfer whatever is left of the reservations.\n\t\t\t */\n\t\t\tnq->qt_blk_res = oq->qt_blk_res - oq->qt_blk_res_used;\n\t\t\toq->qt_blk_res = oq->qt_blk_res_used;\n\n\t\t\tnq->qt_rtblk_res = oq->qt_rtblk_res -\n\t\t\t\toq->qt_rtblk_res_used;\n\t\t\toq->qt_rtblk_res = oq->qt_rtblk_res_used;\n\n\t\t\tnq->qt_ino_res = oq->qt_ino_res - oq->qt_ino_res_used;\n\t\t\toq->qt_ino_res = oq->qt_ino_res_used;\n\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_alloc_dqinfo",
          "args": [
            "ntp"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "872-877",
          "snippet": "STATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nSTATIC void\nxfs_trans_alloc_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\ttp->t_dqinfo = kmem_zone_zalloc(xfs_qm_dqtrxzone, KM_SLEEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_dup_dqinfo(\n\txfs_trans_t\t*otp,\n\txfs_trans_t\t*ntp)\n{\n\txfs_dqtrx_t\t*oq, *nq;\n\tint\t\ti,j;\n\txfs_dqtrx_t\t*oqa, *nqa;\n\n\tif (!otp->t_dqinfo)\n\t\treturn;\n\n\txfs_trans_alloc_dqinfo(ntp);\n\n\t/*\n\t * Because the quota blk reservation is carried forward,\n\t * it is also necessary to carry forward the DQ_DIRTY flag.\n\t */\n\tif(otp->t_flags & XFS_TRANS_DQ_DIRTY)\n\t\tntp->t_flags |= XFS_TRANS_DQ_DIRTY;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\toqa = otp->t_dqinfo->dqs[j];\n\t\tnqa = ntp->t_dqinfo->dqs[j];\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tif (oqa[i].qt_dquot == NULL)\n\t\t\t\tbreak;\n\t\t\toq = &oqa[i];\n\t\t\tnq = &nqa[i];\n\n\t\t\tnq->qt_dquot = oq->qt_dquot;\n\t\t\tnq->qt_bcount_delta = nq->qt_icount_delta = 0;\n\t\t\tnq->qt_rtbcount_delta = 0;\n\n\t\t\t/*\n\t\t\t * Transfer whatever is left of the reservations.\n\t\t\t */\n\t\t\tnq->qt_blk_res = oq->qt_blk_res - oq->qt_blk_res_used;\n\t\t\toq->qt_blk_res = oq->qt_blk_res_used;\n\n\t\t\tnq->qt_rtblk_res = oq->qt_rtblk_res -\n\t\t\t\toq->qt_rtblk_res_used;\n\t\t\toq->qt_rtblk_res = oq->qt_rtblk_res_used;\n\n\t\t\tnq->qt_ino_res = oq->qt_ino_res - oq->qt_ino_res_used;\n\t\t\toq->qt_ino_res = oq->qt_ino_res_used;\n\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_log_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "71-81",
    "snippet": "void\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_transp == tp"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_log_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp == tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tdqp->q_logitem.qli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n}"
  },
  {
    "function_name": "xfs_trans_dqjoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
    "lines": "39-58",
    "snippet": "void\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_add_item",
          "args": [
            "tp",
            "&dqp->q_logitem.qli_item"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "651-668",
          "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_logitem.qli_dquot == dqp"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_transp != tp"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_dqjoin(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(dqp->q_transp != tp);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(dqp->q_logitem.qli_dquot == dqp);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &dqp->q_logitem.qli_item);\n\n\t/*\n\t * Initialize d_transp so we can later determine if this dquot is\n\t * associated with this transaction.\n\t */\n\tdqp->q_transp = tp;\n}"
  }
]