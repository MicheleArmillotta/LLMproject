[
  {
    "function_name": "autofs_dev_ioctl_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "757-761",
    "snippet": "void autofs_dev_ioctl_exit(void)\n{\n\tmisc_deregister(&_autofs_dev_ioctl_misc);\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice _autofs_dev_ioctl_misc = {\n\t.minor\t\t= AUTOFS_MINOR,\n\t.name  \t\t= AUTOFS_DEVICE_NAME,\n\t.fops  \t\t= &_dev_ioctl_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&_autofs_dev_ioctl_misc"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct miscdevice _autofs_dev_ioctl_misc = {\n\t.minor\t\t= AUTOFS_MINOR,\n\t.name  \t\t= AUTOFS_DEVICE_NAME,\n\t.fops  \t\t= &_dev_ioctl_fops\n};\n\nvoid autofs_dev_ioctl_exit(void)\n{\n\tmisc_deregister(&_autofs_dev_ioctl_misc);\n\treturn;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "744-755",
    "snippet": "int __init autofs_dev_ioctl_init(void)\n{\n\tint r;\n\n\tr = misc_register(&_autofs_dev_ioctl_misc);\n\tif (r) {\n\t\tAUTOFS_ERROR(\"misc_register failed for control device\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice _autofs_dev_ioctl_misc = {\n\t.minor\t\t= AUTOFS_MINOR,\n\t.name  \t\t= AUTOFS_DEVICE_NAME,\n\t.fops  \t\t= &_dev_ioctl_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUTOFS_ERROR",
          "args": [
            "\"misc_register failed for control device\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&_autofs_dev_ioctl_misc"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct miscdevice _autofs_dev_ioctl_misc = {\n\t.minor\t\t= AUTOFS_MINOR,\n\t.name  \t\t= AUTOFS_DEVICE_NAME,\n\t.fops  \t\t= &_dev_ioctl_fops\n};\n\nint __init autofs_dev_ioctl_init(void)\n{\n\tint r;\n\n\tr = misc_register(&_autofs_dev_ioctl_misc);\n\tif (r) {\n\t\tAUTOFS_ERROR(\"misc_register failed for control device\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "719-722",
    "snippet": "static long autofs_dev_ioctl_compat(struct file *file, uint command, ulong u)\n{\n\treturn (long) autofs_dev_ioctl(file, command, (ulong) compat_ptr(u));\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define autofs_dev_ioctl_compat NULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs_dev_ioctl",
          "args": [
            "file",
            "command",
            "(ulong) compat_ptr(u)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_dev_ioctl_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "719-722",
          "snippet": "static long autofs_dev_ioctl_compat(struct file *file, uint command, ulong u)\n{\n\treturn (long) autofs_dev_ioctl(file, command, (ulong) compat_ptr(u));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "u"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#define autofs_dev_ioctl_compat NULL\n\nstatic long autofs_dev_ioctl_compat(struct file *file, uint command, ulong u)\n{\n\treturn (long) autofs_dev_ioctl(file, command, (ulong) compat_ptr(u));\n}"
  },
  {
    "function_name": "autofs_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "711-716",
    "snippet": "static long autofs_dev_ioctl(struct file *file, uint command, ulong u)\n{\n\tint err;\n\terr = _autofs_dev_ioctl(command, (struct autofs_dev_ioctl __user *) u);\n\treturn (long) err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_autofs_dev_ioctl",
          "args": [
            "command",
            "(struct autofs_dev_ioctl __user *) u"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "_autofs_dev_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "622-709",
          "snippet": "static int _autofs_dev_ioctl(unsigned int command, struct autofs_dev_ioctl __user *user)\n{\n\tstruct autofs_dev_ioctl *param;\n\tstruct file *fp;\n\tstruct autofs_sb_info *sbi;\n\tunsigned int cmd_first, cmd;\n\tioctl_fn fn = NULL;\n\tint err = 0;\n\n\t/* only root can play with this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\n\tcmd = _IOC_NR(command);\n\n\tif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\n\t    cmd - cmd_first >= AUTOFS_DEV_IOCTL_IOC_COUNT) {\n\t\treturn -ENOTTY;\n\t}\n\n\t/* Copy the parameters into kernel space. */\n\tparam = copy_dev_ioctl(user);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\n\terr = validate_dev_ioctl(command, param);\n\tif (err)\n\t\tgoto out;\n\n\t/* The validate routine above always sets the version */\n\tif (cmd == AUTOFS_DEV_IOCTL_VERSION_CMD)\n\t\tgoto done;\n\n\tfn = lookup_dev_ioctl(cmd);\n\tif (!fn) {\n\t\tAUTOFS_WARN(\"unknown command 0x%08x\", command);\n\t\treturn -ENOTTY;\n\t}\n\n\tfp = NULL;\n\tsbi = NULL;\n\n\t/*\n\t * For obvious reasons the openmount can't have a file\n\t * descriptor yet. We don't take a reference to the\n\t * file during close to allow for immediate release.\n\t */\n\tif (cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\n\t\tfp = fget(param->ioctlfd);\n\t\tif (!fp) {\n\t\t\tif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\n\t\t\t\tgoto cont;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsbi = autofs_dev_ioctl_sbi(fp);\n\t\tif (!sbi || sbi->magic != AUTOFS_SBI_MAGIC) {\n\t\t\terr = -EINVAL;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Admin needs to be able to set the mount catatonic in\n\t\t * order to be able to perform the re-open.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) &&\n\t\t    cmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\n\t\t\terr = -EACCES;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t}\ncont:\n\terr = fn(fp, sbi, param);\n\n\tif (fp)\n\t\tfput(fp);\ndone:\n\tif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\n\t\terr = -EFAULT;\nout:\n\tfree_dev_ioctl(param);\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define AUTOFS_DEV_IOCTL_SIZE\tsizeof(struct autofs_dev_ioctl)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#define AUTOFS_DEV_IOCTL_SIZE\tsizeof(struct autofs_dev_ioctl)\n\nstatic int _autofs_dev_ioctl(unsigned int command, struct autofs_dev_ioctl __user *user)\n{\n\tstruct autofs_dev_ioctl *param;\n\tstruct file *fp;\n\tstruct autofs_sb_info *sbi;\n\tunsigned int cmd_first, cmd;\n\tioctl_fn fn = NULL;\n\tint err = 0;\n\n\t/* only root can play with this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\n\tcmd = _IOC_NR(command);\n\n\tif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\n\t    cmd - cmd_first >= AUTOFS_DEV_IOCTL_IOC_COUNT) {\n\t\treturn -ENOTTY;\n\t}\n\n\t/* Copy the parameters into kernel space. */\n\tparam = copy_dev_ioctl(user);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\n\terr = validate_dev_ioctl(command, param);\n\tif (err)\n\t\tgoto out;\n\n\t/* The validate routine above always sets the version */\n\tif (cmd == AUTOFS_DEV_IOCTL_VERSION_CMD)\n\t\tgoto done;\n\n\tfn = lookup_dev_ioctl(cmd);\n\tif (!fn) {\n\t\tAUTOFS_WARN(\"unknown command 0x%08x\", command);\n\t\treturn -ENOTTY;\n\t}\n\n\tfp = NULL;\n\tsbi = NULL;\n\n\t/*\n\t * For obvious reasons the openmount can't have a file\n\t * descriptor yet. We don't take a reference to the\n\t * file during close to allow for immediate release.\n\t */\n\tif (cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\n\t\tfp = fget(param->ioctlfd);\n\t\tif (!fp) {\n\t\t\tif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\n\t\t\t\tgoto cont;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsbi = autofs_dev_ioctl_sbi(fp);\n\t\tif (!sbi || sbi->magic != AUTOFS_SBI_MAGIC) {\n\t\t\terr = -EINVAL;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Admin needs to be able to set the mount catatonic in\n\t\t * order to be able to perform the re-open.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) &&\n\t\t    cmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\n\t\t\terr = -EACCES;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t}\ncont:\n\terr = fn(fp, sbi, param);\n\n\tif (fp)\n\t\tfput(fp);\ndone:\n\tif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\n\t\terr = -EFAULT;\nout:\n\tfree_dev_ioctl(param);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic long autofs_dev_ioctl(struct file *file, uint command, ulong u)\n{\n\tint err;\n\terr = _autofs_dev_ioctl(command, (struct autofs_dev_ioctl __user *) u);\n\treturn (long) err;\n}"
  },
  {
    "function_name": "_autofs_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "622-709",
    "snippet": "static int _autofs_dev_ioctl(unsigned int command, struct autofs_dev_ioctl __user *user)\n{\n\tstruct autofs_dev_ioctl *param;\n\tstruct file *fp;\n\tstruct autofs_sb_info *sbi;\n\tunsigned int cmd_first, cmd;\n\tioctl_fn fn = NULL;\n\tint err = 0;\n\n\t/* only root can play with this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\n\tcmd = _IOC_NR(command);\n\n\tif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\n\t    cmd - cmd_first >= AUTOFS_DEV_IOCTL_IOC_COUNT) {\n\t\treturn -ENOTTY;\n\t}\n\n\t/* Copy the parameters into kernel space. */\n\tparam = copy_dev_ioctl(user);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\n\terr = validate_dev_ioctl(command, param);\n\tif (err)\n\t\tgoto out;\n\n\t/* The validate routine above always sets the version */\n\tif (cmd == AUTOFS_DEV_IOCTL_VERSION_CMD)\n\t\tgoto done;\n\n\tfn = lookup_dev_ioctl(cmd);\n\tif (!fn) {\n\t\tAUTOFS_WARN(\"unknown command 0x%08x\", command);\n\t\treturn -ENOTTY;\n\t}\n\n\tfp = NULL;\n\tsbi = NULL;\n\n\t/*\n\t * For obvious reasons the openmount can't have a file\n\t * descriptor yet. We don't take a reference to the\n\t * file during close to allow for immediate release.\n\t */\n\tif (cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\n\t\tfp = fget(param->ioctlfd);\n\t\tif (!fp) {\n\t\t\tif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\n\t\t\t\tgoto cont;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsbi = autofs_dev_ioctl_sbi(fp);\n\t\tif (!sbi || sbi->magic != AUTOFS_SBI_MAGIC) {\n\t\t\terr = -EINVAL;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Admin needs to be able to set the mount catatonic in\n\t\t * order to be able to perform the re-open.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) &&\n\t\t    cmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\n\t\t\terr = -EACCES;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t}\ncont:\n\terr = fn(fp, sbi, param);\n\n\tif (fp)\n\t\tfput(fp);\ndone:\n\tif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\n\t\terr = -EFAULT;\nout:\n\tfree_dev_ioctl(param);\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define AUTOFS_DEV_IOCTL_SIZE\tsizeof(struct autofs_dev_ioctl)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_dev_ioctl",
          "args": [
            "param"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "free_dev_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "116-120",
          "snippet": "static inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\n{\n\tkfree(param);\n\treturn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\n{\n\tkfree(param);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user",
            "param",
            "AUTOFS_DEV_IOCTL_SIZE"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "fp"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "fp",
            "sbi",
            "param"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_oz_mode",
          "args": [
            "sbi"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_oz_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "146-148",
          "snippet": "static inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline int autofs4_oz_mode(struct autofs_sb_info *sbi) {\n\treturn sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_dev_ioctl_sbi",
          "args": [
            "fp"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_dev_ioctl_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "163-173",
          "snippet": "static struct autofs_sb_info *autofs_dev_ioctl_sbi(struct file *f)\n{\n\tstruct autofs_sb_info *sbi = NULL;\n\tstruct inode *inode;\n\n\tif (f) {\n\t\tinode = file_inode(f);\n\t\tsbi = autofs4_sbi(inode->i_sb);\n\t}\n\treturn sbi;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct autofs_sb_info *autofs_dev_ioctl_sbi(struct file *f)\n{\n\tstruct autofs_sb_info *sbi = NULL;\n\tstruct inode *inode;\n\n\tif (f) {\n\t\tinode = file_inode(f);\n\t\tsbi = autofs4_sbi(inode->i_sb);\n\t}\n\treturn sbi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "param->ioctlfd"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"unknown command 0x%08x\"",
            "command"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_dev_ioctl",
          "args": [
            "cmd"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_dev_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "582-619",
          "snippet": "static ioctl_fn lookup_dev_ioctl(unsigned int cmd)\n{\n\tstatic struct {\n\t\tint cmd;\n\t\tioctl_fn fn;\n\t} _ioctls[] = {\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_VERSION_CMD), NULL},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOVER_CMD),\n\t\t\t autofs_dev_ioctl_protover},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD),\n\t\t\t autofs_dev_ioctl_protosubver},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_OPENMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_openmount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_closemount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_READY_CMD),\n\t\t\t autofs_dev_ioctl_ready},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_FAIL_CMD),\n\t\t\t autofs_dev_ioctl_fail},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_SETPIPEFD_CMD),\n\t\t\t autofs_dev_ioctl_setpipefd},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CATATONIC_CMD),\n\t\t\t autofs_dev_ioctl_catatonic},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_TIMEOUT_CMD),\n\t\t\t autofs_dev_ioctl_timeout},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_REQUESTER_CMD),\n\t\t\t autofs_dev_ioctl_requester},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_EXPIRE_CMD),\n\t\t\t autofs_dev_ioctl_expire},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_askumount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD),\n\t\t\t autofs_dev_ioctl_ismountpoint}\n\t};\n\tunsigned int idx = cmd_idx(cmd);\n\n\treturn (idx >= ARRAY_SIZE(_ioctls)) ? NULL : _ioctls[idx].fn;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic ioctl_fn lookup_dev_ioctl(unsigned int cmd)\n{\n\tstatic struct {\n\t\tint cmd;\n\t\tioctl_fn fn;\n\t} _ioctls[] = {\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_VERSION_CMD), NULL},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOVER_CMD),\n\t\t\t autofs_dev_ioctl_protover},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD),\n\t\t\t autofs_dev_ioctl_protosubver},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_OPENMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_openmount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_closemount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_READY_CMD),\n\t\t\t autofs_dev_ioctl_ready},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_FAIL_CMD),\n\t\t\t autofs_dev_ioctl_fail},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_SETPIPEFD_CMD),\n\t\t\t autofs_dev_ioctl_setpipefd},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CATATONIC_CMD),\n\t\t\t autofs_dev_ioctl_catatonic},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_TIMEOUT_CMD),\n\t\t\t autofs_dev_ioctl_timeout},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_REQUESTER_CMD),\n\t\t\t autofs_dev_ioctl_requester},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_EXPIRE_CMD),\n\t\t\t autofs_dev_ioctl_expire},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_askumount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD),\n\t\t\t autofs_dev_ioctl_ismountpoint}\n\t};\n\tunsigned int idx = cmd_idx(cmd);\n\n\treturn (idx >= ARRAY_SIZE(_ioctls)) ? NULL : _ioctls[idx].fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_dev_ioctl",
          "args": [
            "command",
            "param"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "validate_dev_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "126-157",
          "snippet": "static int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err;\n\n\terr = check_dev_ioctl_version(cmd, param);\n\tif (err) {\n\t\tAUTOFS_WARN(\"invalid device control module version \"\n\t\t     \"supplied for cmd(0x%08x)\", cmd);\n\t\tgoto out;\n\t}\n\n\tif (param->size > sizeof(*param)) {\n\t\terr = invalid_str(param->path, param->size - sizeof(*param));\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\n\t\t\t  \"path string terminator missing for cmd(0x%08x)\",\n\t\t\t  cmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = check_name(param->path);\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\"invalid path supplied for cmd(0x%08x)\",\n\t\t\t\t    cmd);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err;\n\n\terr = check_dev_ioctl_version(cmd, param);\n\tif (err) {\n\t\tAUTOFS_WARN(\"invalid device control module version \"\n\t\t     \"supplied for cmd(0x%08x)\", cmd);\n\t\tgoto out;\n\t}\n\n\tif (param->size > sizeof(*param)) {\n\t\terr = invalid_str(param->path, param->size - sizeof(*param));\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\n\t\t\t  \"path string terminator missing for cmd(0x%08x)\",\n\t\t\t  cmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = check_name(param->path);\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\"invalid path supplied for cmd(0x%08x)\",\n\t\t\t\t    cmd);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "param"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "param"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_dev_ioctl",
          "args": [
            "user"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "copy_dev_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "96-114",
          "snippet": "static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)\n{\n\tstruct autofs_dev_ioctl tmp, *res;\n\n\tif (copy_from_user(&tmp, in, sizeof(tmp)))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (tmp.size < sizeof(tmp))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tmp.size > (PATH_MAX + sizeof(tmp)))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = memdup_user(in, tmp.size);\n\tif (!IS_ERR(res))\n\t\tres->size = tmp.size;\n\n\treturn res;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)\n{\n\tstruct autofs_dev_ioctl tmp, *res;\n\n\tif (copy_from_user(&tmp, in, sizeof(tmp)))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (tmp.size < sizeof(tmp))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tmp.size > (PATH_MAX + sizeof(tmp)))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = memdup_user(in, tmp.size);\n\tif (!IS_ERR(res))\n\t\tres->size = tmp.size;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "AUTOFS_DEV_IOCTL_IOC_FIRST"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "command"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "command"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "AUTOFS_DEV_IOCTL_IOC_FIRST"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#define AUTOFS_DEV_IOCTL_SIZE\tsizeof(struct autofs_dev_ioctl)\n\nstatic int _autofs_dev_ioctl(unsigned int command, struct autofs_dev_ioctl __user *user)\n{\n\tstruct autofs_dev_ioctl *param;\n\tstruct file *fp;\n\tstruct autofs_sb_info *sbi;\n\tunsigned int cmd_first, cmd;\n\tioctl_fn fn = NULL;\n\tint err = 0;\n\n\t/* only root can play with this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcmd_first = _IOC_NR(AUTOFS_DEV_IOCTL_IOC_FIRST);\n\tcmd = _IOC_NR(command);\n\n\tif (_IOC_TYPE(command) != _IOC_TYPE(AUTOFS_DEV_IOCTL_IOC_FIRST) ||\n\t    cmd - cmd_first >= AUTOFS_DEV_IOCTL_IOC_COUNT) {\n\t\treturn -ENOTTY;\n\t}\n\n\t/* Copy the parameters into kernel space. */\n\tparam = copy_dev_ioctl(user);\n\tif (IS_ERR(param))\n\t\treturn PTR_ERR(param);\n\n\terr = validate_dev_ioctl(command, param);\n\tif (err)\n\t\tgoto out;\n\n\t/* The validate routine above always sets the version */\n\tif (cmd == AUTOFS_DEV_IOCTL_VERSION_CMD)\n\t\tgoto done;\n\n\tfn = lookup_dev_ioctl(cmd);\n\tif (!fn) {\n\t\tAUTOFS_WARN(\"unknown command 0x%08x\", command);\n\t\treturn -ENOTTY;\n\t}\n\n\tfp = NULL;\n\tsbi = NULL;\n\n\t/*\n\t * For obvious reasons the openmount can't have a file\n\t * descriptor yet. We don't take a reference to the\n\t * file during close to allow for immediate release.\n\t */\n\tif (cmd != AUTOFS_DEV_IOCTL_OPENMOUNT_CMD &&\n\t    cmd != AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD) {\n\t\tfp = fget(param->ioctlfd);\n\t\tif (!fp) {\n\t\t\tif (cmd == AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD)\n\t\t\t\tgoto cont;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsbi = autofs_dev_ioctl_sbi(fp);\n\t\tif (!sbi || sbi->magic != AUTOFS_SBI_MAGIC) {\n\t\t\terr = -EINVAL;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Admin needs to be able to set the mount catatonic in\n\t\t * order to be able to perform the re-open.\n\t\t */\n\t\tif (!autofs4_oz_mode(sbi) &&\n\t\t    cmd != AUTOFS_DEV_IOCTL_CATATONIC_CMD) {\n\t\t\terr = -EACCES;\n\t\t\tfput(fp);\n\t\t\tgoto out;\n\t\t}\n\t}\ncont:\n\terr = fn(fp, sbi, param);\n\n\tif (fp)\n\t\tfput(fp);\ndone:\n\tif (err >= 0 && copy_to_user(user, param, AUTOFS_DEV_IOCTL_SIZE))\n\t\terr = -EFAULT;\nout:\n\tfree_dev_ioctl(param);\n\treturn err;\n}"
  },
  {
    "function_name": "lookup_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "582-619",
    "snippet": "static ioctl_fn lookup_dev_ioctl(unsigned int cmd)\n{\n\tstatic struct {\n\t\tint cmd;\n\t\tioctl_fn fn;\n\t} _ioctls[] = {\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_VERSION_CMD), NULL},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOVER_CMD),\n\t\t\t autofs_dev_ioctl_protover},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD),\n\t\t\t autofs_dev_ioctl_protosubver},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_OPENMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_openmount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_closemount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_READY_CMD),\n\t\t\t autofs_dev_ioctl_ready},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_FAIL_CMD),\n\t\t\t autofs_dev_ioctl_fail},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_SETPIPEFD_CMD),\n\t\t\t autofs_dev_ioctl_setpipefd},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CATATONIC_CMD),\n\t\t\t autofs_dev_ioctl_catatonic},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_TIMEOUT_CMD),\n\t\t\t autofs_dev_ioctl_timeout},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_REQUESTER_CMD),\n\t\t\t autofs_dev_ioctl_requester},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_EXPIRE_CMD),\n\t\t\t autofs_dev_ioctl_expire},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_askumount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD),\n\t\t\t autofs_dev_ioctl_ismountpoint}\n\t};\n\tunsigned int idx = cmd_idx(cmd);\n\n\treturn (idx >= ARRAY_SIZE(_ioctls)) ? NULL : _ioctls[idx].fn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_ioctls"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "cmd"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_EXPIRE_CMD"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_REQUESTER_CMD"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_TIMEOUT_CMD"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_CATATONIC_CMD"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_SETPIPEFD_CMD"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_FAIL_CMD"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_READY_CMD"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_OPENMOUNT_CMD"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_PROTOVER_CMD"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_idx",
          "args": [
            "AUTOFS_DEV_IOCTL_VERSION_CMD"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic ioctl_fn lookup_dev_ioctl(unsigned int cmd)\n{\n\tstatic struct {\n\t\tint cmd;\n\t\tioctl_fn fn;\n\t} _ioctls[] = {\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_VERSION_CMD), NULL},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOVER_CMD),\n\t\t\t autofs_dev_ioctl_protover},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD),\n\t\t\t autofs_dev_ioctl_protosubver},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_OPENMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_openmount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_closemount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_READY_CMD),\n\t\t\t autofs_dev_ioctl_ready},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_FAIL_CMD),\n\t\t\t autofs_dev_ioctl_fail},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_SETPIPEFD_CMD),\n\t\t\t autofs_dev_ioctl_setpipefd},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_CATATONIC_CMD),\n\t\t\t autofs_dev_ioctl_catatonic},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_TIMEOUT_CMD),\n\t\t\t autofs_dev_ioctl_timeout},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_REQUESTER_CMD),\n\t\t\t autofs_dev_ioctl_requester},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_EXPIRE_CMD),\n\t\t\t autofs_dev_ioctl_expire},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD),\n\t\t\t autofs_dev_ioctl_askumount},\n\t\t{cmd_idx(AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD),\n\t\t\t autofs_dev_ioctl_ismountpoint}\n\t};\n\tunsigned int idx = cmd_idx(cmd);\n\n\treturn (idx >= ARRAY_SIZE(_ioctls)) ? NULL : _ioctls[idx].fn;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_ismountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "517-573",
    "snippet": "static int autofs_dev_ioctl_ismountpoint(struct file *fp,\n\t\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tstruct path path;\n\tconst char *name;\n\tunsigned int type;\n\tunsigned int devid, magic;\n\tint err = -ENOENT;\n\n\tif (param->size <= sizeof(*param)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tname = param->path;\n\ttype = param->ismountpoint.in.type;\n\n\tparam->ismountpoint.out.devid = devid = 0;\n\tparam->ismountpoint.out.magic = magic = 0;\n\n\tif (!fp || param->ioctlfd == -1) {\n\t\tif (autofs_type_any(type))\n\t\t\terr = kern_path_mountpoint(AT_FDCWD,\n\t\t\t\t\t\t   name, &path, LOOKUP_FOLLOW);\n\t\telse\n\t\t\terr = find_autofs_mount(name, &path,\n\t\t\t\t\t\ttest_by_type, &type);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdevid = new_encode_dev(path.dentry->d_sb->s_dev);\n\t\terr = 0;\n\t\tif (path.mnt->mnt_root == path.dentry) {\n\t\t\terr = 1;\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t\t}\n\t} else {\n\t\tdev_t dev = sbi->sb->s_dev;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdevid = new_encode_dev(dev);\n\n\t\terr = have_submounts(path.dentry);\n\n\t\tif (follow_down_one(&path))\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t}\n\n\tparam->ismountpoint.out.devid = devid;\n\tparam->ismountpoint.out.magic = magic;\n\tpath_put(&path);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_down_one",
          "args": [
            "&path"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1110-1123",
          "snippet": "int follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_submounts",
          "args": [
            "path.dentry"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "have_submounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1262-1269",
          "snippet": "int have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "dev"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_autofs_mount",
          "args": [
            "name",
            "&path",
            "test_by_dev",
            "&dev"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "find_autofs_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "194-218",
          "snippet": "static int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "path.dentry->d_sb->s_dev"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path_mountpoint",
          "args": [
            "AT_FDCWD",
            "name",
            "&path",
            "LOOKUP_FOLLOW"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2411-2416",
          "snippet": "int\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_type_any",
          "args": [
            "type"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_ismountpoint(struct file *fp,\n\t\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tstruct path path;\n\tconst char *name;\n\tunsigned int type;\n\tunsigned int devid, magic;\n\tint err = -ENOENT;\n\n\tif (param->size <= sizeof(*param)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tname = param->path;\n\ttype = param->ismountpoint.in.type;\n\n\tparam->ismountpoint.out.devid = devid = 0;\n\tparam->ismountpoint.out.magic = magic = 0;\n\n\tif (!fp || param->ioctlfd == -1) {\n\t\tif (autofs_type_any(type))\n\t\t\terr = kern_path_mountpoint(AT_FDCWD,\n\t\t\t\t\t\t   name, &path, LOOKUP_FOLLOW);\n\t\telse\n\t\t\terr = find_autofs_mount(name, &path,\n\t\t\t\t\t\ttest_by_type, &type);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdevid = new_encode_dev(path.dentry->d_sb->s_dev);\n\t\terr = 0;\n\t\tif (path.mnt->mnt_root == path.dentry) {\n\t\t\terr = 1;\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t\t}\n\t} else {\n\t\tdev_t dev = sbi->sb->s_dev;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &dev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdevid = new_encode_dev(dev);\n\n\t\terr = have_submounts(path.dentry);\n\n\t\tif (follow_down_one(&path))\n\t\t\tmagic = path.dentry->d_sb->s_magic;\n\t}\n\n\tparam->ismountpoint.out.devid = devid;\n\tparam->ismountpoint.out.magic = magic;\n\tpath_put(&path);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_askumount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "486-494",
    "snippet": "static int autofs_dev_ioctl_askumount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tparam->askumount.may_umount = 0;\n\tif (may_umount(fp->f_path.mnt))\n\t\tparam->askumount.may_umount = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "may_umount",
          "args": [
            "fp->f_path.mnt"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "may_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1304-1314",
          "snippet": "int may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_askumount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tparam->askumount.may_umount = 0;\n\tif (may_umount(fp->f_path.mnt))\n\t\tparam->askumount.may_umount = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "472-483",
    "snippet": "static int autofs_dev_ioctl_expire(struct file *fp,\n\t\t\t\t   struct autofs_sb_info *sbi,\n\t\t\t\t   struct autofs_dev_ioctl *param)\n{\n\tstruct vfsmount *mnt;\n\tint how;\n\n\thow = param->expire.how;\n\tmnt = fp->f_path.mnt;\n\n\treturn autofs4_do_expire_multi(sbi->sb, mnt, sbi, how);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_do_expire_multi",
          "args": [
            "sbi->sb",
            "mnt",
            "sbi",
            "how"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_do_expire_multi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "561-589",
          "snippet": "int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nint autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_expire(struct file *fp,\n\t\t\t\t   struct autofs_sb_info *sbi,\n\t\t\t\t   struct autofs_dev_ioctl *param)\n{\n\tstruct vfsmount *mnt;\n\tint how;\n\n\thow = param->expire.how;\n\tmnt = fp->f_path.mnt;\n\n\treturn autofs4_do_expire_multi(sbi->sb, mnt, sbi, how);\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_requester",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "432-466",
    "snippet": "static int autofs_dev_ioctl_requester(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tstruct autofs_info *ino;\n\tstruct path path;\n\tdev_t devid;\n\tint err = -ENOENT;\n\n\tif (param->size <= sizeof(*param)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdevid = sbi->sb->s_dev;\n\n\tparam->requester.uid = param->requester.gid = -1;\n\n\terr = find_autofs_mount(param->path, &path, test_by_dev, &devid);\n\tif (err)\n\t\tgoto out;\n\n\tino = autofs4_dentry_ino(path.dentry);\n\tif (ino) {\n\t\terr = 0;\n\t\tautofs4_expire_wait(path.dentry, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tparam->requester.uid = from_kuid_munged(current_user_ns(), ino->uid);\n\t\tparam->requester.gid = from_kgid_munged(current_user_ns(), ino->gid);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\tpath_put(&path);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "current_user_ns()",
            "ino->gid"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "ino->uid"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_expire_wait",
          "args": [
            "path.dentry",
            "0"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "490-521",
          "snippet": "int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nint autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "path.dentry"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_autofs_mount",
          "args": [
            "param->path",
            "&path",
            "test_by_dev",
            "&devid"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "find_autofs_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "194-218",
          "snippet": "static int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_requester(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tstruct autofs_info *ino;\n\tstruct path path;\n\tdev_t devid;\n\tint err = -ENOENT;\n\n\tif (param->size <= sizeof(*param)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdevid = sbi->sb->s_dev;\n\n\tparam->requester.uid = param->requester.gid = -1;\n\n\terr = find_autofs_mount(param->path, &path, test_by_dev, &devid);\n\tif (err)\n\t\tgoto out;\n\n\tino = autofs4_dentry_ino(path.dentry);\n\tif (ino) {\n\t\terr = 0;\n\t\tautofs4_expire_wait(path.dentry, 0);\n\t\tspin_lock(&sbi->fs_lock);\n\t\tparam->requester.uid = from_kuid_munged(current_user_ns(), ino->uid);\n\t\tparam->requester.gid = from_kgid_munged(current_user_ns(), ino->gid);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\tpath_put(&path);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "412-422",
    "snippet": "static int autofs_dev_ioctl_timeout(struct file *fp,\n\t\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t\t    struct autofs_dev_ioctl *param)\n{\n\tunsigned long timeout;\n\n\ttimeout = param->timeout.timeout;\n\tparam->timeout.timeout = sbi->exp_timeout / HZ;\n\tsbi->exp_timeout = timeout * HZ;\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_timeout(struct file *fp,\n\t\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t\t    struct autofs_dev_ioctl *param)\n{\n\tunsigned long timeout;\n\n\ttimeout = param->timeout.timeout;\n\tparam->timeout.timeout = sbi->exp_timeout / HZ;\n\tsbi->exp_timeout = timeout * HZ;\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_catatonic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "403-409",
    "snippet": "static int autofs_dev_ioctl_catatonic(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tautofs4_catatonic_mode(sbi);\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_catatonic_mode",
          "args": [
            "sbi"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_catatonic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "27-55",
          "snippet": "void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nvoid autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_catatonic(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tautofs4_catatonic_mode(sbi);\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_setpipefd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "350-397",
    "snippet": "static int autofs_dev_ioctl_setpipefd(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tint pipefd;\n\tint err = 0;\n\tstruct pid *new_pid = NULL;\n\n\tif (param->setpipefd.pipefd == -1)\n\t\treturn -EINVAL;\n\n\tpipefd = param->setpipefd.pipefd;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (!sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EBUSY;\n\t} else {\n\t\tstruct file *pipe;\n\n\t\tnew_pid = get_task_pid(current, PIDTYPE_PGID);\n\n\t\tif (ns_of_pid(new_pid) != ns_of_pid(sbi->oz_pgrp)) {\n\t\t\tAUTOFS_WARN(\"Not allowed to change PID namespace\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpipe = fget(pipefd);\n\t\tif (!pipe) {\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\t\tif (autofs_prepare_pipe(pipe) < 0) {\n\t\t\terr = -EPIPE;\n\t\t\tfput(pipe);\n\t\t\tgoto out;\n\t\t}\n\t\tswap(sbi->oz_pgrp, new_pid);\n\t\tsbi->pipefd = pipefd;\n\t\tsbi->pipe = pipe;\n\t\tsbi->catatonic = 0;\n\t}\nout:\n\tput_pid(new_pid);\n\tmutex_unlock(&sbi->wq_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "new_pid"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "sbi->oz_pgrp",
            "new_pid"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "pipe"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_prepare_pipe",
          "args": [
            "pipe"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_prepare_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "214-223",
          "snippet": "static inline int autofs_prepare_pipe(struct file *pipe)\n{\n\tif (!pipe->f_op->write)\n\t\treturn -EINVAL;\n\tif (!S_ISFIFO(file_inode(pipe)->i_mode))\n\t\treturn -EINVAL;\n\t/* We want a packet pipe */\n\tpipe->f_flags |= O_DIRECT;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstatic inline int autofs_prepare_pipe(struct file *pipe)\n{\n\tif (!pipe->f_op->write)\n\t\treturn -EINVAL;\n\tif (!S_ISFIFO(file_inode(pipe)->i_mode))\n\t\treturn -EINVAL;\n\t/* We want a packet pipe */\n\tpipe->f_flags |= O_DIRECT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "pipefd"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"Not allowed to change PID namespace\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "new_pid"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_pid",
          "args": [
            "current",
            "PIDTYPE_PGID"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_setpipefd(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tint pipefd;\n\tint err = 0;\n\tstruct pid *new_pid = NULL;\n\n\tif (param->setpipefd.pipefd == -1)\n\t\treturn -EINVAL;\n\n\tpipefd = param->setpipefd.pipefd;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (!sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EBUSY;\n\t} else {\n\t\tstruct file *pipe;\n\n\t\tnew_pid = get_task_pid(current, PIDTYPE_PGID);\n\n\t\tif (ns_of_pid(new_pid) != ns_of_pid(sbi->oz_pgrp)) {\n\t\t\tAUTOFS_WARN(\"Not allowed to change PID namespace\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpipe = fget(pipefd);\n\t\tif (!pipe) {\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t}\n\t\tif (autofs_prepare_pipe(pipe) < 0) {\n\t\t\terr = -EPIPE;\n\t\t\tfput(pipe);\n\t\t\tgoto out;\n\t\t}\n\t\tswap(sbi->oz_pgrp, new_pid);\n\t\tsbi->pipefd = pipefd;\n\t\tsbi->pipe = pipe;\n\t\tsbi->catatonic = 0;\n\t}\nout:\n\tput_pid(new_pid);\n\tmutex_unlock(&sbi->wq_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "326-336",
    "snippet": "static int autofs_dev_ioctl_fail(struct file *fp,\n\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\tint status;\n\n\ttoken = (autofs_wqt_t) param->fail.token;\n\tstatus = param->fail.status ? param->fail.status : -ENOENT;\n\treturn autofs4_wait_release(sbi, token, status);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_wait_release",
          "args": [
            "sbi",
            "token",
            "status"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_fail(struct file *fp,\n\t\t\t\t struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\tint status;\n\n\ttoken = (autofs_wqt_t) param->fail.token;\n\tstatus = param->fail.status ? param->fail.status : -ENOENT;\n\treturn autofs4_wait_release(sbi, token, status);\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "312-320",
    "snippet": "static int autofs_dev_ioctl_ready(struct file *fp,\n\t\t\t\t  struct autofs_sb_info *sbi,\n\t\t\t\t  struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\n\ttoken = (autofs_wqt_t) param->ready.token;\n\treturn autofs4_wait_release(sbi, token, 0);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_wait_release",
          "args": [
            "sbi",
            "token",
            "0"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_ready(struct file *fp,\n\t\t\t\t  struct autofs_sb_info *sbi,\n\t\t\t\t  struct autofs_dev_ioctl *param)\n{\n\tautofs_wqt_t token;\n\n\ttoken = (autofs_wqt_t) param->ready.token;\n\treturn autofs4_wait_release(sbi, token, 0);\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_closemount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "301-306",
    "snippet": "static int autofs_dev_ioctl_closemount(struct file *fp,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       struct autofs_dev_ioctl *param)\n{\n\treturn sys_close(param->ioctlfd);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sys_close",
          "args": [
            "param->ioctlfd"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_closemount(struct file *fp,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       struct autofs_dev_ioctl *param)\n{\n\treturn sys_close(param->ioctlfd);\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_openmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "271-298",
    "snippet": "static int autofs_dev_ioctl_openmount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tconst char *path;\n\tdev_t devid;\n\tint err, fd;\n\n\t/* param->path has already been checked */\n\tif (!param->openmount.devid)\n\t\treturn -EINVAL;\n\n\tparam->ioctlfd = -1;\n\n\tpath = param->path;\n\tdevid = new_decode_dev(param->openmount.devid);\n\n\terr = 0;\n\tfd = autofs_dev_ioctl_open_mountpoint(path, devid);\n\tif (unlikely(fd < 0)) {\n\t\terr = fd;\n\t\tgoto out;\n\t}\n\n\tparam->ioctlfd = fd;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fd < 0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_dev_ioctl_open_mountpoint",
          "args": [
            "path",
            "devid"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "autofs_dev_ioctl_open_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "235-268",
          "snippet": "static int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\n{\n\tint err, fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (likely(fd >= 0)) {\n\t\tstruct file *filp;\n\t\tstruct path path;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &devid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Find autofs super block that has the device number\n\t\t * corresponding to the autofs fs we want to open.\n\t\t */\n\n\t\tfilp = dentry_open(&path, O_RDONLY, current_cred());\n\t\tpath_put(&path);\n\t\tif (IS_ERR(filp)) {\n\t\t\terr = PTR_ERR(filp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfd_install(fd, filp);\n\t}\n\n\treturn fd;\n\nout:\n\tput_unused_fd(fd);\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\n{\n\tint err, fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (likely(fd >= 0)) {\n\t\tstruct file *filp;\n\t\tstruct path path;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &devid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Find autofs super block that has the device number\n\t\t * corresponding to the autofs fs we want to open.\n\t\t */\n\n\t\tfilp = dentry_open(&path, O_RDONLY, current_cred());\n\t\tpath_put(&path);\n\t\tif (IS_ERR(filp)) {\n\t\t\terr = PTR_ERR(filp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfd_install(fd, filp);\n\t}\n\n\treturn fd;\n\nout:\n\tput_unused_fd(fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "param->openmount.devid"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_openmount(struct file *fp,\n\t\t\t\t      struct autofs_sb_info *sbi,\n\t\t\t\t      struct autofs_dev_ioctl *param)\n{\n\tconst char *path;\n\tdev_t devid;\n\tint err, fd;\n\n\t/* param->path has already been checked */\n\tif (!param->openmount.devid)\n\t\treturn -EINVAL;\n\n\tparam->ioctlfd = -1;\n\n\tpath = param->path;\n\tdevid = new_decode_dev(param->openmount.devid);\n\n\terr = 0;\n\tfd = autofs_dev_ioctl_open_mountpoint(path, devid);\n\tif (unlikely(fd < 0)) {\n\t\terr = fd;\n\t\tgoto out;\n\t}\n\n\tparam->ioctlfd = fd;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_open_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "235-268",
    "snippet": "static int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\n{\n\tint err, fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (likely(fd >= 0)) {\n\t\tstruct file *filp;\n\t\tstruct path path;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &devid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Find autofs super block that has the device number\n\t\t * corresponding to the autofs fs we want to open.\n\t\t */\n\n\t\tfilp = dentry_open(&path, O_RDONLY, current_cred());\n\t\tpath_put(&path);\n\t\tif (IS_ERR(filp)) {\n\t\t\terr = PTR_ERR(filp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfd_install(fd, filp);\n\t}\n\n\treturn fd;\n\nout:\n\tput_unused_fd(fd);\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "filp"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "O_RDONLY",
            "current_cred()"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_autofs_mount",
          "args": [
            "name",
            "&path",
            "test_by_dev",
            "&devid"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "find_autofs_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "194-218",
          "snippet": "static int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fd >= 0"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "O_CLOEXEC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "508-511",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_open_mountpoint(const char *name, dev_t devid)\n{\n\tint err, fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (likely(fd >= 0)) {\n\t\tstruct file *filp;\n\t\tstruct path path;\n\n\t\terr = find_autofs_mount(name, &path, test_by_dev, &devid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Find autofs super block that has the device number\n\t\t * corresponding to the autofs fs we want to open.\n\t\t */\n\n\t\tfilp = dentry_open(&path, O_RDONLY, current_cred());\n\t\tpath_put(&path);\n\t\tif (IS_ERR(filp)) {\n\t\t\terr = PTR_ERR(filp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfd_install(fd, filp);\n\t}\n\n\treturn fd;\n\nout:\n\tput_unused_fd(fd);\n\treturn err;\n}"
  },
  {
    "function_name": "test_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "225-229",
    "snippet": "static int test_by_type(struct path *path, void *p)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(path->dentry);\n\treturn ino && ino->sbi->type & *(unsigned *)p;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "path->dentry"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int test_by_type(struct path *path, void *p)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(path->dentry);\n\treturn ino && ino->sbi->type & *(unsigned *)p;\n}"
  },
  {
    "function_name": "test_by_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "220-223",
    "snippet": "static int test_by_dev(struct path *path, void *p)\n{\n\treturn path->dentry->d_sb->s_dev == *(dev_t *)p;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int test_by_dev(struct path *path, void *p)\n{\n\treturn path->dentry->d_sb->s_dev == *(dev_t *)p;\n}"
  },
  {
    "function_name": "find_autofs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "194-218",
    "snippet": "static int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_up",
          "args": [
            "&path"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "follow_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "941-961",
          "snippet": "int follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&path"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test",
          "args": [
            "&path",
            "data"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "test_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "225-229",
          "snippet": "static int test_by_type(struct path *path, void *p)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(path->dentry);\n\treturn ino && ino->sbi->type & *(unsigned *)p;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int test_by_type(struct path *path, void *p)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(path->dentry);\n\treturn ino && ino->sbi->type & *(unsigned *)p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_path_mountpoint",
          "args": [
            "AT_FDCWD",
            "pathname",
            "&path",
            "0"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2411-2416",
          "snippet": "int\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\treturn filename_mountpoint(dfd, getname_kernel(name), path, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int find_autofs_mount(const char *pathname,\n\t\t\t     struct path *res,\n\t\t\t     int test(struct path *path, void *data),\n\t\t\t     void *data)\n{\n\tstruct path path;\n\tint err = kern_path_mountpoint(AT_FDCWD, pathname, &path, 0);\n\tif (err)\n\t\treturn err;\n\terr = -ENOENT;\n\twhile (path.dentry == path.mnt->mnt_root) {\n\t\tif (path.dentry->d_sb->s_magic == AUTOFS_SUPER_MAGIC) {\n\t\t\tif (test(&path, data)) {\n\t\t\t\tpath_get(&path);\n\t\t\t\t*res = path;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!follow_up(&path))\n\t\t\tbreak;\n\t}\n\tpath_put(&path);\n\treturn err;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_protosubver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "185-191",
    "snippet": "static int autofs_dev_ioctl_protosubver(struct file *fp,\n\t\t\t\t\tstruct autofs_sb_info *sbi,\n\t\t\t\t\tstruct autofs_dev_ioctl *param)\n{\n\tparam->protosubver.sub_version = sbi->sub_version;\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_protosubver(struct file *fp,\n\t\t\t\t\tstruct autofs_sb_info *sbi,\n\t\t\t\t\tstruct autofs_dev_ioctl *param)\n{\n\tparam->protosubver.sub_version = sbi->sub_version;\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_protover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "176-182",
    "snippet": "static int autofs_dev_ioctl_protover(struct file *fp,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     struct autofs_dev_ioctl *param)\n{\n\tparam->protover.version = sbi->version;\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int autofs_dev_ioctl_protover(struct file *fp,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     struct autofs_dev_ioctl *param)\n{\n\tparam->protover.version = sbi->version;\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs_dev_ioctl_sbi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "163-173",
    "snippet": "static struct autofs_sb_info *autofs_dev_ioctl_sbi(struct file *f)\n{\n\tstruct autofs_sb_info *sbi = NULL;\n\tstruct inode *inode;\n\n\tif (f) {\n\t\tinode = file_inode(f);\n\t\tsbi = autofs4_sbi(inode->i_sb);\n\t}\n\treturn sbi;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "inode->i_sb"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct autofs_sb_info *autofs_dev_ioctl_sbi(struct file *f)\n{\n\tstruct autofs_sb_info *sbi = NULL;\n\tstruct inode *inode;\n\n\tif (f) {\n\t\tinode = file_inode(f);\n\t\tsbi = autofs4_sbi(inode->i_sb);\n\t}\n\treturn sbi;\n}"
  },
  {
    "function_name": "validate_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "126-157",
    "snippet": "static int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err;\n\n\terr = check_dev_ioctl_version(cmd, param);\n\tif (err) {\n\t\tAUTOFS_WARN(\"invalid device control module version \"\n\t\t     \"supplied for cmd(0x%08x)\", cmd);\n\t\tgoto out;\n\t}\n\n\tif (param->size > sizeof(*param)) {\n\t\terr = invalid_str(param->path, param->size - sizeof(*param));\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\n\t\t\t  \"path string terminator missing for cmd(0x%08x)\",\n\t\t\t  cmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = check_name(param->path);\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\"invalid path supplied for cmd(0x%08x)\",\n\t\t\t\t    cmd);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"invalid path supplied for cmd(0x%08x)\"",
            "cmd"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_name",
          "args": [
            "param->path"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "46-51",
          "snippet": "static int check_name(const char *name)\n{\n\tif (!strchr(name, '/'))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int check_name(const char *name)\n{\n\tif (!strchr(name, '/'))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"path string terminator missing for cmd(0x%08x)\"",
            "cmd"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_str",
          "args": [
            "param->path",
            "param->size - sizeof(*param)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "57-62",
          "snippet": "static int invalid_str(char *str, size_t size)\n{\n\tif (memchr(str, 0, size))\n\t\treturn 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int invalid_str(char *str, size_t size)\n{\n\tif (memchr(str, 0, size))\n\t\treturn 0;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"invalid device control module version \"\n\t\t     \"supplied for cmd(0x%08x)\"",
            "cmd"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dev_ioctl_version",
          "args": [
            "cmd",
            "param"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "check_dev_ioctl_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
          "lines": "71-90",
          "snippet": "static int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err = 0;\n\n\tif ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||\n\t    (AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {\n\t\tAUTOFS_WARN(\"ioctl control interface version mismatch: \"\n\t\t     \"kernel(%u.%u), user(%u.%u), cmd(%d)\",\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MAJOR,\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MINOR,\n\t\t     param->ver_major, param->ver_minor, cmd);\n\t\terr = -EINVAL;\n\t}\n\n\t/* Fill in the kernel version. */\n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\n\treturn err;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err = 0;\n\n\tif ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||\n\t    (AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {\n\t\tAUTOFS_WARN(\"ioctl control interface version mismatch: \"\n\t\t     \"kernel(%u.%u), user(%u.%u), cmd(%d)\",\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MAJOR,\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MINOR,\n\t\t     param->ver_major, param->ver_minor, cmd);\n\t\terr = -EINVAL;\n\t}\n\n\t/* Fill in the kernel version. */\n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int validate_dev_ioctl(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err;\n\n\terr = check_dev_ioctl_version(cmd, param);\n\tif (err) {\n\t\tAUTOFS_WARN(\"invalid device control module version \"\n\t\t     \"supplied for cmd(0x%08x)\", cmd);\n\t\tgoto out;\n\t}\n\n\tif (param->size > sizeof(*param)) {\n\t\terr = invalid_str(param->path, param->size - sizeof(*param));\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\n\t\t\t  \"path string terminator missing for cmd(0x%08x)\",\n\t\t\t  cmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = check_name(param->path);\n\t\tif (err) {\n\t\t\tAUTOFS_WARN(\"invalid path supplied for cmd(0x%08x)\",\n\t\t\t\t    cmd);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "free_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "116-120",
    "snippet": "static inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\n{\n\tkfree(param);\n\treturn;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "param"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic inline void free_dev_ioctl(struct autofs_dev_ioctl *param)\n{\n\tkfree(param);\n\treturn;\n}"
  },
  {
    "function_name": "copy_dev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "96-114",
    "snippet": "static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)\n{\n\tstruct autofs_dev_ioctl tmp, *res;\n\n\tif (copy_from_user(&tmp, in, sizeof(tmp)))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (tmp.size < sizeof(tmp))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tmp.size > (PATH_MAX + sizeof(tmp)))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = memdup_user(in, tmp.size);\n\tif (!IS_ERR(res))\n\t\tres->size = tmp.size;\n\n\treturn res;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "in",
            "tmp.size"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tmp",
            "in",
            "sizeof(tmp)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)\n{\n\tstruct autofs_dev_ioctl tmp, *res;\n\n\tif (copy_from_user(&tmp, in, sizeof(tmp)))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (tmp.size < sizeof(tmp))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tmp.size > (PATH_MAX + sizeof(tmp)))\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tres = memdup_user(in, tmp.size);\n\tif (!IS_ERR(res))\n\t\tres->size = tmp.size;\n\n\treturn res;\n}"
  },
  {
    "function_name": "check_dev_ioctl_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "71-90",
    "snippet": "static int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err = 0;\n\n\tif ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||\n\t    (AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {\n\t\tAUTOFS_WARN(\"ioctl control interface version mismatch: \"\n\t\t     \"kernel(%u.%u), user(%u.%u), cmd(%d)\",\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MAJOR,\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MINOR,\n\t\t     param->ver_major, param->ver_minor, cmd);\n\t\terr = -EINVAL;\n\t}\n\n\t/* Fill in the kernel version. */\n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\n\treturn err;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUTOFS_WARN",
          "args": [
            "\"ioctl control interface version mismatch: \"\n\t\t     \"kernel(%u.%u), user(%u.%u), cmd(%d)\"",
            "AUTOFS_DEV_IOCTL_VERSION_MAJOR",
            "AUTOFS_DEV_IOCTL_VERSION_MINOR",
            "param->ver_major",
            "param->ver_minor",
            "cmd"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)\n{\n\tint err = 0;\n\n\tif ((AUTOFS_DEV_IOCTL_VERSION_MAJOR != param->ver_major) ||\n\t    (AUTOFS_DEV_IOCTL_VERSION_MINOR < param->ver_minor)) {\n\t\tAUTOFS_WARN(\"ioctl control interface version mismatch: \"\n\t\t     \"kernel(%u.%u), user(%u.%u), cmd(%d)\",\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MAJOR,\n\t\t     AUTOFS_DEV_IOCTL_VERSION_MINOR,\n\t\t     param->ver_major, param->ver_minor, cmd);\n\t\terr = -EINVAL;\n\t}\n\n\t/* Fill in the kernel version. */\n\tparam->ver_major = AUTOFS_DEV_IOCTL_VERSION_MAJOR;\n\tparam->ver_minor = AUTOFS_DEV_IOCTL_VERSION_MINOR;\n\n\treturn err;\n}"
  },
  {
    "function_name": "invalid_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "57-62",
    "snippet": "static int invalid_str(char *str, size_t size)\n{\n\tif (memchr(str, 0, size))\n\t\treturn 0;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "str",
            "0",
            "size"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int invalid_str(char *str, size_t size)\n{\n\tif (memchr(str, 0, size))\n\t\treturn 0;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "check_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/dev-ioctl.c",
    "lines": "46-51",
    "snippet": "static int check_name(const char *name)\n{\n\tif (!strchr(name, '/'))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/namei.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\nstatic int check_name(const char *name)\n{\n\tif (!strchr(name, '/'))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  }
]