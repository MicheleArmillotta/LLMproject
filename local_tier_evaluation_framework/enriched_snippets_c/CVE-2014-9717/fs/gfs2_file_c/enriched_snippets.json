[
  {
    "function_name": "gfs2_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "1051-1064",
    "snippet": "static int gfs2_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\tif (fl->fl_type & LOCK_MAND)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fl->fl_type == F_UNLCK) {\n\t\tdo_unflock(file, fl);\n\t\treturn 0;\n\t} else {\n\t\treturn do_flock(file, cmd, fl);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_flock",
          "args": [
            "file",
            "cmd",
            "fl"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "do_flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "974-1026",
          "snippet": "static int do_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tstruct gfs2_glock *gl;\n\tunsigned int state;\n\tint flags;\n\tint error = 0;\n\tint sleeptime;\n\n\tstate = (fl->fl_type == F_WRLCK) ? LM_ST_EXCLUSIVE : LM_ST_SHARED;\n\tflags = (IS_SETLKW(cmd) ? 0 : LM_FLAG_TRY_1CB) | GL_EXACT;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\n\tgl = fl_gh->gh_gl;\n\tif (gl) {\n\t\tif (fl_gh->gh_state == state)\n\t\t\tgoto out;\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_reinit(state, flags, fl_gh);\n\t} else {\n\t\terror = gfs2_glock_get(GFS2_SB(&ip->i_inode), ip->i_no_addr,\n\t\t\t\t       &gfs2_flock_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgfs2_holder_init(gl, state, flags, fl_gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\tfor (sleeptime = 1; sleeptime <= 4; sleeptime <<= 1) {\n\t\terror = gfs2_glock_nq(fl_gh);\n\t\tif (error != GLR_TRYFAILED)\n\t\t\tbreak;\n\t\tfl_gh->gh_flags = LM_FLAG_TRY | GL_EXACT;\n\t\tfl_gh->gh_error = 0;\n\t\tmsleep(sleeptime);\n\t}\n\tif (error) {\n\t\tgfs2_holder_uninit(fl_gh);\n\t\tif (error == GLR_TRYFAILED)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = flock_lock_file_wait(file, fl);\n\t\tgfs2_assert_warn(GFS2_SB(&ip->i_inode), !error);\n\t}\n\nout:\n\tmutex_unlock(&fp->f_fl_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int do_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tstruct gfs2_glock *gl;\n\tunsigned int state;\n\tint flags;\n\tint error = 0;\n\tint sleeptime;\n\n\tstate = (fl->fl_type == F_WRLCK) ? LM_ST_EXCLUSIVE : LM_ST_SHARED;\n\tflags = (IS_SETLKW(cmd) ? 0 : LM_FLAG_TRY_1CB) | GL_EXACT;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\n\tgl = fl_gh->gh_gl;\n\tif (gl) {\n\t\tif (fl_gh->gh_state == state)\n\t\t\tgoto out;\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_reinit(state, flags, fl_gh);\n\t} else {\n\t\terror = gfs2_glock_get(GFS2_SB(&ip->i_inode), ip->i_no_addr,\n\t\t\t\t       &gfs2_flock_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgfs2_holder_init(gl, state, flags, fl_gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\tfor (sleeptime = 1; sleeptime <= 4; sleeptime <<= 1) {\n\t\terror = gfs2_glock_nq(fl_gh);\n\t\tif (error != GLR_TRYFAILED)\n\t\t\tbreak;\n\t\tfl_gh->gh_flags = LM_FLAG_TRY | GL_EXACT;\n\t\tfl_gh->gh_error = 0;\n\t\tmsleep(sleeptime);\n\t}\n\tif (error) {\n\t\tgfs2_holder_uninit(fl_gh);\n\t\tif (error == GLR_TRYFAILED)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = flock_lock_file_wait(file, fl);\n\t\tgfs2_assert_warn(GFS2_SB(&ip->i_inode), !error);\n\t}\n\nout:\n\tmutex_unlock(&fp->f_fl_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unflock",
          "args": [
            "file",
            "fl"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "do_unflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "1028-1040",
          "snippet": "static void do_unflock(struct file *file, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\tflock_lock_file_wait(file, fl);\n\tif (fl_gh->gh_gl) {\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_uninit(fl_gh);\n\t}\n\tmutex_unlock(&fp->f_fl_mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void do_unflock(struct file *file, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\tflock_lock_file_wait(file, fl);\n\tif (fl_gh->gh_gl) {\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_uninit(fl_gh);\n\t}\n\tmutex_unlock(&fp->f_fl_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\tif (fl->fl_type & LOCK_MAND)\n\t\treturn -EOPNOTSUPP;\n\n\tif (fl->fl_type == F_UNLCK) {\n\t\tdo_unflock(file, fl);\n\t\treturn 0;\n\t} else {\n\t\treturn do_flock(file, cmd, fl);\n\t}\n}"
  },
  {
    "function_name": "do_unflock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "1028-1040",
    "snippet": "static void do_unflock(struct file *file, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\tflock_lock_file_wait(file, fl);\n\tif (fl_gh->gh_gl) {\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_uninit(fl_gh);\n\t}\n\tmutex_unlock(&fp->f_fl_mutex);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fp->f_fl_mutex"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "fl_gh"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "fl_gh"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fp->f_fl_mutex"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void do_unflock(struct file *file, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\tflock_lock_file_wait(file, fl);\n\tif (fl_gh->gh_gl) {\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_uninit(fl_gh);\n\t}\n\tmutex_unlock(&fp->f_fl_mutex);\n}"
  },
  {
    "function_name": "do_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "974-1026",
    "snippet": "static int do_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tstruct gfs2_glock *gl;\n\tunsigned int state;\n\tint flags;\n\tint error = 0;\n\tint sleeptime;\n\n\tstate = (fl->fl_type == F_WRLCK) ? LM_ST_EXCLUSIVE : LM_ST_SHARED;\n\tflags = (IS_SETLKW(cmd) ? 0 : LM_FLAG_TRY_1CB) | GL_EXACT;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\n\tgl = fl_gh->gh_gl;\n\tif (gl) {\n\t\tif (fl_gh->gh_state == state)\n\t\t\tgoto out;\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_reinit(state, flags, fl_gh);\n\t} else {\n\t\terror = gfs2_glock_get(GFS2_SB(&ip->i_inode), ip->i_no_addr,\n\t\t\t\t       &gfs2_flock_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgfs2_holder_init(gl, state, flags, fl_gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\tfor (sleeptime = 1; sleeptime <= 4; sleeptime <<= 1) {\n\t\terror = gfs2_glock_nq(fl_gh);\n\t\tif (error != GLR_TRYFAILED)\n\t\t\tbreak;\n\t\tfl_gh->gh_flags = LM_FLAG_TRY | GL_EXACT;\n\t\tfl_gh->gh_error = 0;\n\t\tmsleep(sleeptime);\n\t}\n\tif (error) {\n\t\tgfs2_holder_uninit(fl_gh);\n\t\tif (error == GLR_TRYFAILED)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = flock_lock_file_wait(file, fl);\n\t\tgfs2_assert_warn(GFS2_SB(&ip->i_inode), !error);\n\t}\n\nout:\n\tmutex_unlock(&fp->f_fl_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fp->f_fl_mutex"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "!error"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "fl_gh"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "sleeptime"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "fl_gh"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "gl"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "gl",
            "state",
            "flags",
            "fl_gh"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "ip->i_no_addr",
            "&gfs2_flock_glops",
            "CREATE",
            "&gl"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_reinit",
          "args": [
            "state",
            "flags",
            "fl_gh"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "825-833",
          "snippet": "void gfs2_holder_reinit(unsigned int state, unsigned flags, struct gfs2_holder *gh)\n{\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_iflags = 0;\n\tgh->gh_ip = _RET_IP_;\n\tput_pid(gh->gh_owner_pid);\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_reinit(unsigned int state, unsigned flags, struct gfs2_holder *gh)\n{\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_iflags = 0;\n\tgh->gh_ip = _RET_IP_;\n\tput_pid(gh->gh_owner_pid);\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "fl_gh"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fp->f_fl_mutex"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int do_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tstruct gfs2_glock *gl;\n\tunsigned int state;\n\tint flags;\n\tint error = 0;\n\tint sleeptime;\n\n\tstate = (fl->fl_type == F_WRLCK) ? LM_ST_EXCLUSIVE : LM_ST_SHARED;\n\tflags = (IS_SETLKW(cmd) ? 0 : LM_FLAG_TRY_1CB) | GL_EXACT;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\n\tgl = fl_gh->gh_gl;\n\tif (gl) {\n\t\tif (fl_gh->gh_state == state)\n\t\t\tgoto out;\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_reinit(state, flags, fl_gh);\n\t} else {\n\t\terror = gfs2_glock_get(GFS2_SB(&ip->i_inode), ip->i_no_addr,\n\t\t\t\t       &gfs2_flock_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgfs2_holder_init(gl, state, flags, fl_gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\tfor (sleeptime = 1; sleeptime <= 4; sleeptime <<= 1) {\n\t\terror = gfs2_glock_nq(fl_gh);\n\t\tif (error != GLR_TRYFAILED)\n\t\t\tbreak;\n\t\tfl_gh->gh_flags = LM_FLAG_TRY | GL_EXACT;\n\t\tfl_gh->gh_error = 0;\n\t\tmsleep(sleeptime);\n\t}\n\tif (error) {\n\t\tgfs2_holder_uninit(fl_gh);\n\t\tif (error == GLR_TRYFAILED)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = flock_lock_file_wait(file, fl);\n\t\tgfs2_assert_warn(GFS2_SB(&ip->i_inode), !error);\n\t}\n\nout:\n\tmutex_unlock(&fp->f_fl_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "945-972",
    "snippet": "static int gfs2_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(file->f_mapping->host);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(&ip->i_inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif (cmd == F_CANCELLK) {\n\t\t/* Hack: */\n\t\tcmd = F_SETLK;\n\t\tfl->fl_type = F_UNLCK;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\tif (fl->fl_type == F_UNLCK)\n\t\t\tposix_lock_file_wait(file, fl);\n\t\treturn -EIO;\n\t}\n\tif (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse\n\t\treturn dlm_posix_lock(ls->ls_dlm, ip->i_no_addr, file, cmd, fl);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_posix_lock",
          "args": [
            "ls->ls_dlm",
            "ip->i_no_addr",
            "file",
            "cmd",
            "fl"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "104-184",
          "snippet": "int dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_posix_unlock",
          "args": [
            "ls->ls_dlm",
            "ip->i_no_addr",
            "file",
            "fl"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "244-315",
          "snippet": "int dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_posix_get",
          "args": [
            "ls->ls_dlm",
            "ip->i_no_addr",
            "file",
            "fl"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "318-380",
          "snippet": "int dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(SDF_SHUTDOWN, &sdp->sd_flags)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "&ip->i_inode"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(file->f_mapping->host);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(&ip->i_inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tif (cmd == F_CANCELLK) {\n\t\t/* Hack: */\n\t\tcmd = F_SETLK;\n\t\tfl->fl_type = F_UNLCK;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\tif (fl->fl_type == F_UNLCK)\n\t\t\tposix_lock_file_wait(file, fl);\n\t\treturn -EIO;\n\t}\n\tif (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse\n\t\treturn dlm_posix_lock(ls->ls_dlm, ip->i_no_addr, file, cmd, fl);\n}"
  },
  {
    "function_name": "gfs2_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "889-932",
    "snippet": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    (offset + len) > inode->i_size) {\n\t\tret = inode_newsize_ok(inode, offset + len);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out_putw;\n\n\tret = __gfs2_fallocate(file, mode, offset, len);\n\tif (ret)\n\t\tgfs2_rs_deltree(ip->i_res);\nout_putw:\n\tput_write_access(inode);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_deltree",
          "args": [
            "ip->i_res"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "668-678",
          "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_fallocate",
          "args": [
            "file",
            "mode",
            "offset",
            "len"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "793-887",
          "snippet": "static long __gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tint error;\n\tconst loff_t pos = offset;\n\tconst loff_t count = len;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_size_hint(file, offset, len);\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tif (!gfs2_write_alloc_required(ip, offset, bytes)) {\n\t\t\tlen -= bytes;\n\t\t\toffset += bytes;\n\t\t\tcontinue;\n\t\t}\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tap.target = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && (pos + count) > inode->i_size) {\n\t\ti_size_write(inode, pos + count);\n\t\t/* Marks the inode as dirty */\n\t\tfile_update_time(file);\n\t}\n\n\treturn generic_write_sync(file, pos, count);\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic long __gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tint error;\n\tconst loff_t pos = offset;\n\tconst loff_t count = len;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_size_hint(file, offset, len);\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tif (!gfs2_write_alloc_required(ip, offset, bytes)) {\n\t\t\tlen -= bytes;\n\t\t\toffset += bytes;\n\t\t\tcontinue;\n\t\t}\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tap.target = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && (pos + count) > inode->i_size) {\n\t\ti_size_write(inode, pos + count);\n\t\t/* Marks the inode as dirty */\n\t\tfile_update_time(file);\n\t}\n\n\treturn generic_write_sync(file, pos, count);\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "offset + len"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic long gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    (offset + len) > inode->i_size) {\n\t\tret = inode_newsize_ok(inode, offset + len);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out_putw;\n\n\tret = __gfs2_fallocate(file, mode, offset, len);\n\tif (ret)\n\t\tgfs2_rs_deltree(ip->i_res);\nout_putw:\n\tput_write_access(inode);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__gfs2_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "793-887",
    "snippet": "static long __gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tint error;\n\tconst loff_t pos = offset;\n\tconst loff_t count = len;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_size_hint(file, offset, len);\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tif (!gfs2_write_alloc_required(ip, offset, bytes)) {\n\t\t\tlen -= bytes;\n\t\t\toffset += bytes;\n\t\t\tcontinue;\n\t\t}\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tap.target = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && (pos + count) > inode->i_size) {\n\t\ti_size_write(inode, pos + count);\n\t\t/* Marks the inode as dirty */\n\t\tfile_update_time(file);\n\t}\n\n\treturn generic_write_sync(file, pos, count);\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "pos",
            "count"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + count"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fallocate_chunk",
          "args": [
            "inode",
            "offset",
            "max_bytes",
            "mode"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "fallocate_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "725-767",
          "snippet": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrelse(dibh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rblocks",
            "PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "data_blocks + ind_blocks"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_max_reserv",
          "args": [
            "ip",
            "(len > max_chunk_size)? max_chunk_size: len",
            "&max_bytes",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "calc_max_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "769-791",
          "snippet": "static void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,\n\t\t\t    unsigned int *data_blocks, unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int max_blocks = ip->i_rgd->rd_free_clone;\n\tunsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = max_data; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\tmax_data -= tmp;\n\t}\n\t/* This calculation isn't the exact reverse of gfs2_write_calc_reserve,\n\t   so it might end up with fewer data blocks */\n\tif (max_data <= *data_blocks)\n\t\treturn;\n\t*data_blocks = max_data;\n\t*ind_blocks = max_blocks - max_data;\n\t*len = ((loff_t)max_data - 3) << sdp->sd_sb.sb_bsize_shift;\n\tif (*len > max) {\n\t\t*len = max;\n\t\tgfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,\n\t\t\t    unsigned int *data_blocks, unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int max_blocks = ip->i_rgd->rd_free_clone;\n\tunsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = max_data; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\tmax_data -= tmp;\n\t}\n\t/* This calculation isn't the exact reverse of gfs2_write_calc_reserve,\n\t   so it might end up with fewer data blocks */\n\tif (max_data <= *data_blocks)\n\t\treturn;\n\t*data_blocks = max_data;\n\t*ind_blocks = max_blocks - max_data;\n\t*len = ((loff_t)max_data - 3) << sdp->sd_sb.sb_bsize_shift;\n\tif (*len > max) {\n\t\t*len = max;\n\t\tgfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "bytes",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_alloc_required",
          "args": [
            "ip",
            "offset",
            "bytes"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1455-1494",
          "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_size_hint",
          "args": [
            "file",
            "offset",
            "len"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_size_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "332-342",
          "snippet": "static void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic long __gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tint error;\n\tconst loff_t pos = offset;\n\tconst loff_t count = len;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_size_hint(file, offset, len);\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tif (!gfs2_write_alloc_required(ip, offset, bytes)) {\n\t\t\tlen -= bytes;\n\t\t\toffset += bytes;\n\t\t\tcontinue;\n\t\t}\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\treturn error;\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tap.target = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && (pos + count) > inode->i_size) {\n\t\ti_size_write(inode, pos + count);\n\t\t/* Marks the inode as dirty */\n\t\tfile_update_time(file);\n\t}\n\n\treturn generic_write_sync(file, pos, count);\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "calc_max_reserv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "769-791",
    "snippet": "static void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,\n\t\t\t    unsigned int *data_blocks, unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int max_blocks = ip->i_rgd->rd_free_clone;\n\tunsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = max_data; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\tmax_data -= tmp;\n\t}\n\t/* This calculation isn't the exact reverse of gfs2_write_calc_reserve,\n\t   so it might end up with fewer data blocks */\n\tif (max_data <= *data_blocks)\n\t\treturn;\n\t*data_blocks = max_data;\n\t*ind_blocks = max_blocks - max_data;\n\t*len = ((loff_t)max_data - 3) << sdp->sd_sb.sb_bsize_shift;\n\tif (*len > max) {\n\t\t*len = max;\n\t\tgfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "max",
            "data_blocks",
            "ind_blocks"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "tmp",
            "sdp->sd_inptrs"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,\n\t\t\t    unsigned int *data_blocks, unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int max_blocks = ip->i_rgd->rd_free_clone;\n\tunsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = max_data; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\tmax_data -= tmp;\n\t}\n\t/* This calculation isn't the exact reverse of gfs2_write_calc_reserve,\n\t   so it might end up with fewer data blocks */\n\tif (max_data <= *data_blocks)\n\t\treturn;\n\t*data_blocks = max_data;\n\t*ind_blocks = max_blocks - max_data;\n\t*len = ((loff_t)max_data - 3) << sdp->sd_sb.sb_bsize_shift;\n\tif (*len > max) {\n\t\t*len = max;\n\t\tgfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);\n\t}\n}"
  },
  {
    "function_name": "fallocate_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "725-767",
    "snippet": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_zeronew(&bh_map)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_zeronew",
          "args": [
            "&bh_map"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&bh_map"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "lblock",
            "&bh_map",
            "1"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_zeronew",
          "args": [
            "&bh_map"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "NULL"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrelse(dibh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "701-723",
    "snippet": "static ssize_t gfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tint ret;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tgfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));\n\n\tif (file->f_flags & O_APPEND) {\n\t\tstruct gfs2_holder gh;\n\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgfs2_glock_dq_uninit(&gh);\n\t}\n\n\treturn generic_file_write_iter(iocb, from);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&gh"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_size_hint",
          "args": [
            "file",
            "iocb->ki_pos",
            "iov_iter_count(from)"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_size_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "332-342",
          "snippet": "static void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic ssize_t gfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tint ret;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tgfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));\n\n\tif (file->f_flags & O_APPEND) {\n\t\tstruct gfs2_holder gh;\n\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgfs2_glock_dq_uninit(&gh);\n\t}\n\n\treturn generic_file_write_iter(iocb, from);\n}"
  },
  {
    "function_name": "gfs2_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "652-685",
    "snippet": "static int gfs2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint sync_state = inode->i_state & I_DIRTY_ALL;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret = 0, ret1 = 0;\n\n\tif (mapping->nrpages) {\n\t\tret1 = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (ret1 == -EIO)\n\t\t\treturn ret1;\n\t}\n\n\tif (!gfs2_is_jdata(ip))\n\t\tsync_state &= ~I_DIRTY_PAGES;\n\tif (datasync)\n\t\tsync_state &= ~(I_DIRTY_SYNC | I_DIRTY_TIME);\n\n\tif (sync_state) {\n\t\tret = sync_inode_metadata(inode, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tfilemap_write_and_wait(mapping);\n\t\tgfs2_ail_flush(ip->i_gl, 1);\n\t}\n\n\tif (mapping->nrpages)\n\t\tret = filemap_fdatawait_range(mapping, start, end);\n\n\treturn ret ? ret : ret1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ail_flush",
          "args": [
            "ip->i_gl",
            "1"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ail_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "110-129",
          "snippet": "void gfs2_ail_flush(struct gfs2_glock *gl, bool fsync)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tunsigned int revokes = atomic_read(&gl->gl_ail_count);\n\tunsigned int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);\n\tint ret;\n\n\tif (!revokes)\n\t\treturn;\n\n\twhile (revokes > max_revokes)\n\t\tmax_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\n\tret = gfs2_trans_begin(sdp, 0, max_revokes);\n\tif (ret)\n\t\treturn;\n\t__gfs2_ail_flush(gl, fsync, max_revokes);\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_ail_flush(struct gfs2_glock *gl, bool fsync)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tunsigned int revokes = atomic_read(&gl->gl_ail_count);\n\tunsigned int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);\n\tint ret;\n\n\tif (!revokes)\n\t\treturn;\n\n\twhile (revokes > max_revokes)\n\t\tmax_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\n\tret = gfs2_trans_begin(sdp, 0, max_revokes);\n\tif (ret)\n\t\treturn;\n\t__gfs2_ail_flush(gl, fsync, max_revokes);\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "mapping"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint sync_state = inode->i_state & I_DIRTY_ALL;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret = 0, ret1 = 0;\n\n\tif (mapping->nrpages) {\n\t\tret1 = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (ret1 == -EIO)\n\t\t\treturn ret1;\n\t}\n\n\tif (!gfs2_is_jdata(ip))\n\t\tsync_state &= ~I_DIRTY_PAGES;\n\tif (datasync)\n\t\tsync_state &= ~(I_DIRTY_SYNC | I_DIRTY_TIME);\n\n\tif (sync_state) {\n\t\tret = sync_inode_metadata(inode, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tfilemap_write_and_wait(mapping);\n\t\tgfs2_ail_flush(ip->i_gl, 1);\n\t}\n\n\tif (mapping->nrpages)\n\t\tret = filemap_fdatawait_range(mapping, start, end);\n\n\treturn ret ? ret : ret1;\n}"
  },
  {
    "function_name": "gfs2_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "617-629",
    "snippet": "static int gfs2_release(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn 0;\n\n\tgfs2_rs_delete(ip, &inode->i_writecount);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rs_delete",
          "args": [
            "ip",
            "&inode->i_writecount"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "686-696",
          "snippet": "void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_release(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn 0;\n\n\tgfs2_rs_delete(ip, &inode->i_writecount);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "586-607",
    "snippet": "static int gfs2_open(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tbool need_unlock = false;\n\n\tif (S_ISREG(ip->i_inode.i_mode)) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tneed_unlock = true;\n\t}\n\n\terror = gfs2_open_common(inode, file);\n\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_open_common",
          "args": [
            "inode",
            "file"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "550-570",
          "snippet": "int gfs2_open_common(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_file *fp;\n\tint ret;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tret = generic_file_open(inode, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfp = kzalloc(sizeof(struct gfs2_file), GFP_NOFS);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fp->f_fl_mutex);\n\n\tgfs2_assert_warn(GFS2_SB(inode), !file->private_data);\n\tfile->private_data = fp;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_open_common(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_file *fp;\n\tint ret;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tret = generic_file_open(inode, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfp = kzalloc(sizeof(struct gfs2_file), GFP_NOFS);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fp->f_fl_mutex);\n\n\tgfs2_assert_warn(GFS2_SB(inode), !file->private_data);\n\tfile->private_data = fp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_open(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tbool need_unlock = false;\n\n\tif (S_ISREG(ip->i_inode.i_mode)) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tneed_unlock = true;\n\t}\n\n\terror = gfs2_open_common(inode, file);\n\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_open_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "550-570",
    "snippet": "int gfs2_open_common(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_file *fp;\n\tint ret;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tret = generic_file_open(inode, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfp = kzalloc(sizeof(struct gfs2_file), GFP_NOFS);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fp->f_fl_mutex);\n\n\tgfs2_assert_warn(GFS2_SB(inode), !file->private_data);\n\tfile->private_data = fp;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "GFS2_SB(inode)",
            "!file->private_data"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fp->f_fl_mutex"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gfs2_file)",
            "GFP_NOFS"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1121-1126",
          "snippet": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_open_common(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_file *fp;\n\tint ret;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tret = generic_file_open(inode, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfp = kzalloc(sizeof(struct gfs2_file), GFP_NOFS);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fp->f_fl_mutex);\n\n\tgfs2_assert_warn(GFS2_SB(inode), !file->private_data);\n\tfile->private_data = fp;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "515-535",
    "snippet": "static int gfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\n\tif (!(file->f_flags & O_NOATIME) &&\n\t    !IS_NOATIME(&ip->i_inode)) {\n\t\tstruct gfs2_holder i_gh;\n\t\tint error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* grab lock to update inode */\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tfile_accessed(file);\n\t}\n\tvma->vm_ops = &gfs2_vm_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct gfs2_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = gfs2_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOATIME",
          "args": [
            "&ip->i_inode"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const struct vm_operations_struct gfs2_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = gfs2_page_mkwrite,\n};\n\nstatic int gfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\n\tif (!(file->f_flags & O_NOATIME) &&\n\t    !IS_NOATIME(&ip->i_inode)) {\n\t\tstruct gfs2_holder i_gh;\n\t\tint error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* grab lock to update inode */\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tfile_accessed(file);\n\t}\n\tvma->vm_ops = &gfs2_vm_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "382-495",
    "snippet": "static int gfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned long last_index;\n\tu64 pos = page->index << PAGE_CACHE_SHIFT;\n\tunsigned int data_blocks, ind_blocks, rblocks;\n\tstruct gfs2_holder gh;\n\tloff_t size;\n\tint ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\n\t/* Update file times before taking page lock */\n\tfile_update_time(vma->vm_file);\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out_write_access;\n\n\tgfs2_size_hint(vma->vm_file, pos, PAGE_CACHE_SIZE);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tset_bit(GLF_DIRTY, &ip->i_gl->gl_flags);\n\tset_bit(GIF_SW_PAGED, &ip->i_flags);\n\n\tif (!gfs2_write_alloc_required(ip, pos, PAGE_CACHE_SIZE)) {\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page) || page->mapping != inode->i_mapping) {\n\t\t\tret = -EAGAIN;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = gfs2_quota_lock_check(ip);\n\tif (ret)\n\t\tgoto out_unlock;\n\tgfs2_write_calc_reserv(ip, PAGE_CACHE_SIZE, &data_blocks, &ind_blocks);\n\tap.target = data_blocks + ind_blocks;\n\tret = gfs2_inplace_reserve(ip, &ap);\n\tif (ret)\n\t\tgoto out_quota_unlock;\n\n\trblocks = RES_DINODE + ind_blocks;\n\tif (gfs2_is_jdata(ip))\n\t\trblocks += data_blocks ? data_blocks : 1;\n\tif (ind_blocks || data_blocks) {\n\t\trblocks += RES_STATFS + RES_QUOTA;\n\t\trblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t}\n\tret = gfs2_trans_begin(sdp, rblocks, 0);\n\tif (ret)\n\t\tgoto out_trans_fail;\n\n\tlock_page(page);\n\tret = -EINVAL;\n\tsize = i_size_read(inode);\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\t/* Check page index against inode size */\n\tif (size == 0 || (page->index > last_index))\n\t\tgoto out_trans_end;\n\n\tret = -EAGAIN;\n\t/* If truncated, we must retry the operation, we may have raced\n\t * with the glock demotion code.\n\t */\n\tif (!PageUptodate(page) || page->mapping != inode->i_mapping)\n\t\tgoto out_trans_end;\n\n\t/* Unstuff, if required, and allocate backing blocks for page */\n\tret = 0;\n\tif (gfs2_is_stuffed(ip))\n\t\tret = gfs2_unstuff_dinode(ip, page);\n\tif (ret == 0)\n\t\tret = gfs2_allocate_page_backing(page);\n\nout_trans_end:\n\tif (ret)\n\t\tunlock_page(page);\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_quota_unlock:\n\tgfs2_quota_unlock(ip);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tif (ret == 0) {\n\t\tset_page_dirty(page);\n\t\twait_for_stable_page(page);\n\t}\nout_write_access:\n\tput_write_access(inode);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(ret);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "ret"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "931-935",
          "snippet": "static int gfs2_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_buffers(page);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_allocate_page_backing",
          "args": [
            "page"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_allocate_page_backing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "354-371",
          "snippet": "static int gfs2_allocate_page_backing(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head bh;\n\tunsigned long size = PAGE_CACHE_SIZE;\n\tu64 lblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(inode, lblock, &bh, 1);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn -EIO;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> inode->i_blkbits);\n\t} while(size > 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_allocate_page_backing(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head bh;\n\tunsigned long size = PAGE_CACHE_SIZE;\n\tu64 lblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(inode, lblock, &bh, 1);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn -EIO;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> inode->i_blkbits);\n\t} while(size > 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "page"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rblocks",
            "0"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "data_blocks + ind_blocks"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "PAGE_CACHE_SIZE",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_write_alloc_required",
          "args": [
            "ip",
            "pos",
            "PAGE_CACHE_SIZE"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1455-1494",
          "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GIF_SW_PAGED",
            "&ip->i_flags"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_size_hint",
          "args": [
            "vma->vm_file",
            "pos",
            "PAGE_CACHE_SIZE"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_size_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "332-342",
          "snippet": "static void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned long last_index;\n\tu64 pos = page->index << PAGE_CACHE_SHIFT;\n\tunsigned int data_blocks, ind_blocks, rblocks;\n\tstruct gfs2_holder gh;\n\tloff_t size;\n\tint ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\n\t/* Update file times before taking page lock */\n\tfile_update_time(vma->vm_file);\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = gfs2_rs_alloc(ip);\n\tif (ret)\n\t\tgoto out_write_access;\n\n\tgfs2_size_hint(vma->vm_file, pos, PAGE_CACHE_SIZE);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tset_bit(GLF_DIRTY, &ip->i_gl->gl_flags);\n\tset_bit(GIF_SW_PAGED, &ip->i_flags);\n\n\tif (!gfs2_write_alloc_required(ip, pos, PAGE_CACHE_SIZE)) {\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page) || page->mapping != inode->i_mapping) {\n\t\t\tret = -EAGAIN;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = gfs2_quota_lock_check(ip);\n\tif (ret)\n\t\tgoto out_unlock;\n\tgfs2_write_calc_reserv(ip, PAGE_CACHE_SIZE, &data_blocks, &ind_blocks);\n\tap.target = data_blocks + ind_blocks;\n\tret = gfs2_inplace_reserve(ip, &ap);\n\tif (ret)\n\t\tgoto out_quota_unlock;\n\n\trblocks = RES_DINODE + ind_blocks;\n\tif (gfs2_is_jdata(ip))\n\t\trblocks += data_blocks ? data_blocks : 1;\n\tif (ind_blocks || data_blocks) {\n\t\trblocks += RES_STATFS + RES_QUOTA;\n\t\trblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t}\n\tret = gfs2_trans_begin(sdp, rblocks, 0);\n\tif (ret)\n\t\tgoto out_trans_fail;\n\n\tlock_page(page);\n\tret = -EINVAL;\n\tsize = i_size_read(inode);\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\t/* Check page index against inode size */\n\tif (size == 0 || (page->index > last_index))\n\t\tgoto out_trans_end;\n\n\tret = -EAGAIN;\n\t/* If truncated, we must retry the operation, we may have raced\n\t * with the glock demotion code.\n\t */\n\tif (!PageUptodate(page) || page->mapping != inode->i_mapping)\n\t\tgoto out_trans_end;\n\n\t/* Unstuff, if required, and allocate backing blocks for page */\n\tret = 0;\n\tif (gfs2_is_stuffed(ip))\n\t\tret = gfs2_unstuff_dinode(ip, page);\n\tif (ret == 0)\n\t\tret = gfs2_allocate_page_backing(page);\n\nout_trans_end:\n\tif (ret)\n\t\tunlock_page(page);\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_quota_unlock:\n\tgfs2_quota_unlock(ip);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tif (ret == 0) {\n\t\tset_page_dirty(page);\n\t\twait_for_stable_page(page);\n\t}\nout_write_access:\n\tput_write_access(inode);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(ret);\n}"
  },
  {
    "function_name": "gfs2_allocate_page_backing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "354-371",
    "snippet": "static int gfs2_allocate_page_backing(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head bh;\n\tunsigned long size = PAGE_CACHE_SIZE;\n\tu64 lblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(inode, lblock, &bh, 1);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn -EIO;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> inode->i_blkbits);\n\t} while(size > 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&bh"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "lblock",
            "&bh",
            "1"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_allocate_page_backing(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head bh;\n\tunsigned long size = PAGE_CACHE_SIZE;\n\tu64 lblock = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(inode, lblock, &bh, 1);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn -EIO;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> inode->i_blkbits);\n\t} while(size > 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_size_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "332-342",
    "snippet": "static void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ip->i_res->rs_sizehint",
            "hint"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ip->i_res->rs_sizehint"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "INT_MAX",
            "blks"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_res->rs_sizehint))\n\t\tatomic_set(&ip->i_res->rs_sizehint, hint);\n}"
  },
  {
    "function_name": "gfs2_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "307-318",
    "snippet": "static long gfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch(cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn gfs2_get_flags(filp, (u32 __user *)arg);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn gfs2_set_flags(filp, (u32 __user *)arg);\n\tcase FITRIM:\n\t\treturn gfs2_fitrim(filp, (void __user *)arg);\n\t}\n\treturn -ENOTTY;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_fitrim",
          "args": [
            "filp",
            "(void __user *)arg"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_fitrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1342-1432",
          "snippet": "int gfs2_fitrim(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct request_queue *q = bdev_get_queue(sdp->sd_vfs->s_bdev);\n\tstruct buffer_head *bh;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd *rgd_end;\n\tstruct gfs2_holder gh;\n\tstruct fstrim_range r;\n\tint ret = 0;\n\tu64 amt;\n\tu64 trimmed = 0;\n\tu64 start, end, minlen;\n\tunsigned int x;\n\tunsigned bs_shift = sdp->sd_sb.sb_bsize_shift;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\treturn -EFAULT;\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\treturn ret;\n\n\tstart = r.start >> bs_shift;\n\tend = start + (r.len >> bs_shift);\n\tminlen = max_t(u64, r.minlen,\n\t\t       q->limits.discard_granularity) >> bs_shift;\n\n\tif (end <= start || minlen > sdp->sd_max_rg_data)\n\t\treturn -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, start, 0);\n\trgd_end = gfs2_blk2rgrpd(sdp, end, 0);\n\n\tif ((gfs2_rgrpd_get_first(sdp) == gfs2_rgrpd_get_next(rgd_end))\n\t    && (start > rgd_end->rd_data0 + rgd_end->rd_data))\n\t\treturn -EINVAL; /* start is beyond the end of the fs */\n\n\twhile (1) {\n\n\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(rgd->rd_flags & GFS2_RGF_TRIMMED)) {\n\t\t\t/* Trim each bitmap in the rgrp */\n\t\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\t\t\tret = gfs2_rgrp_send_discards(sdp,\n\t\t\t\t\t\trgd->rd_data0, NULL, bi, minlen,\n\t\t\t\t\t\t&amt);\n\t\t\t\tif (ret) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&gh);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttrimmed += amt;\n\t\t\t}\n\n\t\t\t/* Mark rgrp as having been trimmed */\n\t\t\tret = gfs2_trans_begin(sdp, RES_RG_HDR, 0);\n\t\t\tif (ret == 0) {\n\t\t\t\tbh = rgd->rd_bits[0].bi_bh;\n\t\t\t\trgd->rd_flags |= GFS2_RGF_TRIMMED;\n\t\t\t\tgfs2_trans_add_meta(rgd->rd_gl, bh);\n\t\t\t\tgfs2_rgrp_out(rgd, bh->b_data);\n\t\t\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, bh->b_data);\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t}\n\t\t}\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\t\tif (rgd == rgd_end)\n\t\t\tbreak;\n\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t}\n\nout:\n\tr.len = trimmed << bs_shift;\n\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_fitrim(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct request_queue *q = bdev_get_queue(sdp->sd_vfs->s_bdev);\n\tstruct buffer_head *bh;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd *rgd_end;\n\tstruct gfs2_holder gh;\n\tstruct fstrim_range r;\n\tint ret = 0;\n\tu64 amt;\n\tu64 trimmed = 0;\n\tu64 start, end, minlen;\n\tunsigned int x;\n\tunsigned bs_shift = sdp->sd_sb.sb_bsize_shift;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\treturn -EFAULT;\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\treturn ret;\n\n\tstart = r.start >> bs_shift;\n\tend = start + (r.len >> bs_shift);\n\tminlen = max_t(u64, r.minlen,\n\t\t       q->limits.discard_granularity) >> bs_shift;\n\n\tif (end <= start || minlen > sdp->sd_max_rg_data)\n\t\treturn -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, start, 0);\n\trgd_end = gfs2_blk2rgrpd(sdp, end, 0);\n\n\tif ((gfs2_rgrpd_get_first(sdp) == gfs2_rgrpd_get_next(rgd_end))\n\t    && (start > rgd_end->rd_data0 + rgd_end->rd_data))\n\t\treturn -EINVAL; /* start is beyond the end of the fs */\n\n\twhile (1) {\n\n\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(rgd->rd_flags & GFS2_RGF_TRIMMED)) {\n\t\t\t/* Trim each bitmap in the rgrp */\n\t\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\t\t\tret = gfs2_rgrp_send_discards(sdp,\n\t\t\t\t\t\trgd->rd_data0, NULL, bi, minlen,\n\t\t\t\t\t\t&amt);\n\t\t\t\tif (ret) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&gh);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttrimmed += amt;\n\t\t\t}\n\n\t\t\t/* Mark rgrp as having been trimmed */\n\t\t\tret = gfs2_trans_begin(sdp, RES_RG_HDR, 0);\n\t\t\tif (ret == 0) {\n\t\t\t\tbh = rgd->rd_bits[0].bi_bh;\n\t\t\t\trgd->rd_flags |= GFS2_RGF_TRIMMED;\n\t\t\t\tgfs2_trans_add_meta(rgd->rd_gl, bh);\n\t\t\t\tgfs2_rgrp_out(rgd, bh->b_data);\n\t\t\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, bh->b_data);\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t}\n\t\t}\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\t\tif (rgd == rgd_end)\n\t\t\tbreak;\n\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t}\n\nout:\n\tr.len = trimmed << bs_shift;\n\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_flags",
          "args": [
            "filp",
            "(u32 __user *)arg"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "289-305",
          "snippet": "static int gfs2_set_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 fsflags, gfsflags;\n\n\tif (get_user(fsflags, ptr))\n\t\treturn -EFAULT;\n\n\tgfsflags = fsflags_cvt(fsflags_to_gfs2, fsflags);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tgfsflags &= ~GFS2_DIF_TOPDIR;\n\t\tif (gfsflags & GFS2_DIF_INHERIT_JDATA)\n\t\t\tgfsflags ^= (GFS2_DIF_JDATA | GFS2_DIF_INHERIT_JDATA);\n\t\treturn do_gfs2_set_flags(filp, gfsflags, ~0);\n\t}\n\treturn do_gfs2_set_flags(filp, gfsflags, ~GFS2_DIF_JDATA);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u32 fsflags_to_gfs2[32] = {\n\t[3] = GFS2_DIF_SYNC,\n\t[4] = GFS2_DIF_IMMUTABLE,\n\t[5] = GFS2_DIF_APPENDONLY,\n\t[7] = GFS2_DIF_NOATIME,\n\t[12] = GFS2_DIF_EXHASH,\n\t[14] = GFS2_DIF_INHERIT_JDATA,\n\t[17] = GFS2_DIF_TOPDIR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const u32 fsflags_to_gfs2[32] = {\n\t[3] = GFS2_DIF_SYNC,\n\t[4] = GFS2_DIF_IMMUTABLE,\n\t[5] = GFS2_DIF_APPENDONLY,\n\t[7] = GFS2_DIF_NOATIME,\n\t[12] = GFS2_DIF_EXHASH,\n\t[14] = GFS2_DIF_INHERIT_JDATA,\n\t[17] = GFS2_DIF_TOPDIR,\n};\n\nstatic int gfs2_set_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 fsflags, gfsflags;\n\n\tif (get_user(fsflags, ptr))\n\t\treturn -EFAULT;\n\n\tgfsflags = fsflags_cvt(fsflags_to_gfs2, fsflags);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tgfsflags &= ~GFS2_DIF_TOPDIR;\n\t\tif (gfsflags & GFS2_DIF_INHERIT_JDATA)\n\t\t\tgfsflags ^= (GFS2_DIF_JDATA | GFS2_DIF_INHERIT_JDATA);\n\t\treturn do_gfs2_set_flags(filp, gfsflags, ~0);\n\t}\n\treturn do_gfs2_set_flags(filp, gfsflags, ~GFS2_DIF_JDATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_get_flags",
          "args": [
            "filp",
            "(u32 __user *)arg"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "153-175",
          "snippet": "static int gfs2_get_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\treturn error;\n\n\tfsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);\n\tif (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)\n\t\tfsflags |= FS_JOURNAL_DATA_FL;\n\tif (put_user(fsflags, ptr))\n\t\terror = -EFAULT;\n\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u32 gfs2_to_fsflags[32] = {\n\t[gfs2fl_Sync] = FS_SYNC_FL,\n\t[gfs2fl_Immutable] = FS_IMMUTABLE_FL,\n\t[gfs2fl_AppendOnly] = FS_APPEND_FL,\n\t[gfs2fl_NoAtime] = FS_NOATIME_FL,\n\t[gfs2fl_ExHash] = FS_INDEX_FL,\n\t[gfs2fl_TopLevel] = FS_TOPDIR_FL,\n\t[gfs2fl_InheritJdata] = FS_JOURNAL_DATA_FL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const u32 gfs2_to_fsflags[32] = {\n\t[gfs2fl_Sync] = FS_SYNC_FL,\n\t[gfs2fl_Immutable] = FS_IMMUTABLE_FL,\n\t[gfs2fl_AppendOnly] = FS_APPEND_FL,\n\t[gfs2fl_NoAtime] = FS_NOATIME_FL,\n\t[gfs2fl_ExHash] = FS_INDEX_FL,\n\t[gfs2fl_TopLevel] = FS_TOPDIR_FL,\n\t[gfs2fl_InheritJdata] = FS_JOURNAL_DATA_FL,\n};\n\nstatic int gfs2_get_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\treturn error;\n\n\tfsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);\n\tif (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)\n\t\tfsflags |= FS_JOURNAL_DATA_FL;\n\tif (put_user(fsflags, ptr))\n\t\terror = -EFAULT;\n\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic long gfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch(cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn gfs2_get_flags(filp, (u32 __user *)arg);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn gfs2_set_flags(filp, (u32 __user *)arg);\n\tcase FITRIM:\n\t\treturn gfs2_fitrim(filp, (void __user *)arg);\n\t}\n\treturn -ENOTTY;\n}"
  },
  {
    "function_name": "gfs2_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "289-305",
    "snippet": "static int gfs2_set_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 fsflags, gfsflags;\n\n\tif (get_user(fsflags, ptr))\n\t\treturn -EFAULT;\n\n\tgfsflags = fsflags_cvt(fsflags_to_gfs2, fsflags);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tgfsflags &= ~GFS2_DIF_TOPDIR;\n\t\tif (gfsflags & GFS2_DIF_INHERIT_JDATA)\n\t\t\tgfsflags ^= (GFS2_DIF_JDATA | GFS2_DIF_INHERIT_JDATA);\n\t\treturn do_gfs2_set_flags(filp, gfsflags, ~0);\n\t}\n\treturn do_gfs2_set_flags(filp, gfsflags, ~GFS2_DIF_JDATA);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const u32 fsflags_to_gfs2[32] = {\n\t[3] = GFS2_DIF_SYNC,\n\t[4] = GFS2_DIF_IMMUTABLE,\n\t[5] = GFS2_DIF_APPENDONLY,\n\t[7] = GFS2_DIF_NOATIME,\n\t[12] = GFS2_DIF_EXHASH,\n\t[14] = GFS2_DIF_INHERIT_JDATA,\n\t[17] = GFS2_DIF_TOPDIR,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_gfs2_set_flags",
          "args": [
            "filp",
            "gfsflags",
            "~GFS2_DIF_JDATA"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "do_gfs2_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "213-287",
          "snippet": "static int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\terror = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto out;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif ((new_flags ^ flags) & ~GFS2_FLAGS_USER_SET)\n\t\tgoto out;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) && (new_flags & GFS2_DIF_IMMUTABLE))\n\t\tgoto out;\n\tif (IS_APPEND(inode) && (new_flags & GFS2_DIF_APPENDONLY))\n\t\tgoto out;\n\tif (((new_flags ^ flags) & GFS2_DIF_IMMUTABLE) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\tgfs2_set_inode_flags(inode);\n\tgfs2_set_aops(inode);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout:\n\tgfs2_glock_dq_uninit(&gh);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define GFS2_FLAGS_USER_SET (GFS2_DIF_JDATA|\t\t\t\\\n\t\t\t     GFS2_DIF_IMMUTABLE|\t\t\\\n\t\t\t     GFS2_DIF_APPENDONLY|\t\t\\\n\t\t\t     GFS2_DIF_NOATIME|\t\t\t\\\n\t\t\t     GFS2_DIF_SYNC|\t\t\t\\\n\t\t\t     GFS2_DIF_SYSTEM|\t\t\t\\\n\t\t\t     GFS2_DIF_TOPDIR|\t\t\t\\\n\t\t\t     GFS2_DIF_INHERIT_JDATA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define GFS2_FLAGS_USER_SET (GFS2_DIF_JDATA|\t\t\t\\\n\t\t\t     GFS2_DIF_IMMUTABLE|\t\t\\\n\t\t\t     GFS2_DIF_APPENDONLY|\t\t\\\n\t\t\t     GFS2_DIF_NOATIME|\t\t\t\\\n\t\t\t     GFS2_DIF_SYNC|\t\t\t\\\n\t\t\t     GFS2_DIF_SYSTEM|\t\t\t\\\n\t\t\t     GFS2_DIF_TOPDIR|\t\t\t\\\n\t\t\t     GFS2_DIF_INHERIT_JDATA)\n\nstatic int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\terror = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto out;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif ((new_flags ^ flags) & ~GFS2_FLAGS_USER_SET)\n\t\tgoto out;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) && (new_flags & GFS2_DIF_IMMUTABLE))\n\t\tgoto out;\n\tif (IS_APPEND(inode) && (new_flags & GFS2_DIF_APPENDONLY))\n\t\tgoto out;\n\tif (((new_flags ^ flags) & GFS2_DIF_IMMUTABLE) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\tgfs2_set_inode_flags(inode);\n\tgfs2_set_aops(inode);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout:\n\tgfs2_glock_dq_uninit(&gh);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsflags_cvt",
          "args": [
            "fsflags_to_gfs2",
            "fsflags"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "fsflags_cvt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "121-131",
          "snippet": "static u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "fsflags",
            "ptr"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const u32 fsflags_to_gfs2[32] = {\n\t[3] = GFS2_DIF_SYNC,\n\t[4] = GFS2_DIF_IMMUTABLE,\n\t[5] = GFS2_DIF_APPENDONLY,\n\t[7] = GFS2_DIF_NOATIME,\n\t[12] = GFS2_DIF_EXHASH,\n\t[14] = GFS2_DIF_INHERIT_JDATA,\n\t[17] = GFS2_DIF_TOPDIR,\n};\n\nstatic int gfs2_set_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 fsflags, gfsflags;\n\n\tif (get_user(fsflags, ptr))\n\t\treturn -EFAULT;\n\n\tgfsflags = fsflags_cvt(fsflags_to_gfs2, fsflags);\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tgfsflags &= ~GFS2_DIF_TOPDIR;\n\t\tif (gfsflags & GFS2_DIF_INHERIT_JDATA)\n\t\t\tgfsflags ^= (GFS2_DIF_JDATA | GFS2_DIF_INHERIT_JDATA);\n\t\treturn do_gfs2_set_flags(filp, gfsflags, ~0);\n\t}\n\treturn do_gfs2_set_flags(filp, gfsflags, ~GFS2_DIF_JDATA);\n}"
  },
  {
    "function_name": "do_gfs2_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "213-287",
    "snippet": "static int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\terror = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto out;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif ((new_flags ^ flags) & ~GFS2_FLAGS_USER_SET)\n\t\tgoto out;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) && (new_flags & GFS2_DIF_IMMUTABLE))\n\t\tgoto out;\n\tif (IS_APPEND(inode) && (new_flags & GFS2_DIF_APPENDONLY))\n\t\tgoto out;\n\tif (((new_flags ^ flags) & GFS2_DIF_IMMUTABLE) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\tgfs2_set_inode_flags(inode);\n\tgfs2_set_aops(inode);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout:\n\tgfs2_glock_dq_uninit(&gh);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define GFS2_FLAGS_USER_SET (GFS2_DIF_JDATA|\t\t\t\\\n\t\t\t     GFS2_DIF_IMMUTABLE|\t\t\\\n\t\t\t     GFS2_DIF_APPENDONLY|\t\t\\\n\t\t\t     GFS2_DIF_NOATIME|\t\t\t\\\n\t\t\t     GFS2_DIF_SYNC|\t\t\t\\\n\t\t\t     GFS2_DIF_SYSTEM|\t\t\t\\\n\t\t\t     GFS2_DIF_TOPDIR|\t\t\t\\\n\t\t\t     GFS2_DIF_INHERIT_JDATA)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_aops",
          "args": [
            "inode"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "1218-1230",
          "snippet": "void gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\nvoid gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "177-194",
          "snippet": "void gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "bh->b_data"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&bh"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE",
            "0"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "ip->i_gl",
            "NORMAL_FLUSH"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1606-1632",
          "snippet": "int gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_permission(struct inode *inode, int mask)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tint unlock = 0;\n\n\n\tip = GFS2_I(inode);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\tif (mask & MAY_NOT_BLOCK)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tunlock = 1;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EACCES;\n\telse\n\t\terror = generic_permission(inode, mask);\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define GFS2_FLAGS_USER_SET (GFS2_DIF_JDATA|\t\t\t\\\n\t\t\t     GFS2_DIF_IMMUTABLE|\t\t\\\n\t\t\t     GFS2_DIF_APPENDONLY|\t\t\\\n\t\t\t     GFS2_DIF_NOATIME|\t\t\t\\\n\t\t\t     GFS2_DIF_SYNC|\t\t\t\\\n\t\t\t     GFS2_DIF_SYSTEM|\t\t\t\\\n\t\t\t     GFS2_DIF_TOPDIR|\t\t\t\\\n\t\t\t     GFS2_DIF_INHERIT_JDATA)\n\nstatic int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\terror = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto out;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif ((new_flags ^ flags) & ~GFS2_FLAGS_USER_SET)\n\t\tgoto out;\n\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) && (new_flags & GFS2_DIF_IMMUTABLE))\n\t\tgoto out;\n\tif (IS_APPEND(inode) && (new_flags & GFS2_DIF_APPENDONLY))\n\t\tgoto out;\n\tif (((new_flags ^ flags) & GFS2_DIF_IMMUTABLE) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\tgfs2_set_inode_flags(inode);\n\tgfs2_set_aops(inode);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout:\n\tgfs2_glock_dq_uninit(&gh);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "177-194",
    "snippet": "void gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_sxid",
          "args": [
            "inode->i_mode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}"
  },
  {
    "function_name": "gfs2_get_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "153-175",
    "snippet": "static int gfs2_get_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\treturn error;\n\n\tfsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);\n\tif (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)\n\t\tfsflags |= FS_JOURNAL_DATA_FL;\n\tif (put_user(fsflags, ptr))\n\t\terror = -EFAULT;\n\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const u32 gfs2_to_fsflags[32] = {\n\t[gfs2fl_Sync] = FS_SYNC_FL,\n\t[gfs2fl_Immutable] = FS_IMMUTABLE_FL,\n\t[gfs2fl_AppendOnly] = FS_APPEND_FL,\n\t[gfs2fl_NoAtime] = FS_NOATIME_FL,\n\t[gfs2fl_ExHash] = FS_INDEX_FL,\n\t[gfs2fl_TopLevel] = FS_TOPDIR_FL,\n\t[gfs2fl_InheritJdata] = FS_JOURNAL_DATA_FL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "fsflags",
            "ptr"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsflags_cvt",
          "args": [
            "gfs2_to_fsflags",
            "ip->i_diskflags"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "fsflags_cvt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "121-131",
          "snippet": "static u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&gh"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const u32 gfs2_to_fsflags[32] = {\n\t[gfs2fl_Sync] = FS_SYNC_FL,\n\t[gfs2fl_Immutable] = FS_IMMUTABLE_FL,\n\t[gfs2fl_AppendOnly] = FS_APPEND_FL,\n\t[gfs2fl_NoAtime] = FS_NOATIME_FL,\n\t[gfs2fl_ExHash] = FS_INDEX_FL,\n\t[gfs2fl_TopLevel] = FS_TOPDIR_FL,\n\t[gfs2fl_InheritJdata] = FS_JOURNAL_DATA_FL,\n};\n\nstatic int gfs2_get_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\treturn error;\n\n\tfsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);\n\tif (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)\n\t\tfsflags |= FS_JOURNAL_DATA_FL;\n\tif (put_user(fsflags, ptr))\n\t\terror = -EFAULT;\n\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}"
  },
  {
    "function_name": "fsflags_cvt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "121-131",
    "snippet": "static u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "gfs2_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "93-109",
    "snippet": "static int gfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file->f_mapping->host;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dir_read(dir, ctx, &file->f_ra);\n\n\tgfs2_glock_dq_uninit(&d_gh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&d_gh"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_read",
          "args": [
            "dir",
            "ctx",
            "&file->f_ra"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1475-1534",
          "snippet": "int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,\n\t\t  struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t/* 96 is max number of dirents which can be stuffed into an inode */\n\tdarr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\tif (IS_ERR(dent)) {\n\t\t\terror = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dip->i_entries != g.offset) {\n\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\",\n\t\t\t\t(unsigned long long)dip->i_no_addr,\n\t\t\t\tdip->i_entries,\n\t\t\t\tg.offset);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\terror = do_filldir_main(dip, ctx, darr,\n\t\t\t\t\tdip->i_entries, &copied);\nout:\n\t\tkfree(darr);\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\tbrelse(dibh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_read(struct inode *inode, struct dir_context *ctx,\n\t\t  struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tconst struct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t/* 96 is max number of dirents which can be stuffed into an inode */\n\tdarr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\tif (IS_ERR(dent)) {\n\t\t\terror = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dip->i_entries != g.offset) {\n\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\",\n\t\t\t\t(unsigned long long)dip->i_no_addr,\n\t\t\t\tdip->i_entries,\n\t\t\t\tg.offset);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\terror = do_filldir_main(dip, ctx, darr,\n\t\t\t\t\tdip->i_entries, &copied);\nout:\n\t\tkfree(darr);\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\tbrelse(dibh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "dip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&d_gh"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dir"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file->f_mapping->host;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dir_read(dir, ctx, &file->f_ra);\n\n\tgfs2_glock_dq_uninit(&d_gh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
    "lines": "57-83",
    "snippet": "static loff_t gfs2_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_holder i_gh;\n\tloff_t error;\n\n\tswitch (whence) {\n\tcase SEEK_END: /* These reference inode->i_size */\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (!error) {\n\t\t\terror = generic_file_llseek(file, offset, whence);\n\t\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\t}\n\t\tbreak;\n\tcase SEEK_CUR:\n\tcase SEEK_SET:\n\t\terror = generic_file_llseek(file, offset, whence);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"dir.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/delay.h>",
      "#include <linux/aio.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/crc32.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic loff_t gfs2_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_holder i_gh;\n\tloff_t error;\n\n\tswitch (whence) {\n\tcase SEEK_END: /* These reference inode->i_size */\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (!error) {\n\t\t\terror = generic_file_llseek(file, offset, whence);\n\t\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\t}\n\t\tbreak;\n\tcase SEEK_CUR:\n\tcase SEEK_SET:\n\t\terror = generic_file_llseek(file, offset, whence);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}"
  }
]