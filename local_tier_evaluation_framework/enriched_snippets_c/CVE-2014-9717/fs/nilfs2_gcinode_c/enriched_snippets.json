[
  {
    "function_name": "nilfs_remove_all_gcinodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
    "lines": "185-197",
    "snippet": "void nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\n{\n\tstruct list_head *head = &nilfs->ns_gc_inodes;\n\tstruct nilfs_inode_info *ii;\n\n\twhile (!list_empty(head)) {\n\t\tii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&ii->vfs_inode"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_btnode_cache_clear",
          "args": [
            "&ii->i_btnode_cache"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_cache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "37-41",
          "snippet": "void nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&ii->vfs_inode.i_data",
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structnilfs_inode_info",
            "i_dirty"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\n{\n\tstruct list_head *head = &nilfs->ns_gc_inodes;\n\tstruct nilfs_inode_info *ii;\n\n\twhile (!list_empty(head)) {\n\t\tii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}"
  },
  {
    "function_name": "nilfs_init_gcinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
    "lines": "168-180",
    "snippet": "int nilfs_init_gcinode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_mapping->a_ops = &empty_aops;\n\n\tii->i_flags = 0;\n\tnilfs_bmap_init_gc(ii->i_bmap);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_bmap_init_gc",
          "args": [
            "ii->i_bmap"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_init_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "539-549",
          "snippet": "void nilfs_bmap_init_gc(struct nilfs_bmap *bmap)\n{\n\tmemset(&bmap->b_u, 0, NILFS_BMAP_SIZE);\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tbmap->b_ptr_type = NILFS_BMAP_PTR_U;\n\tbmap->b_last_allocated_key = 0;\n\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\tbmap->b_state = 0;\n\tnilfs_btree_init_gc(bmap);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_init_gc(struct nilfs_bmap *bmap)\n{\n\tmemset(&bmap->b_u, 0, NILFS_BMAP_SIZE);\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tbmap->b_ptr_type = NILFS_BMAP_PTR_U;\n\tbmap->b_last_allocated_key = 0;\n\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\tbmap->b_state = 0;\n\tnilfs_btree_init_gc(bmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_NOFS"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_init_gcinode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_mapping->a_ops = &empty_aops;\n\n\tii->i_flags = 0;\n\tnilfs_bmap_init_gc(ii->i_bmap);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_gccache_wait_and_mark_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
    "lines": "152-166",
    "snippet": "int nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\n{\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh))\n\t\treturn -EIO;\n\tif (buffer_dirty(bh))\n\t\treturn -EEXIST;\n\n\tif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\treturn -EIO;\n\t}\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_btree_broken_node_block",
          "args": [
            "bh"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btree_broken_node_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btree.c",
          "lines": "401-413",
          "snippet": "int nilfs_btree_broken_node_block(struct buffer_head *bh)\n{\n\tint ret;\n\n\tif (buffer_nilfs_checked(bh))\n\t\treturn 0;\n\n\tret = nilfs_btree_node_broken((struct nilfs_btree_node *)bh->b_data,\n\t\t\t\t       bh->b_size, bh->b_blocknr);\n\tif (likely(!ret))\n\t\tset_buffer_nilfs_checked(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"btree.h\"",
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"btree.h\"\n#include \"btnode.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagevec.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nint nilfs_btree_broken_node_block(struct buffer_head *bh)\n{\n\tint ret;\n\n\tif (buffer_nilfs_checked(bh))\n\t\treturn 0;\n\n\tret = nilfs_btree_node_broken((struct nilfs_btree_node *)bh->b_data,\n\t\t\t\t       bh->b_size, bh->b_blocknr);\n\tif (likely(!ret))\n\t\tset_buffer_nilfs_checked(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_nilfs_node",
          "args": [
            "bh"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\n{\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh))\n\t\treturn -EIO;\n\tif (buffer_dirty(bh))\n\t\treturn -EEXIST;\n\n\tif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\treturn -EIO;\n\t}\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_gccache_submit_read_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
    "lines": "140-150",
    "snippet": "int nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\n\t\t\t\t   __u64 vbn, struct buffer_head **out_bh)\n{\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(&NILFS_I(inode)->i_btnode_cache,\n\t\t\t\t\tvbn ? : pbn, pbn, READ, out_bh, &pbn);\n\tif (ret == -EEXIST) /* internal code (cache hit) */\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_btnode_submit_block",
          "args": [
            "&NILFS_I(inode)->i_btnode_cache",
            "vbn ? : pbn",
            "pbn",
            "READ",
            "out_bh",
            "&pbn"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_submit_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "69-133",
          "snippet": "int nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\n\t\t\t      sector_t pblocknr, int mode,\n\t\t\t      struct buffer_head **pbh, sector_t *submit_ptr)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct page *page;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\terr = -EEXIST; /* internal code */\n\tpage = bh->b_page;\n\n\tif (buffer_uptodate(bh) || buffer_dirty(bh))\n\t\tgoto found;\n\n\tif (pblocknr == 0) {\n\t\tpblocknr = blocknr;\n\t\tif (inode->i_ino != NILFS_DAT_INO) {\n\t\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t\t/* blocknr is a virtual block number */\n\t\t\terr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\n\t\t\t\t\t\t  &pblocknr);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == READA) {\n\t\tif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\n\t\t\terr = -EBUSY; /* internal code */\n\t\t\tbrelse(bh);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else { /* mode == READ */\n\t\tlock_buffer(bh);\n\t}\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\terr = -EEXIST; /* internal code */\n\t\tgoto found;\n\t}\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = pblocknr; /* set block address for read */\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tbh->b_blocknr = blocknr; /* set back to the given block address */\n\t*submit_ptr = pblocknr;\n\terr = 0;\nfound:\n\t*pbh = bh;\n\nout_locked:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\n\t\t\t      sector_t pblocknr, int mode,\n\t\t\t      struct buffer_head **pbh, sector_t *submit_ptr)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct page *page;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\terr = -EEXIST; /* internal code */\n\tpage = bh->b_page;\n\n\tif (buffer_uptodate(bh) || buffer_dirty(bh))\n\t\tgoto found;\n\n\tif (pblocknr == 0) {\n\t\tpblocknr = blocknr;\n\t\tif (inode->i_ino != NILFS_DAT_INO) {\n\t\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t\t/* blocknr is a virtual block number */\n\t\t\terr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\n\t\t\t\t\t\t  &pblocknr);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == READA) {\n\t\tif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\n\t\t\terr = -EBUSY; /* internal code */\n\t\t\tbrelse(bh);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else { /* mode == READ */\n\t\tlock_buffer(bh);\n\t}\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\terr = -EEXIST; /* internal code */\n\t\tgoto found;\n\t}\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = pblocknr; /* set block address for read */\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tbh->b_blocknr = blocknr; /* set back to the given block address */\n\t*submit_ptr = pblocknr;\n\terr = 0;\nfound:\n\t*pbh = bh;\n\nout_locked:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\n\t\t\t\t   __u64 vbn, struct buffer_head **out_bh)\n{\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(&NILFS_I(inode)->i_btnode_cache,\n\t\t\t\t\tvbn ? : pbn, pbn, READ, out_bh, &pbn);\n\tif (ret == -EEXIST) /* internal code (cache hit) */\n\t\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_gccache_submit_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/gcinode.c",
    "lines": "72-120",
    "snippet": "int nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\n\t\t\t\t   sector_t pbn, __u64 vbn,\n\t\t\t\t   struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (pbn == 0) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\terr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\n\t\tif (unlikely(err)) { /* -EIO, -ENOMEM, -ENOENT */\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\tset_buffer_mapped(bh);\n\t}\n\tbh->b_blocknr = pbn;\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ, bh);\n\tif (vbn)\n\t\tbh->b_blocknr = vbn;\n out:\n\terr = 0;\n\t*out_bh = bh;\n\n failed:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bh->b_page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_dat_translate",
          "args": [
            "nilfs->ns_dat",
            "vbn",
            "&pbn"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dat_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/dat.c",
          "lines": "397-431",
          "snippet": "int nilfs_dat_translate(struct inode *dat, __u64 vblocknr, sector_t *blocknrp)\n{\n\tstruct buffer_head *entry_bh, *bh;\n\tstruct nilfs_dat_entry *entry;\n\tsector_t blocknr;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_get_entry_block(dat, vblocknr, 0, &entry_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!nilfs_doing_gc() && buffer_nilfs_redirected(entry_bh)) {\n\t\tbh = nilfs_mdt_get_frozen_buffer(dat, entry_bh);\n\t\tif (bh) {\n\t\t\tWARN_ON(!buffer_uptodate(bh));\n\t\t\tbrelse(entry_bh);\n\t\t\tentry_bh = bh;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(entry_bh->b_page);\n\tentry = nilfs_palloc_block_get_entry(dat, vblocknr, entry_bh, kaddr);\n\tblocknr = le64_to_cpu(entry->de_blocknr);\n\tif (blocknr == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*blocknrp = blocknr;\n\n out:\n\tkunmap_atomic(kaddr);\n\tbrelse(entry_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_dat_translate(struct inode *dat, __u64 vblocknr, sector_t *blocknrp)\n{\n\tstruct buffer_head *entry_bh, *bh;\n\tstruct nilfs_dat_entry *entry;\n\tsector_t blocknr;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_get_entry_block(dat, vblocknr, 0, &entry_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!nilfs_doing_gc() && buffer_nilfs_redirected(entry_bh)) {\n\t\tbh = nilfs_mdt_get_frozen_buffer(dat, entry_bh);\n\t\tif (bh) {\n\t\t\tWARN_ON(!buffer_uptodate(bh));\n\t\t\tbrelse(entry_bh);\n\t\t\tentry_bh = bh;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(entry_bh->b_page);\n\tentry = nilfs_palloc_block_get_entry(dat, vblocknr, entry_bh, kaddr);\n\tblocknr = le64_to_cpu(entry->de_blocknr);\n\tif (blocknr == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*blocknrp = blocknr;\n\n out:\n\tkunmap_atomic(kaddr);\n\tbrelse(entry_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_grab_buffer",
          "args": [
            "inode",
            "inode->i_mapping",
            "blkoff",
            "0"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_grab_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "61-82",
          "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"nilfs.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\n\t\t\t\t   sector_t pbn, __u64 vbn,\n\t\t\t\t   struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (pbn == 0) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\terr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\n\t\tif (unlikely(err)) { /* -EIO, -ENOMEM, -ENOENT */\n\t\t\tbrelse(bh);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\tset_buffer_mapped(bh);\n\t}\n\tbh->b_blocknr = pbn;\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ, bh);\n\tif (vbn)\n\t\tbh->b_blocknr = vbn;\n out:\n\terr = 0;\n\t*out_bh = bh;\n\n failed:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn err;\n}"
  }
]