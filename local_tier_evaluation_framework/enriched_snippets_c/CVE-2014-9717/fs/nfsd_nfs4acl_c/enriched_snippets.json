[
  {
    "function_name": "nfs4_acl_write_who",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "927-944",
    "snippet": "__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "s2t_map[i].string",
            "s2t_map[i].stringlen"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "s2t_map[i].stringlen + 4"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "s2t_map"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\n__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}"
  },
  {
    "function_name": "nfs4_acl_get_whotype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "914-925",
    "snippet": "int\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s2t_map[i].string",
            "p",
            "len"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "s2t_map"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\nint\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}"
  },
  {
    "function_name": "nfs4_acl_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "887-890",
    "snippet": "int nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static short ace2type(struct nfs4_ace *);",
      "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}"
  },
  {
    "function_name": "ace2type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "865-881",
    "snippet": "static short\nace2type(struct nfs4_ace *ace)\n{\n\tswitch (ace->whotype) {\n\t\tcase NFS4_ACL_WHO_NAMED:\n\t\t\treturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\n\t\t\t\t\tACL_GROUP : ACL_USER);\n\t\tcase NFS4_ACL_WHO_OWNER:\n\t\t\treturn ACL_USER_OBJ;\n\t\tcase NFS4_ACL_WHO_GROUP:\n\t\t\treturn ACL_GROUP_OBJ;\n\t\tcase NFS4_ACL_WHO_EVERYONE:\n\t\t\treturn ACL_OTHER;\n\t}\n\tBUG();\n\treturn -1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static short ace2type(struct nfs4_ace *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\n\nstatic short\nace2type(struct nfs4_ace *ace)\n{\n\tswitch (ace->whotype) {\n\t\tcase NFS4_ACL_WHO_NAMED:\n\t\t\treturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\n\t\t\t\t\tACL_GROUP : ACL_USER);\n\t\tcase NFS4_ACL_WHO_OWNER:\n\t\t\treturn ACL_USER_OBJ;\n\t\tcase NFS4_ACL_WHO_GROUP:\n\t\t\treturn ACL_GROUP_OBJ;\n\t\tcase NFS4_ACL_WHO_EVERYONE:\n\t\t\treturn ACL_OTHER;\n\t}\n\tBUG();\n\treturn -1;\n}"
  },
  {
    "function_name": "nfsd4_set_nfs4_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "814-862",
    "snippet": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_ACL_DIR\t\t0x02"
    ],
    "globals_used": [
      "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "host_error"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "dpacl"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "pacl"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "dpacl",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "pacl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_acl_nfsv4_to_posix",
          "args": [
            "acl",
            "&pacl",
            "&dpacl",
            "flags"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_nfsv4_to_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "752-812",
          "snippet": "static int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\n\t\tstruct posix_acl **pacl, struct posix_acl **dpacl,\n\t\tunsigned int flags)\n{\n\tstruct posix_acl_state effective_acl_state, default_acl_state;\n\tstruct nfs4_ace *ace;\n\tint ret;\n\n\tret = init_state(&effective_acl_state, acl->naces);\n\tif (ret)\n\t\treturn ret;\n\tret = init_state(&default_acl_state, acl->naces);\n\tif (ret)\n\t\tgoto out_estate;\n\tret = -EINVAL;\n\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\tif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    ace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\n\t\t\tgoto out_dstate;\n\t\tif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\n\t\t\tgoto out_dstate;\n\t\tif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(flags & NFS4_ACL_DIR))\n\t\t\tgoto out_dstate;\n\t\t/*\n\t\t * Note that when only one of FILE_INHERIT or DIRECTORY_INHERIT\n\t\t * is set, we're effectively turning on the other.  That's OK,\n\t\t * according to rfc 3530.\n\t\t */\n\t\tprocess_one_v4_ace(&default_acl_state, ace);\n\n\t\tif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t}\n\t*pacl = posix_state_to_acl(&effective_acl_state, flags);\n\tif (IS_ERR(*pacl)) {\n\t\tret = PTR_ERR(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\t*dpacl = posix_state_to_acl(&default_acl_state,\n\t\t\t\t\t\tflags | NFS4_ACL_TYPE_DEFAULT);\n\tif (IS_ERR(*dpacl)) {\n\t\tret = PTR_ERR(*dpacl);\n\t\t*dpacl = NULL;\n\t\tposix_acl_release(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\tsort_pacl(*pacl);\n\tsort_pacl(*dpacl);\n\tret = 0;\nout_dstate:\n\tfree_state(&default_acl_state);\nout_estate:\n\tfree_state(&effective_acl_state);\n\treturn ret;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_SUPPORTED_FLAGS (NFS4_INHERITANCE_FLAGS \\\n\t\t| NFS4_ACE_INHERIT_ONLY_ACE \\\n\t\t| NFS4_ACE_IDENTIFIER_GROUP)",
            "#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)",
            "#define NFS4_ACL_DIR\t\t0x02",
            "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
          ],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);",
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_SUPPORTED_FLAGS (NFS4_INHERITANCE_FLAGS \\\n\t\t| NFS4_ACE_INHERIT_ONLY_ACE \\\n\t\t| NFS4_ACE_IDENTIFIER_GROUP)\n#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nstatic int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\n\t\tstruct posix_acl **pacl, struct posix_acl **dpacl,\n\t\tunsigned int flags)\n{\n\tstruct posix_acl_state effective_acl_state, default_acl_state;\n\tstruct nfs4_ace *ace;\n\tint ret;\n\n\tret = init_state(&effective_acl_state, acl->naces);\n\tif (ret)\n\t\treturn ret;\n\tret = init_state(&default_acl_state, acl->naces);\n\tif (ret)\n\t\tgoto out_estate;\n\tret = -EINVAL;\n\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\tif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    ace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\n\t\t\tgoto out_dstate;\n\t\tif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\n\t\t\tgoto out_dstate;\n\t\tif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(flags & NFS4_ACL_DIR))\n\t\t\tgoto out_dstate;\n\t\t/*\n\t\t * Note that when only one of FILE_INHERIT or DIRECTORY_INHERIT\n\t\t * is set, we're effectively turning on the other.  That's OK,\n\t\t * according to rfc 3530.\n\t\t */\n\t\tprocess_one_v4_ace(&default_acl_state, ace);\n\n\t\tif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t}\n\t*pacl = posix_state_to_acl(&effective_acl_state, flags);\n\tif (IS_ERR(*pacl)) {\n\t\tret = PTR_ERR(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\t*dpacl = posix_state_to_acl(&default_acl_state,\n\t\t\t\t\t\tflags | NFS4_ACL_TYPE_DEFAULT);\n\tif (IS_ERR(*dpacl)) {\n\t\tret = PTR_ERR(*dpacl);\n\t\t*dpacl = NULL;\n\t\tposix_acl_release(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\tsort_pacl(*pacl);\n\tsort_pacl(*dpacl);\n\tret = 0;\nout_dstate:\n\tfree_state(&default_acl_state);\nout_estate:\n\tfree_state(&effective_acl_state);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "fhp",
            "0",
            "NFSD_MAY_SATTR"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\n__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}"
  },
  {
    "function_name": "nfs4_acl_nfsv4_to_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "752-812",
    "snippet": "static int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\n\t\tstruct posix_acl **pacl, struct posix_acl **dpacl,\n\t\tunsigned int flags)\n{\n\tstruct posix_acl_state effective_acl_state, default_acl_state;\n\tstruct nfs4_ace *ace;\n\tint ret;\n\n\tret = init_state(&effective_acl_state, acl->naces);\n\tif (ret)\n\t\treturn ret;\n\tret = init_state(&default_acl_state, acl->naces);\n\tif (ret)\n\t\tgoto out_estate;\n\tret = -EINVAL;\n\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\tif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    ace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\n\t\t\tgoto out_dstate;\n\t\tif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\n\t\t\tgoto out_dstate;\n\t\tif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(flags & NFS4_ACL_DIR))\n\t\t\tgoto out_dstate;\n\t\t/*\n\t\t * Note that when only one of FILE_INHERIT or DIRECTORY_INHERIT\n\t\t * is set, we're effectively turning on the other.  That's OK,\n\t\t * according to rfc 3530.\n\t\t */\n\t\tprocess_one_v4_ace(&default_acl_state, ace);\n\n\t\tif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t}\n\t*pacl = posix_state_to_acl(&effective_acl_state, flags);\n\tif (IS_ERR(*pacl)) {\n\t\tret = PTR_ERR(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\t*dpacl = posix_state_to_acl(&default_acl_state,\n\t\t\t\t\t\tflags | NFS4_ACL_TYPE_DEFAULT);\n\tif (IS_ERR(*dpacl)) {\n\t\tret = PTR_ERR(*dpacl);\n\t\t*dpacl = NULL;\n\t\tposix_acl_release(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\tsort_pacl(*pacl);\n\tsort_pacl(*dpacl);\n\tret = 0;\nout_dstate:\n\tfree_state(&default_acl_state);\nout_estate:\n\tfree_state(&effective_acl_state);\n\treturn ret;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_SUPPORTED_FLAGS (NFS4_INHERITANCE_FLAGS \\\n\t\t| NFS4_ACE_INHERIT_ONLY_ACE \\\n\t\t| NFS4_ACE_IDENTIFIER_GROUP)",
      "#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)",
      "#define NFS4_ACL_DIR\t\t0x02",
      "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
    ],
    "globals_used": [
      "static short ace2type(struct nfs4_ace *);",
      "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_state",
          "args": [
            "&effective_acl_state"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "free_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "491-495",
          "snippet": "static void\nfree_state(struct posix_acl_state *state) {\n\tkfree(state->users);\n\tkfree(state->groups);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nfree_state(struct posix_acl_state *state) {\n\tkfree(state->users);\n\tkfree(state->groups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_pacl",
          "args": [
            "*dpacl"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "sort_pacl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "405-427",
          "snippet": "static void\nsort_pacl(struct posix_acl *pacl)\n{\n\t/* posix_acl_valid requires that users and groups be in order\n\t * by uid/gid. */\n\tint i, j;\n\n\t/* no users or groups */\n\tif (!pacl || pacl->a_count <= 4)\n\t\treturn;\n\n\ti = 1;\n\twhile (pacl->a_entries[i].e_tag == ACL_USER)\n\t\ti++;\n\tsort_pacl_range(pacl, 1, i-1);\n\n\tBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\n\tj = ++i;\n\twhile (pacl->a_entries[j].e_tag == ACL_GROUP)\n\t\tj++;\n\tsort_pacl_range(pacl, i, j-1);\n\treturn;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsort_pacl(struct posix_acl *pacl)\n{\n\t/* posix_acl_valid requires that users and groups be in order\n\t * by uid/gid. */\n\tint i, j;\n\n\t/* no users or groups */\n\tif (!pacl || pacl->a_count <= 4)\n\t\treturn;\n\n\ti = 1;\n\twhile (pacl->a_entries[i].e_tag == ACL_USER)\n\t\ti++;\n\tsort_pacl_range(pacl, 1, i-1);\n\n\tBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\n\tj = ++i;\n\twhile (pacl->a_entries[j].e_tag == ACL_GROUP)\n\t\tj++;\n\tsort_pacl_range(pacl, i, j-1);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "*pacl"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*dpacl"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*dpacl"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_state_to_acl",
          "args": [
            "&default_acl_state",
            "flags | NFS4_ACL_TYPE_DEFAULT"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "posix_state_to_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "532-617",
          "snippet": "static struct posix_acl *\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct posix_acl *pacl;\n\tint nace;\n\tint i, error = 0;\n\n\t/*\n\t * ACLs with no ACEs are treated differently in the inheritable\n\t * and effective cases: when there are no inheritable ACEs,\n\t * calls ->set_acl with a NULL ACL structure.\n\t */\n\tif (state->empty && (flags & NFS4_ACL_TYPE_DEFAULT))\n\t\treturn NULL;\n\n\t/*\n\t * When there are no effective ACEs, the following will end\n\t * up setting a 3-element effective posix ACL with all\n\t * permissions zero.\n\t */\n\tif (!state->users->n && !state->groups->n)\n\t\tnace = 3;\n\telse /* Note we also include a MASK ACE in this case: */\n\t\tnace = 4 + state->users->n + state->groups->n;\n\tpacl = posix_acl_alloc(nace, GFP_KERNEL);\n\tif (!pacl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpace = pacl->a_entries;\n\tpace->e_tag = ACL_USER_OBJ;\n\terror = check_deny(state->owner.deny, 1);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\n\n\tfor (i=0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\terror = check_deny(state->users->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->users->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tadd_to_mask(state, &state->users->aces[i].perms);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\terror = check_deny(state->group.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\n\tadd_to_mask(state, &state->group);\n\n\tfor (i=0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\terror = check_deny(state->groups->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tadd_to_mask(state, &state->groups->aces[i].perms);\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\terror = check_deny(state->other.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\n\n\treturn pacl;\nout_err:\n\tposix_acl_release(pacl);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic struct posix_acl *\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct posix_acl *pacl;\n\tint nace;\n\tint i, error = 0;\n\n\t/*\n\t * ACLs with no ACEs are treated differently in the inheritable\n\t * and effective cases: when there are no inheritable ACEs,\n\t * calls ->set_acl with a NULL ACL structure.\n\t */\n\tif (state->empty && (flags & NFS4_ACL_TYPE_DEFAULT))\n\t\treturn NULL;\n\n\t/*\n\t * When there are no effective ACEs, the following will end\n\t * up setting a 3-element effective posix ACL with all\n\t * permissions zero.\n\t */\n\tif (!state->users->n && !state->groups->n)\n\t\tnace = 3;\n\telse /* Note we also include a MASK ACE in this case: */\n\t\tnace = 4 + state->users->n + state->groups->n;\n\tpacl = posix_acl_alloc(nace, GFP_KERNEL);\n\tif (!pacl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpace = pacl->a_entries;\n\tpace->e_tag = ACL_USER_OBJ;\n\terror = check_deny(state->owner.deny, 1);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\n\n\tfor (i=0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\terror = check_deny(state->users->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->users->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tadd_to_mask(state, &state->users->aces[i].perms);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\terror = check_deny(state->group.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\n\tadd_to_mask(state, &state->group);\n\n\tfor (i=0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\terror = check_deny(state->groups->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tadd_to_mask(state, &state->groups->aces[i].perms);\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\terror = check_deny(state->other.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\n\n\treturn pacl;\nout_err:\n\tposix_acl_release(pacl);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*pacl"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*pacl"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_one_v4_ace",
          "args": [
            "&effective_acl_state",
            "ace"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "process_one_v4_ace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "681-750",
          "snippet": "static void process_one_v4_ace(struct posix_acl_state *state,\n\t\t\t\tstruct nfs4_ace *ace)\n{\n\tu32 mask = ace->access_mask;\n\tint i;\n\n\tstate->empty = 0;\n\n\tswitch (ace2type(ace)) {\n\tcase ACL_USER_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_USER:\n\t\ti = find_uid(state, ace->who_uid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->users->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->users->aces[i].perms, mask);\n\t\t\tmask = state->users->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->group, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tmask = state->group.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\ti = find_gid(state, ace->who_gid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->groups->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->groups->aces[i].perms, mask);\n\t\t\tmask = state->groups->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_OTHER:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t\tallow_bits(&state->group, mask);\n\t\t\tallow_bits(&state->other, mask);\n\t\t\tallow_bits(&state->everyone, mask);\n\t\t\tallow_bits_array(state->users, mask);\n\t\t\tallow_bits_array(state->groups, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->other, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\n\nstatic void process_one_v4_ace(struct posix_acl_state *state,\n\t\t\t\tstruct nfs4_ace *ace)\n{\n\tu32 mask = ace->access_mask;\n\tint i;\n\n\tstate->empty = 0;\n\n\tswitch (ace2type(ace)) {\n\tcase ACL_USER_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_USER:\n\t\ti = find_uid(state, ace->who_uid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->users->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->users->aces[i].perms, mask);\n\t\t\tmask = state->users->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->group, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tmask = state->group.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\ti = find_gid(state, ace->who_gid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->groups->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->groups->aces[i].perms, mask);\n\t\t\tmask = state->groups->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_OTHER:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t\tallow_bits(&state->group, mask);\n\t\t\tallow_bits(&state->other, mask);\n\t\t\tallow_bits(&state->everyone, mask);\n\t\t\tallow_bits_array(state->users, mask);\n\t\t\tallow_bits_array(state->groups, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->other, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_state",
          "args": [
            "&default_acl_state",
            "acl->naces"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "init_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "466-489",
          "snippet": "static int\ninit_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int\ninit_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_SUPPORTED_FLAGS (NFS4_INHERITANCE_FLAGS \\\n\t\t| NFS4_ACE_INHERIT_ONLY_ACE \\\n\t\t| NFS4_ACE_IDENTIFIER_GROUP)\n#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nstatic int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\n\t\tstruct posix_acl **pacl, struct posix_acl **dpacl,\n\t\tunsigned int flags)\n{\n\tstruct posix_acl_state effective_acl_state, default_acl_state;\n\tstruct nfs4_ace *ace;\n\tint ret;\n\n\tret = init_state(&effective_acl_state, acl->naces);\n\tif (ret)\n\t\treturn ret;\n\tret = init_state(&default_acl_state, acl->naces);\n\tif (ret)\n\t\tgoto out_estate;\n\tret = -EINVAL;\n\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\tif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    ace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\n\t\t\tgoto out_dstate;\n\t\tif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\n\t\t\tgoto out_dstate;\n\t\tif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(flags & NFS4_ACL_DIR))\n\t\t\tgoto out_dstate;\n\t\t/*\n\t\t * Note that when only one of FILE_INHERIT or DIRECTORY_INHERIT\n\t\t * is set, we're effectively turning on the other.  That's OK,\n\t\t * according to rfc 3530.\n\t\t */\n\t\tprocess_one_v4_ace(&default_acl_state, ace);\n\n\t\tif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\n\t\t\tprocess_one_v4_ace(&effective_acl_state, ace);\n\t}\n\t*pacl = posix_state_to_acl(&effective_acl_state, flags);\n\tif (IS_ERR(*pacl)) {\n\t\tret = PTR_ERR(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\t*dpacl = posix_state_to_acl(&default_acl_state,\n\t\t\t\t\t\tflags | NFS4_ACL_TYPE_DEFAULT);\n\tif (IS_ERR(*dpacl)) {\n\t\tret = PTR_ERR(*dpacl);\n\t\t*dpacl = NULL;\n\t\tposix_acl_release(*pacl);\n\t\t*pacl = NULL;\n\t\tgoto out_dstate;\n\t}\n\tsort_pacl(*pacl);\n\tsort_pacl(*dpacl);\n\tret = 0;\nout_dstate:\n\tfree_state(&default_acl_state);\nout_estate:\n\tfree_state(&effective_acl_state);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_one_v4_ace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "681-750",
    "snippet": "static void process_one_v4_ace(struct posix_acl_state *state,\n\t\t\t\tstruct nfs4_ace *ace)\n{\n\tu32 mask = ace->access_mask;\n\tint i;\n\n\tstate->empty = 0;\n\n\tswitch (ace2type(ace)) {\n\tcase ACL_USER_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_USER:\n\t\ti = find_uid(state, ace->who_uid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->users->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->users->aces[i].perms, mask);\n\t\t\tmask = state->users->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->group, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tmask = state->group.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\ti = find_gid(state, ace->who_gid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->groups->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->groups->aces[i].perms, mask);\n\t\t\tmask = state->groups->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_OTHER:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t\tallow_bits(&state->group, mask);\n\t\t\tallow_bits(&state->other, mask);\n\t\t\tallow_bits(&state->everyone, mask);\n\t\t\tallow_bits_array(state->users, mask);\n\t\t\tallow_bits_array(state->groups, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->other, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static short ace2type(struct nfs4_ace *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deny_bits_array",
          "args": [
            "state->groups",
            "mask"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "deny_bits_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "665-671",
          "snippet": "static void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_bits_array",
          "args": [
            "state->groups",
            "mask"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "allow_bits_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "673-679",
          "snippet": "static void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_gid",
          "args": [
            "state",
            "ace->who_gid"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "find_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "648-663",
          "snippet": "static int find_gid(struct posix_acl_state *state, kgid_t gid)\n{\n\tstruct posix_ace_state_array *a = state->groups;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (gid_eq(a->aces[i].gid, gid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].gid = gid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int find_gid(struct posix_acl_state *state, kgid_t gid)\n{\n\tstruct posix_ace_state_array *a = state->groups;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (gid_eq(a->aces[i].gid, gid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].gid = gid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_uid",
          "args": [
            "state",
            "ace->who_uid"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "find_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "631-646",
          "snippet": "static int find_uid(struct posix_acl_state *state, kuid_t uid)\n{\n\tstruct posix_ace_state_array *a = state->users;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (uid_eq(a->aces[i].uid, uid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int find_uid(struct posix_acl_state *state, kuid_t uid)\n{\n\tstruct posix_ace_state_array *a = state->users;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (uid_eq(a->aces[i].uid, uid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ace2type",
          "args": [
            "ace"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ace2type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "865-881",
          "snippet": "static short\nace2type(struct nfs4_ace *ace)\n{\n\tswitch (ace->whotype) {\n\t\tcase NFS4_ACL_WHO_NAMED:\n\t\t\treturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\n\t\t\t\t\tACL_GROUP : ACL_USER);\n\t\tcase NFS4_ACL_WHO_OWNER:\n\t\t\treturn ACL_USER_OBJ;\n\t\tcase NFS4_ACL_WHO_GROUP:\n\t\t\treturn ACL_GROUP_OBJ;\n\t\tcase NFS4_ACL_WHO_EVERYONE:\n\t\t\treturn ACL_OTHER;\n\t}\n\tBUG();\n\treturn -1;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\n\nstatic short\nace2type(struct nfs4_ace *ace)\n{\n\tswitch (ace->whotype) {\n\t\tcase NFS4_ACL_WHO_NAMED:\n\t\t\treturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\n\t\t\t\t\tACL_GROUP : ACL_USER);\n\t\tcase NFS4_ACL_WHO_OWNER:\n\t\t\treturn ACL_USER_OBJ;\n\t\tcase NFS4_ACL_WHO_GROUP:\n\t\t\treturn ACL_GROUP_OBJ;\n\t\tcase NFS4_ACL_WHO_EVERYONE:\n\t\t\treturn ACL_OTHER;\n\t}\n\tBUG();\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\n\nstatic void process_one_v4_ace(struct posix_acl_state *state,\n\t\t\t\tstruct nfs4_ace *ace)\n{\n\tu32 mask = ace->access_mask;\n\tint i;\n\n\tstate->empty = 0;\n\n\tswitch (ace2type(ace)) {\n\tcase ACL_USER_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_USER:\n\t\ti = find_uid(state, ace->who_uid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->users->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->users->aces[i].perms, mask);\n\t\t\tmask = state->users->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP_OBJ:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->group, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tmask = state->group.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\ti = find_gid(state, ace->who_gid);\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->groups->aces[i].perms, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->groups->aces[i].perms, mask);\n\t\t\tmask = state->groups->aces[i].perms.deny;\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t\tbreak;\n\tcase ACL_OTHER:\n\t\tif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\tallow_bits(&state->owner, mask);\n\t\t\tallow_bits(&state->group, mask);\n\t\t\tallow_bits(&state->other, mask);\n\t\t\tallow_bits(&state->everyone, mask);\n\t\t\tallow_bits_array(state->users, mask);\n\t\t\tallow_bits_array(state->groups, mask);\n\t\t} else {\n\t\t\tdeny_bits(&state->owner, mask);\n\t\t\tdeny_bits(&state->group, mask);\n\t\t\tdeny_bits(&state->other, mask);\n\t\t\tdeny_bits(&state->everyone, mask);\n\t\t\tdeny_bits_array(state->users, mask);\n\t\t\tdeny_bits_array(state->groups, mask);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "allow_bits_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "673-679",
    "snippet": "static void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "allow_bits",
          "args": [
            "&a->aces[i].perms",
            "mask"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "allow_bits_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "673-679",
          "snippet": "static void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tallow_bits(&a->aces[i].perms, mask);\n}"
  },
  {
    "function_name": "deny_bits_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "665-671",
    "snippet": "static void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deny_bits",
          "args": [
            "&a->aces[i].perms",
            "mask"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "deny_bits_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "665-671",
          "snippet": "static void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\n{\n\tint i;\n\n\tfor (i=0; i < a->n; i++)\n\t\tdeny_bits(&a->aces[i].perms, mask);\n}"
  },
  {
    "function_name": "find_gid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "648-663",
    "snippet": "static int find_gid(struct posix_acl_state *state, kgid_t gid)\n{\n\tstruct posix_ace_state_array *a = state->groups;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (gid_eq(a->aces[i].gid, gid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].gid = gid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "a->aces[i].gid",
            "gid"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int find_gid(struct posix_acl_state *state, kgid_t gid)\n{\n\tstruct posix_ace_state_array *a = state->groups;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (gid_eq(a->aces[i].gid, gid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].gid = gid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}"
  },
  {
    "function_name": "find_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "631-646",
    "snippet": "static int find_uid(struct posix_acl_state *state, kuid_t uid)\n{\n\tstruct posix_ace_state_array *a = state->users;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (uid_eq(a->aces[i].uid, uid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "a->aces[i].uid",
            "uid"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int find_uid(struct posix_acl_state *state, kuid_t uid)\n{\n\tstruct posix_ace_state_array *a = state->users;\n\tint i;\n\n\tfor (i = 0; i < a->n; i++)\n\t\tif (uid_eq(a->aces[i].uid, uid))\n\t\t\treturn i;\n\t/* Not found: */\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\n\treturn i;\n}"
  },
  {
    "function_name": "deny_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "625-629",
    "snippet": "static inline void deny_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t/* Deny all bits in the mask not already allowed: */\n\tastate->deny |= mask & ~astate->allow;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline void deny_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t/* Deny all bits in the mask not already allowed: */\n\tastate->deny |= mask & ~astate->allow;\n}"
  },
  {
    "function_name": "allow_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "619-623",
    "snippet": "static inline void allow_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t/* Allow all bits in the mask not already denied: */\n\tastate->allow |= mask & ~astate->deny;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline void allow_bits(struct posix_ace_state *astate, u32 mask)\n{\n\t/* Allow all bits in the mask not already denied: */\n\tastate->allow |= mask & ~astate->deny;\n}"
  },
  {
    "function_name": "posix_state_to_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "532-617",
    "snippet": "static struct posix_acl *\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct posix_acl *pacl;\n\tint nace;\n\tint i, error = 0;\n\n\t/*\n\t * ACLs with no ACEs are treated differently in the inheritable\n\t * and effective cases: when there are no inheritable ACEs,\n\t * calls ->set_acl with a NULL ACL structure.\n\t */\n\tif (state->empty && (flags & NFS4_ACL_TYPE_DEFAULT))\n\t\treturn NULL;\n\n\t/*\n\t * When there are no effective ACEs, the following will end\n\t * up setting a 3-element effective posix ACL with all\n\t * permissions zero.\n\t */\n\tif (!state->users->n && !state->groups->n)\n\t\tnace = 3;\n\telse /* Note we also include a MASK ACE in this case: */\n\t\tnace = 4 + state->users->n + state->groups->n;\n\tpacl = posix_acl_alloc(nace, GFP_KERNEL);\n\tif (!pacl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpace = pacl->a_entries;\n\tpace->e_tag = ACL_USER_OBJ;\n\terror = check_deny(state->owner.deny, 1);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\n\n\tfor (i=0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\terror = check_deny(state->users->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->users->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tadd_to_mask(state, &state->users->aces[i].perms);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\terror = check_deny(state->group.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\n\tadd_to_mask(state, &state->group);\n\n\tfor (i=0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\terror = check_deny(state->groups->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tadd_to_mask(state, &state->groups->aces[i].perms);\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\terror = check_deny(state->other.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\n\n\treturn pacl;\nout_err:\n\tposix_acl_release(pacl);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "pacl"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_mode_from_nfs4",
          "args": [
            "state->other.allow",
            "&pace->e_perm",
            "flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "low_mode_from_nfs4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "113-127",
          "snippet": "static void\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\n{\n\tu32 write_mode = NFS4_WRITE_MODE;\n\n\tif (flags & NFS4_ACL_DIR)\n\t\twrite_mode |= NFS4_ACE_DELETE_CHILD;\n\t*mode = 0;\n\tif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\n\t\t*mode |= ACL_READ;\n\tif ((perm & write_mode) == write_mode)\n\t\t*mode |= ACL_WRITE;\n\tif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\n\t\t*mode |= ACL_EXECUTE;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE",
            "#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)",
            "#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)",
            "#define NFS4_ACL_DIR\t\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic void\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\n{\n\tu32 write_mode = NFS4_WRITE_MODE;\n\n\tif (flags & NFS4_ACL_DIR)\n\t\twrite_mode |= NFS4_ACE_DELETE_CHILD;\n\t*mode = 0;\n\tif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\n\t\t*mode |= ACL_READ;\n\tif ((perm & write_mode) == write_mode)\n\t\t*mode |= ACL_WRITE;\n\tif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\n\t\t*mode |= ACL_EXECUTE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_deny",
          "args": [
            "state->other.deny",
            "0"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "check_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "521-530",
          "snippet": "static inline int check_deny(u32 mask, int isowner)\n{\n\tif (mask & (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL))\n\t\treturn -EINVAL;\n\tif (!isowner)\n\t\treturn 0;\n\tif (mask & (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline int check_deny(u32 mask, int isowner)\n{\n\tif (mask & (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL))\n\t\treturn -EINVAL;\n\tif (!isowner)\n\t\treturn 0;\n\tif (mask & (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_mask",
          "args": [
            "state",
            "&state->groups->aces[i].perms"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "497-500",
          "snippet": "static inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\n{\n\tstate->mask.allow |= astate->allow;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\n{\n\tstate->mask.allow |= astate->allow;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "nace",
            "GFP_KERNEL"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic struct posix_acl *\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct posix_acl *pacl;\n\tint nace;\n\tint i, error = 0;\n\n\t/*\n\t * ACLs with no ACEs are treated differently in the inheritable\n\t * and effective cases: when there are no inheritable ACEs,\n\t * calls ->set_acl with a NULL ACL structure.\n\t */\n\tif (state->empty && (flags & NFS4_ACL_TYPE_DEFAULT))\n\t\treturn NULL;\n\n\t/*\n\t * When there are no effective ACEs, the following will end\n\t * up setting a 3-element effective posix ACL with all\n\t * permissions zero.\n\t */\n\tif (!state->users->n && !state->groups->n)\n\t\tnace = 3;\n\telse /* Note we also include a MASK ACE in this case: */\n\t\tnace = 4 + state->users->n + state->groups->n;\n\tpacl = posix_acl_alloc(nace, GFP_KERNEL);\n\tif (!pacl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpace = pacl->a_entries;\n\tpace->e_tag = ACL_USER_OBJ;\n\terror = check_deny(state->owner.deny, 1);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\n\n\tfor (i=0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\terror = check_deny(state->users->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->users->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tadd_to_mask(state, &state->users->aces[i].perms);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\terror = check_deny(state->group.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\n\tadd_to_mask(state, &state->group);\n\n\tfor (i=0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\terror = check_deny(state->groups->aces[i].perms.deny, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\n\t\t\t\t\t&pace->e_perm, flags);\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tadd_to_mask(state, &state->groups->aces[i].perms);\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\terror = check_deny(state->other.deny, 0);\n\tif (error)\n\t\tgoto out_err;\n\tlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\n\n\treturn pacl;\nout_err:\n\tposix_acl_release(pacl);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "check_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "521-530",
    "snippet": "static inline int check_deny(u32 mask, int isowner)\n{\n\tif (mask & (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL))\n\t\treturn -EINVAL;\n\tif (!isowner)\n\t\treturn 0;\n\tif (mask & (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline int check_deny(u32 mask, int isowner)\n{\n\tif (mask & (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL))\n\t\treturn -EINVAL;\n\tif (!isowner)\n\t\treturn 0;\n\tif (mask & (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_to_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "497-500",
    "snippet": "static inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\n{\n\tstate->mask.allow |= astate->allow;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\n{\n\tstate->mask.allow |= astate->allow;\n}"
  },
  {
    "function_name": "free_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "491-495",
    "snippet": "static void\nfree_state(struct posix_acl_state *state) {\n\tkfree(state->users);\n\tkfree(state->groups);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "state->groups"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "state->users"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nfree_state(struct posix_acl_state *state) {\n\tkfree(state->users);\n\tkfree(state->groups);\n}"
  },
  {
    "function_name": "init_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "466-489",
    "snippet": "static int\ninit_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "state->users"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc",
            "GFP_KERNEL"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc",
            "GFP_KERNEL"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "state",
            "0",
            "sizeof(struct posix_acl_state)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic int\ninit_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sort_pacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "405-427",
    "snippet": "static void\nsort_pacl(struct posix_acl *pacl)\n{\n\t/* posix_acl_valid requires that users and groups be in order\n\t * by uid/gid. */\n\tint i, j;\n\n\t/* no users or groups */\n\tif (!pacl || pacl->a_count <= 4)\n\t\treturn;\n\n\ti = 1;\n\twhile (pacl->a_entries[i].e_tag == ACL_USER)\n\t\ti++;\n\tsort_pacl_range(pacl, 1, i-1);\n\n\tBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\n\tj = ++i;\n\twhile (pacl->a_entries[j].e_tag == ACL_GROUP)\n\t\tj++;\n\tsort_pacl_range(pacl, i, j-1);\n\treturn;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort_pacl_range",
          "args": [
            "pacl",
            "i",
            "j-1"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "sort_pacl_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "384-403",
          "snippet": "static void\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\n\tint sorted = 0, i;\n\tstruct posix_acl_entry tmp;\n\n\t/* We just do a bubble sort; easy to do in place, and we're not\n\t * expecting acl's to be long enough to justify anything more. */\n\twhile (!sorted) {\n\t\tsorted = 1;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (pace_gt(&pacl->a_entries[i],\n\t\t\t\t    &pacl->a_entries[i+1])) {\n\t\t\t\tsorted = 0;\n\t\t\t\ttmp = pacl->a_entries[i];\n\t\t\t\tpacl->a_entries[i] = pacl->a_entries[i+1];\n\t\t\t\tpacl->a_entries[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\n\tint sorted = 0, i;\n\tstruct posix_acl_entry tmp;\n\n\t/* We just do a bubble sort; easy to do in place, and we're not\n\t * expecting acl's to be long enough to justify anything more. */\n\twhile (!sorted) {\n\t\tsorted = 1;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (pace_gt(&pacl->a_entries[i],\n\t\t\t\t    &pacl->a_entries[i+1])) {\n\t\t\t\tsorted = 0;\n\t\t\t\ttmp = pacl->a_entries[i];\n\t\t\t\tpacl->a_entries[i] = pacl->a_entries[i+1];\n\t\t\t\tpacl->a_entries[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pacl->a_entries[i].e_tag != ACL_GROUP_OBJ"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsort_pacl(struct posix_acl *pacl)\n{\n\t/* posix_acl_valid requires that users and groups be in order\n\t * by uid/gid. */\n\tint i, j;\n\n\t/* no users or groups */\n\tif (!pacl || pacl->a_count <= 4)\n\t\treturn;\n\n\ti = 1;\n\twhile (pacl->a_entries[i].e_tag == ACL_USER)\n\t\ti++;\n\tsort_pacl_range(pacl, 1, i-1);\n\n\tBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\n\tj = ++i;\n\twhile (pacl->a_entries[j].e_tag == ACL_GROUP)\n\t\tj++;\n\tsort_pacl_range(pacl, i, j-1);\n\treturn;\n}"
  },
  {
    "function_name": "sort_pacl_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "384-403",
    "snippet": "static void\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\n\tint sorted = 0, i;\n\tstruct posix_acl_entry tmp;\n\n\t/* We just do a bubble sort; easy to do in place, and we're not\n\t * expecting acl's to be long enough to justify anything more. */\n\twhile (!sorted) {\n\t\tsorted = 1;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (pace_gt(&pacl->a_entries[i],\n\t\t\t\t    &pacl->a_entries[i+1])) {\n\t\t\t\tsorted = 0;\n\t\t\t\ttmp = pacl->a_entries[i];\n\t\t\t\tpacl->a_entries[i] = pacl->a_entries[i+1];\n\t\t\t\tpacl->a_entries[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pace_gt",
          "args": [
            "&pacl->a_entries[i]",
            "&pacl->a_entries[i+1]"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "pace_gt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "372-382",
          "snippet": "static bool\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\n{\n\tif (pace1->e_tag != pace2->e_tag)\n\t\treturn pace1->e_tag > pace2->e_tag;\n\tif (pace1->e_tag == ACL_USER)\n\t\treturn uid_gt(pace1->e_uid, pace2->e_uid);\n\tif (pace1->e_tag == ACL_GROUP)\n\t\treturn gid_gt(pace1->e_gid, pace2->e_gid);\n\treturn false;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic bool\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\n{\n\tif (pace1->e_tag != pace2->e_tag)\n\t\treturn pace1->e_tag > pace2->e_tag;\n\tif (pace1->e_tag == ACL_USER)\n\t\treturn uid_gt(pace1->e_uid, pace2->e_uid);\n\tif (pace1->e_tag == ACL_GROUP)\n\t\treturn gid_gt(pace1->e_gid, pace2->e_gid);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\n\tint sorted = 0, i;\n\tstruct posix_acl_entry tmp;\n\n\t/* We just do a bubble sort; easy to do in place, and we're not\n\t * expecting acl's to be long enough to justify anything more. */\n\twhile (!sorted) {\n\t\tsorted = 1;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (pace_gt(&pacl->a_entries[i],\n\t\t\t\t    &pacl->a_entries[i+1])) {\n\t\t\t\tsorted = 0;\n\t\t\t\ttmp = pacl->a_entries[i];\n\t\t\t\tpacl->a_entries[i] = pacl->a_entries[i+1];\n\t\t\t\tpacl->a_entries[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pace_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "372-382",
    "snippet": "static bool\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\n{\n\tif (pace1->e_tag != pace2->e_tag)\n\t\treturn pace1->e_tag > pace2->e_tag;\n\tif (pace1->e_tag == ACL_USER)\n\t\treturn uid_gt(pace1->e_uid, pace2->e_uid);\n\tif (pace1->e_tag == ACL_GROUP)\n\t\treturn gid_gt(pace1->e_gid, pace2->e_gid);\n\treturn false;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "pace1->e_gid",
            "pace2->e_gid"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "pace1->e_uid",
            "pace2->e_uid"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic bool\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\n{\n\tif (pace1->e_tag != pace2->e_tag)\n\t\treturn pace1->e_tag > pace2->e_tag;\n\tif (pace1->e_tag == ACL_USER)\n\t\treturn uid_gt(pace1->e_uid, pace2->e_uid);\n\tif (pace1->e_tag == ACL_GROUP)\n\t\treturn gid_gt(pace1->e_gid, pace2->e_gid);\n\treturn false;\n}"
  },
  {
    "function_name": "_posix_to_nfsv4_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "242-370",
    "snippet": "static void\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct posix_acl_entry *pa, *group_owner_entry;\n\tstruct nfs4_ace *ace;\n\tstruct posix_acl_summary pas;\n\tunsigned short deny;\n\tint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\n\t\tNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\n\n\tBUG_ON(pacl->a_count < 3);\n\tsummarize_posix_acl(pacl, &pas);\n\n\tpa = pacl->a_entries;\n\tace = acl->aces + acl->naces;\n\n\t/* We could deny everything not granted by the owner: */\n\tdeny = ~pas.owner;\n\t/*\n\t * but it is equivalent (and simpler) to deny only what is not\n\t * granted by later entries:\n\t */\n\tdeny &= pas.users | pas.group | pas.groups | pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_OWNER;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\n\tace->whotype = NFS4_ACL_WHO_OWNER;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_USER) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.groups | pas.group | pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_uid = pa->e_uid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_uid = pa->e_uid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* In the case of groups, we apply allow ACEs first, then deny ACEs,\n\t * since a user can be in more than one group.  */\n\n\t/* allow ACEs */\n\n\tgroup_owner_entry = pa;\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pas.group, flags);\n\tace->whotype = NFS4_ACL_WHO_GROUP;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_gid = pa->e_gid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* deny ACEs */\n\n\tpa = group_owner_entry;\n\n\tdeny = ~pas.group & pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_GROUP;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_gid = pa->e_gid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tpa++;\n\t}\n\n\tif (pa->e_tag == ACL_MASK)\n\t\tpa++;\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags);\n\tace->whotype = NFS4_ACL_WHO_EVERYONE;\n\tacl->naces++;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)",
      "#define NFS4_ACL_OWNER\t\t0x04",
      "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
    ],
    "globals_used": [
      "static short ace2type(struct nfs4_ace *);",
      "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mask_from_posix",
          "args": [
            "pa->e_perm",
            "flags"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "deny_mask_from_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "88-102",
          "snippet": "static u32\ndeny_mask_from_posix(unsigned short perm, u32 flags)\n{\n\tu32 mask = 0;\n\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE",
            "#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)",
            "#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)",
            "#define NFS4_ACL_DIR\t\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic u32\ndeny_mask_from_posix(unsigned short perm, u32 flags)\n{\n\tu32 mask = 0;\n\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "summarize_posix_acl",
          "args": [
            "pacl",
            "&pas"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "summarize_posix_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "198-239",
          "snippet": "static void\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/*\n\t * Only pas.users and pas.groups need initialization; previous\n\t * posix_acl_valid() calls ensure that the other fields will be\n\t * initialized in the following loop.  But, just to placate gcc:\n\t */\n\tmemset(pas, 0, sizeof(*pas));\n\tpas->mask = 07;\n\n\tpe = acl->a_entries + acl->a_count;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpas->owner = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tpas->group = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\t\tpas->users |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tpas->groups |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpas->other = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tpas->mask = pa->e_perm;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* We'll only care about effective permissions: */\n\tpas->users &= pas->mask;\n\tpas->group &= pas->mask;\n\tpas->groups &= pas->mask;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/*\n\t * Only pas.users and pas.groups need initialization; previous\n\t * posix_acl_valid() calls ensure that the other fields will be\n\t * initialized in the following loop.  But, just to placate gcc:\n\t */\n\tmemset(pas, 0, sizeof(*pas));\n\tpas->mask = 07;\n\n\tpe = acl->a_entries + acl->a_count;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpas->owner = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tpas->group = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\t\tpas->users |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tpas->groups |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpas->other = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tpas->mask = pa->e_perm;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* We'll only care about effective permissions: */\n\tpas->users &= pas->mask;\n\tpas->group &= pas->mask;\n\tpas->groups &= pas->mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pacl->a_count < 3"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)\n#define NFS4_ACL_OWNER\t\t0x04\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nstatic void\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct posix_acl_entry *pa, *group_owner_entry;\n\tstruct nfs4_ace *ace;\n\tstruct posix_acl_summary pas;\n\tunsigned short deny;\n\tint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\n\t\tNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\n\n\tBUG_ON(pacl->a_count < 3);\n\tsummarize_posix_acl(pacl, &pas);\n\n\tpa = pacl->a_entries;\n\tace = acl->aces + acl->naces;\n\n\t/* We could deny everything not granted by the owner: */\n\tdeny = ~pas.owner;\n\t/*\n\t * but it is equivalent (and simpler) to deny only what is not\n\t * granted by later entries:\n\t */\n\tdeny &= pas.users | pas.group | pas.groups | pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_OWNER;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\n\tace->whotype = NFS4_ACL_WHO_OWNER;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_USER) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.groups | pas.group | pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_uid = pa->e_uid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_uid = pa->e_uid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* In the case of groups, we apply allow ACEs first, then deny ACEs,\n\t * since a user can be in more than one group.  */\n\n\t/* allow ACEs */\n\n\tgroup_owner_entry = pa;\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pas.group, flags);\n\tace->whotype = NFS4_ACL_WHO_GROUP;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_gid = pa->e_gid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* deny ACEs */\n\n\tpa = group_owner_entry;\n\n\tdeny = ~pas.group & pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_GROUP;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_gid = pa->e_gid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tpa++;\n\t}\n\n\tif (pa->e_tag == ACL_MASK)\n\t\tpa++;\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags);\n\tace->whotype = NFS4_ACL_WHO_EVERYONE;\n\tacl->naces++;\n}"
  },
  {
    "function_name": "summarize_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "198-239",
    "snippet": "static void\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/*\n\t * Only pas.users and pas.groups need initialization; previous\n\t * posix_acl_valid() calls ensure that the other fields will be\n\t * initialized in the following loop.  But, just to placate gcc:\n\t */\n\tmemset(pas, 0, sizeof(*pas));\n\tpas->mask = 07;\n\n\tpe = acl->a_entries + acl->a_count;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpas->owner = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tpas->group = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\t\tpas->users |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tpas->groups |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpas->other = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tpas->mask = pa->e_perm;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* We'll only care about effective permissions: */\n\tpas->users &= pas->mask;\n\tpas->group &= pas->mask;\n\tpas->groups &= pas->mask;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pas",
            "0",
            "sizeof(*pas)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic void\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/*\n\t * Only pas.users and pas.groups need initialization; previous\n\t * posix_acl_valid() calls ensure that the other fields will be\n\t * initialized in the following loop.  But, just to placate gcc:\n\t */\n\tmemset(pas, 0, sizeof(*pas));\n\tpas->mask = 07;\n\n\tpe = acl->a_entries + acl->a_count;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpas->owner = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tpas->group = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\t\tpas->users |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tpas->groups |= pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpas->other = pa->e_perm;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tpas->mask = pa->e_perm;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* We'll only care about effective permissions: */\n\tpas->users &= pas->mask;\n\tpas->group &= pas->mask;\n\tpas->groups &= pas->mask;\n}"
  },
  {
    "function_name": "nfsd4_get_nfs4_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "138-187",
    "snippet": "int\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_ACL_DIR\t\t0x02",
      "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
    ],
    "globals_used": [
      "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "pacl"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "dpacl"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_posix_to_nfsv4_one",
          "args": [
            "dpacl",
            "*acl",
            "flags | NFS4_ACL_TYPE_DEFAULT"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "_posix_to_nfsv4_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "242-370",
          "snippet": "static void\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct posix_acl_entry *pa, *group_owner_entry;\n\tstruct nfs4_ace *ace;\n\tstruct posix_acl_summary pas;\n\tunsigned short deny;\n\tint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\n\t\tNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\n\n\tBUG_ON(pacl->a_count < 3);\n\tsummarize_posix_acl(pacl, &pas);\n\n\tpa = pacl->a_entries;\n\tace = acl->aces + acl->naces;\n\n\t/* We could deny everything not granted by the owner: */\n\tdeny = ~pas.owner;\n\t/*\n\t * but it is equivalent (and simpler) to deny only what is not\n\t * granted by later entries:\n\t */\n\tdeny &= pas.users | pas.group | pas.groups | pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_OWNER;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\n\tace->whotype = NFS4_ACL_WHO_OWNER;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_USER) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.groups | pas.group | pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_uid = pa->e_uid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_uid = pa->e_uid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* In the case of groups, we apply allow ACEs first, then deny ACEs,\n\t * since a user can be in more than one group.  */\n\n\t/* allow ACEs */\n\n\tgroup_owner_entry = pa;\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pas.group, flags);\n\tace->whotype = NFS4_ACL_WHO_GROUP;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_gid = pa->e_gid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* deny ACEs */\n\n\tpa = group_owner_entry;\n\n\tdeny = ~pas.group & pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_GROUP;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_gid = pa->e_gid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tpa++;\n\t}\n\n\tif (pa->e_tag == ACL_MASK)\n\t\tpa++;\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags);\n\tace->whotype = NFS4_ACL_WHO_EVERYONE;\n\tacl->naces++;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)",
            "#define NFS4_ACL_OWNER\t\t0x04",
            "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
          ],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);",
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_INHERITANCE_FLAGS (NFS4_ACE_FILE_INHERIT_ACE \\\n\t\t| NFS4_ACE_DIRECTORY_INHERIT_ACE)\n#define NFS4_ACL_OWNER\t\t0x04\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nstatic void\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct posix_acl_entry *pa, *group_owner_entry;\n\tstruct nfs4_ace *ace;\n\tstruct posix_acl_summary pas;\n\tunsigned short deny;\n\tint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\n\t\tNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\n\n\tBUG_ON(pacl->a_count < 3);\n\tsummarize_posix_acl(pacl, &pas);\n\n\tpa = pacl->a_entries;\n\tace = acl->aces + acl->naces;\n\n\t/* We could deny everything not granted by the owner: */\n\tdeny = ~pas.owner;\n\t/*\n\t * but it is equivalent (and simpler) to deny only what is not\n\t * granted by later entries:\n\t */\n\tdeny &= pas.users | pas.group | pas.groups | pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_OWNER;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\n\tace->whotype = NFS4_ACL_WHO_OWNER;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_USER) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.groups | pas.group | pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_uid = pa->e_uid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_uid = pa->e_uid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* In the case of groups, we apply allow ACEs first, then deny ACEs,\n\t * since a user can be in more than one group.  */\n\n\t/* allow ACEs */\n\n\tgroup_owner_entry = pa;\n\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pas.group, flags);\n\tace->whotype = NFS4_ACL_WHO_GROUP;\n\tace++;\n\tacl->naces++;\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\tace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\n\t\t\t\t\t\t   flags);\n\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\tace->who_gid = pa->e_gid;\n\t\tace++;\n\t\tacl->naces++;\n\t\tpa++;\n\t}\n\n\t/* deny ACEs */\n\n\tpa = group_owner_entry;\n\n\tdeny = ~pas.group & pas.other;\n\tif (deny) {\n\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\tace->flag = eflag;\n\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\tace->whotype = NFS4_ACL_WHO_GROUP;\n\t\tace++;\n\t\tacl->naces++;\n\t}\n\tpa++;\n\n\twhile (pa->e_tag == ACL_GROUP) {\n\t\tdeny = ~(pa->e_perm & pas.mask);\n\t\tdeny &= pas.other;\n\t\tif (deny) {\n\t\t\tace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\n\t\t\tace->access_mask = deny_mask_from_posix(deny, flags);\n\t\t\tace->whotype = NFS4_ACL_WHO_NAMED;\n\t\t\tace->who_gid = pa->e_gid;\n\t\t\tace++;\n\t\t\tacl->naces++;\n\t\t}\n\t\tpa++;\n\t}\n\n\tif (pa->e_tag == ACL_MASK)\n\t\tpa++;\n\tace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\n\tace->flag = eflag;\n\tace->access_mask = mask_from_posix(pa->e_perm, flags);\n\tace->whotype = NFS4_ACL_WHO_EVERYONE;\n\tacl->naces++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nfs4_acl_bytes(size)",
            "GFP_KERNEL"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_acl_bytes",
          "args": [
            "size"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "887-890",
          "snippet": "int nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);",
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dpacl"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dpacl"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "99-123",
          "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\t/*\n\t * A filesystem can force a ACL callback by just never filling the\n\t * ACL cache. But normally you'd fill the cache either at inode\n\t * instantiation time, or on the first ->get_acl call.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\treturn inode->i_op->get_acl(inode, type);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\t/*\n\t * A filesystem can force a ACL callback by just never filling the\n\t * ACL cache. But normally you'd fill the cache either at inode\n\t * instantiation time, or on the first ->get_acl call.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\treturn inode->i_op->get_acl(inode, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pacl"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pacl"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_mode",
          "args": [
            "inode->i_mode",
            "GFP_KERNEL"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "288-304",
          "snippet": "struct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}"
  },
  {
    "function_name": "low_mode_from_nfs4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "113-127",
    "snippet": "static void\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\n{\n\tu32 write_mode = NFS4_WRITE_MODE;\n\n\tif (flags & NFS4_ACL_DIR)\n\t\twrite_mode |= NFS4_ACE_DELETE_CHILD;\n\t*mode = 0;\n\tif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\n\t\t*mode |= ACL_READ;\n\tif ((perm & write_mode) == write_mode)\n\t\t*mode |= ACL_WRITE;\n\tif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\n\t\t*mode |= ACL_EXECUTE;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE",
      "#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)",
      "#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)",
      "#define NFS4_ACL_DIR\t\t0x02"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic void\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\n{\n\tu32 write_mode = NFS4_WRITE_MODE;\n\n\tif (flags & NFS4_ACL_DIR)\n\t\twrite_mode |= NFS4_ACE_DELETE_CHILD;\n\t*mode = 0;\n\tif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\n\t\t*mode |= ACL_READ;\n\tif ((perm & write_mode) == write_mode)\n\t\t*mode |= ACL_WRITE;\n\tif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\n\t\t*mode |= ACL_EXECUTE;\n}"
  },
  {
    "function_name": "deny_mask_from_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "88-102",
    "snippet": "static u32\ndeny_mask_from_posix(unsigned short perm, u32 flags)\n{\n\tu32 mask = 0;\n\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE",
      "#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)",
      "#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)",
      "#define NFS4_ACL_DIR\t\t0x02"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic u32\ndeny_mask_from_posix(unsigned short perm, u32 flags)\n{\n\tu32 mask = 0;\n\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}"
  },
  {
    "function_name": "mask_from_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
    "lines": "70-86",
    "snippet": "static u32\nmask_from_posix(unsigned short perm, unsigned int flags)\n{\n\tint mask = NFS4_ANYONE_MODE;\n\n\tif (flags & NFS4_ACL_OWNER)\n\t\tmask |= NFS4_OWNER_MODE;\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"acl.h\"",
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NFS4_OWNER_MODE (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL)",
      "#define NFS4_ANYONE_MODE (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL | NFS4_ACE_SYNCHRONIZE)",
      "#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE",
      "#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)",
      "#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)",
      "#define NFS4_ACL_OWNER\t\t0x04",
      "#define NFS4_ACL_DIR\t\t0x02"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_OWNER_MODE (NFS4_ACE_WRITE_ATTRIBUTES | NFS4_ACE_WRITE_ACL)\n#define NFS4_ANYONE_MODE (NFS4_ACE_READ_ATTRIBUTES | NFS4_ACE_READ_ACL | NFS4_ACE_SYNCHRONIZE)\n#define NFS4_EXECUTE_MODE NFS4_ACE_EXECUTE\n#define NFS4_WRITE_MODE (NFS4_ACE_WRITE_DATA | NFS4_ACE_APPEND_DATA)\n#define NFS4_READ_MODE (NFS4_ACE_READ_DATA)\n#define NFS4_ACL_OWNER\t\t0x04\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic u32\nmask_from_posix(unsigned short perm, unsigned int flags)\n{\n\tint mask = NFS4_ANYONE_MODE;\n\n\tif (flags & NFS4_ACL_OWNER)\n\t\tmask |= NFS4_OWNER_MODE;\n\tif (perm & ACL_READ)\n\t\tmask |= NFS4_READ_MODE;\n\tif (perm & ACL_WRITE)\n\t\tmask |= NFS4_WRITE_MODE;\n\tif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\n\t\tmask |= NFS4_ACE_DELETE_CHILD;\n\tif (perm & ACL_EXECUTE)\n\t\tmask |= NFS4_EXECUTE_MODE;\n\treturn mask;\n}"
  }
]