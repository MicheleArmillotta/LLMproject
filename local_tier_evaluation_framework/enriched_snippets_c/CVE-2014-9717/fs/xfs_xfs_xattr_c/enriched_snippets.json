[
  {
    "function_name": "xfs_vn_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "195-243",
    "snippet": "ssize_t\nxfs_vn_listxattr(struct dentry *dentry, char *data, size_t size)\n{\n\tstruct xfs_attr_list_context context;\n\tstruct attrlist_cursor_kern cursor = { 0 };\n\tstruct inode\t\t*inode = dentry->d_inode;\n\tint\t\t\terror;\n\n\t/*\n\t * First read the regular on-disk attributes.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = XFS_I(inode);\n\tcontext.cursor = &cursor;\n\tcontext.resynch = 1;\n\tcontext.alist = data;\n\tcontext.bufsize = size;\n\tcontext.firstu = context.bufsize;\n\n\tif (size)\n\t\tcontext.put_listent = xfs_xattr_put_listent;\n\telse\n\t\tcontext.put_listent = xfs_xattr_put_listent_sizes;\n\n\txfs_attr_list_int(&context);\n\tif (context.count < 0)\n\t\treturn -ERANGE;\n\n\t/*\n\t * Then add the two synthetic ACL attributes.\n\t */\n\tif (posix_acl_access_exists(inode)) {\n\t\terror = list_one_attr(POSIX_ACL_XATTR_ACCESS,\n\t\t\t\tstrlen(POSIX_ACL_XATTR_ACCESS) + 1,\n\t\t\t\tdata, size, &context.count);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (posix_acl_default_exists(inode)) {\n\t\terror = list_one_attr(POSIX_ACL_XATTR_DEFAULT,\n\t\t\t\tstrlen(POSIX_ACL_XATTR_DEFAULT) + 1,\n\t\t\t\tdata, size, &context.count);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn context.count;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_one_attr",
          "args": [
            "POSIX_ACL_XATTR_DEFAULT",
            "strlen(POSIX_ACL_XATTR_DEFAULT) + 1",
            "data",
            "size",
            "&context.count"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "list_one_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
          "lines": "179-193",
          "snippet": "static int\nlist_one_attr(const char *name, const size_t len, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tchar *p = data + *result;\n\n\t*result += len;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nlist_one_attr(const char *name, const size_t len, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tchar *p = data + *result;\n\n\t*result += len;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "POSIX_ACL_XATTR_DEFAULT"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_default_exists",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_default_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "266-272",
          "snippet": "int\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_access_exists",
          "args": [
            "inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_access_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "260-264",
          "snippet": "int\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_list_int",
          "args": [
            "&context"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_list_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "503-531",
          "snippet": "int\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context",
            "0",
            "sizeof(context)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nssize_t\nxfs_vn_listxattr(struct dentry *dentry, char *data, size_t size)\n{\n\tstruct xfs_attr_list_context context;\n\tstruct attrlist_cursor_kern cursor = { 0 };\n\tstruct inode\t\t*inode = dentry->d_inode;\n\tint\t\t\terror;\n\n\t/*\n\t * First read the regular on-disk attributes.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = XFS_I(inode);\n\tcontext.cursor = &cursor;\n\tcontext.resynch = 1;\n\tcontext.alist = data;\n\tcontext.bufsize = size;\n\tcontext.firstu = context.bufsize;\n\n\tif (size)\n\t\tcontext.put_listent = xfs_xattr_put_listent;\n\telse\n\t\tcontext.put_listent = xfs_xattr_put_listent_sizes;\n\n\txfs_attr_list_int(&context);\n\tif (context.count < 0)\n\t\treturn -ERANGE;\n\n\t/*\n\t * Then add the two synthetic ACL attributes.\n\t */\n\tif (posix_acl_access_exists(inode)) {\n\t\terror = list_one_attr(POSIX_ACL_XATTR_ACCESS,\n\t\t\t\tstrlen(POSIX_ACL_XATTR_ACCESS) + 1,\n\t\t\t\tdata, size, &context.count);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (posix_acl_default_exists(inode)) {\n\t\terror = list_one_attr(POSIX_ACL_XATTR_DEFAULT,\n\t\t\t\tstrlen(POSIX_ACL_XATTR_DEFAULT) + 1,\n\t\t\t\tdata, size, &context.count);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn context.count;\n}"
  },
  {
    "function_name": "list_one_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "179-193",
    "snippet": "static int\nlist_one_attr(const char *name, const size_t len, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tchar *p = data + *result;\n\n\t*result += len;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "name"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nlist_one_attr(const char *name, const size_t len, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tchar *p = data + *result;\n\n\t*result += len;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_xattr_put_listent_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "166-177",
    "snippet": "static int\nxfs_xattr_put_listent_sizes(\n\tstruct xfs_attr_list_context *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tcontext->count += xfs_xattr_prefix_len(flags) + namelen + 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_xattr_prefix_len",
          "args": [
            "flags"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_xattr_prefix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
          "lines": "109-117",
          "snippet": "static unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_xattr_put_listent_sizes(\n\tstruct xfs_attr_list_context *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tcontext->count += xfs_xattr_prefix_len(flags) + namelen + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_xattr_put_listent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "129-164",
    "snippet": "static int\nxfs_xattr_put_listent(\n\tstruct xfs_attr_list_context *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tunsigned int prefix_len = xfs_xattr_prefix_len(flags);\n\tchar *offset;\n\tint arraytop;\n\n\tASSERT(context->count >= 0);\n\n\t/*\n\t * Only show root namespace entries if we are actually allowed to\n\t * see them.\n\t */\n\tif ((flags & XFS_ATTR_ROOT) && !capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tarraytop = context->count + prefix_len + namelen + 1;\n\tif (arraytop > context->firstu) {\n\t\tcontext->count = -1;\t/* insufficient space */\n\t\treturn 1;\n\t}\n\toffset = (char *)context->alist + context->count;\n\tstrncpy(offset, xfs_xattr_prefix(flags), prefix_len);\n\toffset += prefix_len;\n\tstrncpy(offset, (char *)name, namelen);\t\t\t/* real name */\n\toffset += namelen;\n\t*offset = '\\0';\n\tcontext->count += prefix_len + namelen + 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "offset",
            "(char *)name",
            "namelen"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "offset",
            "xfs_xattr_prefix(flags)",
            "prefix_len"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_xattr_prefix",
          "args": [
            "flags"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_xattr_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
          "lines": "119-127",
          "snippet": "static const char *xfs_xattr_prefix(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn xfs_xattr_security_handler.prefix;\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn xfs_xattr_trusted_handler.prefix;\n\telse\n\t\treturn xfs_xattr_user_handler.prefix;\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler xfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= 0, /* no flags implies user namespace */\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};",
            "static const struct xattr_handler xfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= ATTR_ROOT,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};",
            "static const struct xattr_handler xfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= ATTR_SECURE,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic const struct xattr_handler xfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= 0, /* no flags implies user namespace */\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\nstatic const struct xattr_handler xfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= ATTR_ROOT,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\nstatic const struct xattr_handler xfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= ATTR_SECURE,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\n\nstatic const char *xfs_xattr_prefix(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn xfs_xattr_security_handler.prefix;\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn xfs_xattr_trusted_handler.prefix;\n\telse\n\t\treturn xfs_xattr_user_handler.prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "context->count >= 0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_xattr_prefix_len",
          "args": [
            "flags"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_xattr_prefix_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
          "lines": "109-117",
          "snippet": "static unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_xattr_put_listent(\n\tstruct xfs_attr_list_context *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tunsigned int prefix_len = xfs_xattr_prefix_len(flags);\n\tchar *offset;\n\tint arraytop;\n\n\tASSERT(context->count >= 0);\n\n\t/*\n\t * Only show root namespace entries if we are actually allowed to\n\t * see them.\n\t */\n\tif ((flags & XFS_ATTR_ROOT) && !capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tarraytop = context->count + prefix_len + namelen + 1;\n\tif (arraytop > context->firstu) {\n\t\tcontext->count = -1;\t/* insufficient space */\n\t\treturn 1;\n\t}\n\toffset = (char *)context->alist + context->count;\n\tstrncpy(offset, xfs_xattr_prefix(flags), prefix_len);\n\toffset += prefix_len;\n\tstrncpy(offset, (char *)name, namelen);\t\t\t/* real name */\n\toffset += namelen;\n\t*offset = '\\0';\n\tcontext->count += prefix_len + namelen + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_xattr_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "119-127",
    "snippet": "static const char *xfs_xattr_prefix(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn xfs_xattr_security_handler.prefix;\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn xfs_xattr_trusted_handler.prefix;\n\telse\n\t\treturn xfs_xattr_user_handler.prefix;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler xfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= 0, /* no flags implies user namespace */\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};",
      "static const struct xattr_handler xfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= ATTR_ROOT,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};",
      "static const struct xattr_handler xfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= ATTR_SECURE,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic const struct xattr_handler xfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= 0, /* no flags implies user namespace */\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\nstatic const struct xattr_handler xfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= ATTR_ROOT,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\nstatic const struct xattr_handler xfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= ATTR_SECURE,\n\t.get\t= xfs_xattr_get,\n\t.set\t= xfs_xattr_set,\n};\n\nstatic const char *xfs_xattr_prefix(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn xfs_xattr_security_handler.prefix;\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn xfs_xattr_trusted_handler.prefix;\n\telse\n\t\treturn xfs_xattr_user_handler.prefix;\n}"
  },
  {
    "function_name": "xfs_xattr_prefix_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "109-117",
    "snippet": "static unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int xfs_xattr_prefix_len(int flags)\n{\n\tif (flags & XFS_ATTR_SECURE)\n\t\treturn sizeof(\"security\");\n\telse if (flags & XFS_ATTR_ROOT)\n\t\treturn sizeof(\"trusted\");\n\telse\n\t\treturn sizeof(\"user\");\n}"
  },
  {
    "function_name": "xfs_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "56-75",
    "snippet": "static int\nxfs_xattr_set(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags, int xflags)\n{\n\tstruct xfs_inode *ip = XFS_I(dentry->d_inode);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\t/* Convert Linux syscall to XFS internal ATTR flags */\n\tif (flags & XATTR_CREATE)\n\t\txflags |= ATTR_CREATE;\n\tif (flags & XATTR_REPLACE)\n\t\txflags |= ATTR_REPLACE;\n\n\tif (!value)\n\t\treturn xfs_attr_remove(ip, (unsigned char *)name, xflags);\n\treturn xfs_attr_set(ip, (unsigned char *)name,\n\t\t\t\t(void *)value, size, xflags);\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_set",
          "args": [
            "ip",
            "(unsigned char *)name",
            "(void *)value",
            "size",
            "xflags"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "194-398",
          "snippet": "int\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_remove",
          "args": [
            "ip",
            "(unsigned char *)name",
            "xflags"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "404-516",
          "snippet": "int\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_xattr_set(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags, int xflags)\n{\n\tstruct xfs_inode *ip = XFS_I(dentry->d_inode);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\t/* Convert Linux syscall to XFS internal ATTR flags */\n\tif (flags & XATTR_CREATE)\n\t\txflags |= ATTR_CREATE;\n\tif (flags & XATTR_REPLACE)\n\t\txflags |= ATTR_REPLACE;\n\n\tif (!value)\n\t\treturn xfs_attr_remove(ip, (unsigned char *)name, xflags);\n\treturn xfs_attr_set(ip, (unsigned char *)name,\n\t\t\t\t(void *)value, size, xflags);\n}"
  },
  {
    "function_name": "xfs_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_xattr.c",
    "lines": "34-54",
    "snippet": "static int\nxfs_xattr_get(struct dentry *dentry, const char *name,\n\t\tvoid *value, size_t size, int xflags)\n{\n\tstruct xfs_inode *ip = XFS_I(dentry->d_inode);\n\tint error, asize = size;\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\t/* Convert Linux syscall to XFS internal ATTR flags */\n\tif (!size) {\n\t\txflags |= ATTR_KERNOVAL;\n\t\tvalue = NULL;\n\t}\n\n\terror = xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);\n\tif (error)\n\t\treturn error;\n\treturn asize;\n}",
    "includes": [
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_get",
          "args": [
            "ip",
            "(unsigned char *)name",
            "value",
            "&asize",
            "xflags"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "116-156",
          "snippet": "int\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xfs_acl.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_xattr_get(struct dentry *dentry, const char *name,\n\t\tvoid *value, size_t size, int xflags)\n{\n\tstruct xfs_inode *ip = XFS_I(dentry->d_inode);\n\tint error, asize = size;\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\t/* Convert Linux syscall to XFS internal ATTR flags */\n\tif (!size) {\n\t\txflags |= ATTR_KERNOVAL;\n\t\tvalue = NULL;\n\t}\n\n\terror = xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);\n\tif (error)\n\t\treturn error;\n\treturn asize;\n}"
  }
]