[
  {
    "function_name": "ufs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "607-655",
    "snippet": "int ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "sb",
            "de"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "de->d_ino"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "de"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\"",
            "kaddr",
            "de"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_last_byte",
          "args": [
            "inode",
            "i"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "212-221",
          "snippet": "static unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_page",
          "args": [
            "inode",
            "i"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "190-206",
          "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_dir_pages",
          "args": [
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_make_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "559-602",
    "snippet": "int ufs_make_empty(struct inode * inode, struct inode *dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tstruct ufs_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ufs_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkmap(page);\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct ufs_dir_entry *) base;\n\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\tufs_set_de_namlen(sb, de, 1);\n\tde->d_reclen = cpu_to_fs16(sb, UFS_DIR_REC_LEN(1));\n\tstrcpy (de->d_name, \".\");\n\tde = (struct ufs_dir_entry *)\n\t\t((char *)de + fs16_to_cpu(sb, de->d_reclen));\n\tde->d_ino = cpu_to_fs32(sb, dir->i_ino);\n\tufs_set_de_type(sb, de, dir->i_mode);\n\tde->d_reclen = cpu_to_fs16(sb, chunk_size - UFS_DIR_REC_LEN(1));\n\tufs_set_de_namlen(sb, de, 2);\n\tstrcpy (de->d_name, \"..\");\n\tkunmap(page);\n\n\terr = ufs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_commit_chunk",
          "args": [
            "page",
            "0",
            "chunk_size"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "43-60",
          "snippet": "static int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->d_name",
            "\"..\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_de_namlen",
          "args": [
            "sb",
            "de",
            "2"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "145-152",
          "snippet": "static inline void\nufs_set_de_namlen(struct super_block *sb, struct ufs_dir_entry *de, u16 value)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\tde->d_u.d_namlen = cpu_to_fs16(sb, value);\n\telse\n\t\tde->d_u.d_44.d_namlen = value; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_namlen(struct super_block *sb, struct ufs_dir_entry *de, u16 value)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\tde->d_u.d_namlen = cpu_to_fs16(sb, value);\n\telse\n\t\tde->d_u.d_44.d_namlen = value; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs16",
          "args": [
            "sb",
            "chunk_size - UFS_DIR_REC_LEN(1)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "88-95",
          "snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_de_type",
          "args": [
            "sb",
            "de",
            "dir->i_mode"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "154-188",
          "snippet": "static inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "dir->i_ino"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "de->d_reclen"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->d_name",
            "\".\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "base",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_prepare_chunk",
          "args": [
            "page",
            "0",
            "chunk_size"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "524-527",
          "snippet": "int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_make_empty(struct inode * inode, struct inode *dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tstruct ufs_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ufs_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkmap(page);\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct ufs_dir_entry *) base;\n\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\tufs_set_de_namlen(sb, de, 1);\n\tde->d_reclen = cpu_to_fs16(sb, UFS_DIR_REC_LEN(1));\n\tstrcpy (de->d_name, \".\");\n\tde = (struct ufs_dir_entry *)\n\t\t((char *)de + fs16_to_cpu(sb, de->d_reclen));\n\tde->d_ino = cpu_to_fs32(sb, dir->i_ino);\n\tufs_set_de_type(sb, de, dir->i_mode);\n\tde->d_reclen = cpu_to_fs16(sb, chunk_size - UFS_DIR_REC_LEN(1));\n\tufs_set_de_namlen(sb, de, 2);\n\tstrcpy (de->d_name, \"..\");\n\tkunmap(page);\n\n\terr = ufs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "511-557",
    "snippet": "int ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_commit_chunk",
          "args": [
            "page",
            "pos",
            "to - from"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "43-60",
          "snippet": "static int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs16",
          "args": [
            "sb",
            "to - from"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "88-95",
          "snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_prepare_chunk",
          "args": [
            "page",
            "pos",
            "to - from"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "524-527",
          "snippet": "int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "sb",
            "de"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"zero-length directory entry\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ino %u, reclen %u, namlen %u, name %s\\n\"",
            "fs32_to_cpu(sb, de->d_ino)",
            "fs16_to_cpu(sb, de->d_reclen)",
            "ufs_get_de_namlen(sb, de)",
            "de->d_name"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "de"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "de->d_reclen"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "de->d_ino"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "432-504",
    "snippet": "static int\nufs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int offset = pos & ~PAGE_CACHE_MASK;\n\tunsigned long n = pos >> PAGE_CACHE_SHIFT;\n\tunsigned long npages = ufs_dir_pages(inode);\n\tunsigned chunk_mask = ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tint need_revalidate = file->f_version != inode->i_version;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\n\tUFSD(\"BEGIN\\n\");\n\n\tif (pos > inode->i_size - UFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct ufs_dir_entry *de;\n\n\t\tstruct page *page = ufs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tufs_error(sb, __func__,\n\t\t\t\t  \"bad page in #%lu\",\n\t\t\t\t  inode->i_ino);\n\t\t\tctx->pos += PAGE_CACHE_SIZE - offset;\n\t\t\treturn -EIO;\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = ufs_validate_entry(sb, kaddr, offset, chunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_CACHE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tneed_revalidate = 0;\n\t\t}\n\t\tde = (struct ufs_dir_entry *)(kaddr+offset);\n\t\tlimit = kaddr + ufs_last_byte(inode, n) - UFS_DIR_REC_LEN(1);\n\t\tfor ( ;(char*)de <= limit; de = ufs_next_entry(sb, de)) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tufs_put_page(page);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tUFSD(\"filldir(%s,%u)\\n\", de->d_name,\n\t\t\t\t      fs32_to_cpu(sb, de->d_ino));\n\t\t\t\tUFSD(\"namlen %u\\n\", ufs_get_de_namlen(sb, de));\n\n\t\t\t\tif ((flags & UFS_DE_MASK) == UFS_DE_44BSD)\n\t\t\t\t\td_type = de->d_u.d_44.d_type;\n\n\t\t\t\tif (!dir_emit(ctx, de->d_name,\n\t\t\t\t\t       ufs_get_de_namlen(sb, de),\n\t\t\t\t\t       fs32_to_cpu(sb, de->d_ino),\n\t\t\t\t\t       d_type)) {\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += fs16_to_cpu(sb, de->d_reclen);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "de->d_reclen"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->d_name",
            "ufs_get_de_namlen(sb, de)",
            "fs32_to_cpu(sb, de->d_ino)",
            "d_type"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "de->d_ino"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "de"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"namlen %u\\n\"",
            "ufs_get_de_namlen(sb, de)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"filldir(%s,%u)\\n\"",
            "de->d_name",
            "fs32_to_cpu(sb, de->d_ino)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "__func__",
            "\"zero-length directory entry\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "sb",
            "de"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_last_byte",
          "args": [
            "inode",
            "n"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "212-221",
          "snippet": "static unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_validate_entry",
          "args": [
            "sb",
            "kaddr",
            "offset",
            "chunk_mask"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_validate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "414-426",
          "snippet": "static inline unsigned\nufs_validate_entry(struct super_block *sb, char *base,\n\t\t   unsigned offset, unsigned mask)\n{\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry*)(base + offset);\n\tstruct ufs_dir_entry *p = (struct ufs_dir_entry*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de) {\n\t\tif (p->d_reclen == 0)\n\t\t\tbreak;\n\t\tp = ufs_next_entry(sb, p);\n\t}\n\treturn (char *)p - base;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned\nufs_validate_entry(struct super_block *sb, char *base,\n\t\t   unsigned offset, unsigned mask)\n{\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry*)(base + offset);\n\tstruct ufs_dir_entry *p = (struct ufs_dir_entry*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de) {\n\t\tif (p->d_reclen == 0)\n\t\t\tbreak;\n\t\tp = ufs_next_entry(sb, p);\n\t}\n\treturn (char *)p - base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "need_revalidate"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_page",
          "args": [
            "inode",
            "n"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "190-206",
          "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"BEGIN\\n\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dir_pages",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int\nufs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int offset = pos & ~PAGE_CACHE_MASK;\n\tunsigned long n = pos >> PAGE_CACHE_SHIFT;\n\tunsigned long npages = ufs_dir_pages(inode);\n\tunsigned chunk_mask = ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tint need_revalidate = file->f_version != inode->i_version;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\n\tUFSD(\"BEGIN\\n\");\n\n\tif (pos > inode->i_size - UFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct ufs_dir_entry *de;\n\n\t\tstruct page *page = ufs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tufs_error(sb, __func__,\n\t\t\t\t  \"bad page in #%lu\",\n\t\t\t\t  inode->i_ino);\n\t\t\tctx->pos += PAGE_CACHE_SIZE - offset;\n\t\t\treturn -EIO;\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = ufs_validate_entry(sb, kaddr, offset, chunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_CACHE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tneed_revalidate = 0;\n\t\t}\n\t\tde = (struct ufs_dir_entry *)(kaddr+offset);\n\t\tlimit = kaddr + ufs_last_byte(inode, n) - UFS_DIR_REC_LEN(1);\n\t\tfor ( ;(char*)de <= limit; de = ufs_next_entry(sb, de)) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tufs_put_page(page);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tunsigned char d_type = DT_UNKNOWN;\n\n\t\t\t\tUFSD(\"filldir(%s,%u)\\n\", de->d_name,\n\t\t\t\t      fs32_to_cpu(sb, de->d_ino));\n\t\t\t\tUFSD(\"namlen %u\\n\", ufs_get_de_namlen(sb, de));\n\n\t\t\t\tif ((flags & UFS_DE_MASK) == UFS_DE_44BSD)\n\t\t\t\t\td_type = de->d_u.d_44.d_type;\n\n\t\t\t\tif (!dir_emit(ctx, de->d_name,\n\t\t\t\t\t       ufs_get_de_namlen(sb, de),\n\t\t\t\t\t       fs32_to_cpu(sb, de->d_ino),\n\t\t\t\t\t       d_type)) {\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += fs16_to_cpu(sb, de->d_reclen);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_validate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "414-426",
    "snippet": "static inline unsigned\nufs_validate_entry(struct super_block *sb, char *base,\n\t\t   unsigned offset, unsigned mask)\n{\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry*)(base + offset);\n\tstruct ufs_dir_entry *p = (struct ufs_dir_entry*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de) {\n\t\tif (p->d_reclen == 0)\n\t\t\tbreak;\n\t\tp = ufs_next_entry(sb, p);\n\t}\n\treturn (char *)p - base;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "sb",
            "p"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned\nufs_validate_entry(struct super_block *sb, char *base,\n\t\t   unsigned offset, unsigned mask)\n{\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry*)(base + offset);\n\tstruct ufs_dir_entry *p = (struct ufs_dir_entry*)(base + (offset&mask));\n\twhile ((char*)p < (char*)de) {\n\t\tif (p->d_reclen == 0)\n\t\t\tbreak;\n\t\tp = ufs_next_entry(sb, p);\n\t}\n\treturn (char *)p - base;\n}"
  },
  {
    "function_name": "ufs_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "312-412",
    "snippet": "int ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_commit_chunk",
          "args": [
            "page",
            "pos",
            "rec_len"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "43-60",
          "snippet": "static int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_de_type",
          "args": [
            "sb",
            "de",
            "inode->i_mode"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "154-188",
          "snippet": "static inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->d_name",
            "name",
            "namelen + 1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_de_namlen",
          "args": [
            "sb",
            "de",
            "namelen"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "145-152",
          "snippet": "static inline void\nufs_set_de_namlen(struct super_block *sb, struct ufs_dir_entry *de, u16 value)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\tde->d_u.d_namlen = cpu_to_fs16(sb, value);\n\telse\n\t\tde->d_u.d_44.d_namlen = value; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_namlen(struct super_block *sb, struct ufs_dir_entry *de, u16 value)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\tde->d_u.d_namlen = cpu_to_fs16(sb, value);\n\telse\n\t\tde->d_u.d_44.d_namlen = value; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs16",
          "args": [
            "sb",
            "name_len"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "88-95",
          "snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_prepare_chunk",
          "args": [
            "page",
            "pos",
            "rec_len"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "524-527",
          "snippet": "int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "de->d_reclen"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "ufs_get_de_namlen(sb, de)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "de"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_match",
          "args": [
            "sb",
            "namelen",
            "name",
            "de"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "33-41",
          "snippet": "static inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"zero-length directory entry\""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "212-221",
          "snippet": "static unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "190-206",
          "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, name %s, namelen %u\\n\"",
            "name",
            "namelen"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dir_pages",
          "args": [
            "dir"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
  },
  {
    "function_name": "ufs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "251-307",
    "snippet": "struct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "sb",
            "de"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_match",
          "args": [
            "sb",
            "namelen",
            "name",
            "de"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "33-41",
          "snippet": "static inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"zero-length directory entry\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "212-221",
          "snippet": "static unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "190-206",
          "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, dir_ino %lu, name %s, namlen %u\\n\"",
            "dir->i_ino",
            "name",
            "namelen"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "dir"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dir_pages",
          "args": [
            "dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "68-71",
          "snippet": "static inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}"
  },
  {
    "function_name": "ufs_dotdot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "230-241",
    "snippet": "struct ufs_dir_entry *ufs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = ufs_get_page(dir, 0);\n\tstruct ufs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ufs_next_entry(dir->i_sb,\n\t\t\t\t    (struct ufs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_next_entry",
          "args": [
            "dir->i_sb",
            "(struct ufs_dir_entry *)page_address(page)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "223-228",
          "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_page",
          "args": [
            "dir",
            "0"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "190-206",
          "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = ufs_get_page(dir, 0);\n\tstruct ufs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ufs_next_entry(dir->i_sb,\n\t\t\t\t    (struct ufs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}"
  },
  {
    "function_name": "ufs_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "223-228",
    "snippet": "static inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "p->d_reclen"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline struct ufs_dir_entry *\nufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)\n{\n\treturn (struct ufs_dir_entry *)((char *)p +\n\t\t\t\t\tfs16_to_cpu(sb, p->d_reclen));\n}"
  },
  {
    "function_name": "ufs_last_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "212-221",
    "snippet": "static unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic unsigned\nufs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
  },
  {
    "function_name": "ufs_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "190-206",
    "snippet": "static struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_check_page",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "111-188",
          "snippet": "static void ufs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tconst unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;\n\tstruct ufs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & chunk_mask)\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - UFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\t\trec_len = fs16_to_cpu(sb, p->d_reclen);\n\n\t\tif (rec_len < UFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, p)))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~chunk_mask)\n\t\t\tgoto Espan;\n\t\tif (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *\n\t\t\t\t\t\t  UFS_SB(sb)->s_uspi->s_ncg))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\n\t/* Too bad, we had an error */\n\nEbadsize:\n\tufs_error(sb, \"ufs_check_page\",\n\t\t  \"size of directory #%lu is not a multiple of chunk size\",\n\t\t  dir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tufs_error (sb, \"ufs_check_page\", \"bad entry in directory #%lu: %s - \"\n\t\t   \"offset=%lu, rec_len=%d, name_len=%d\",\n\t\t   dir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t   rec_len, ufs_get_de_namlen(sb, p));\n\tgoto fail;\nEend:\n\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\tufs_error(sb, __func__,\n\t\t   \"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\",\n\t\t   dir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs);\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void ufs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tconst unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;\n\tstruct ufs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & chunk_mask)\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - UFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\t\trec_len = fs16_to_cpu(sb, p->d_reclen);\n\n\t\tif (rec_len < UFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, p)))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~chunk_mask)\n\t\t\tgoto Espan;\n\t\tif (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *\n\t\t\t\t\t\t  UFS_SB(sb)->s_uspi->s_ncg))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\n\t/* Too bad, we had an error */\n\nEbadsize:\n\tufs_error(sb, \"ufs_check_page\",\n\t\t  \"size of directory #%lu is not a multiple of chunk size\",\n\t\t  dir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tufs_error (sb, \"ufs_check_page\", \"bad entry in directory #%lu: %s - \"\n\t\t   \"offset=%lu, rec_len=%d, name_len=%d\",\n\t\t   dir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t   rec_len, ufs_get_de_namlen(sb, p));\n\tgoto fail;\nEend:\n\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\tufs_error(sb, __func__,\n\t\t   \"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\",\n\t\t   dir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs);\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct page *ufs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tufs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tufs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "ufs_check_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "111-188",
    "snippet": "static void ufs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tconst unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;\n\tstruct ufs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & chunk_mask)\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - UFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\t\trec_len = fs16_to_cpu(sb, p->d_reclen);\n\n\t\tif (rec_len < UFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, p)))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~chunk_mask)\n\t\t\tgoto Espan;\n\t\tif (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *\n\t\t\t\t\t\t  UFS_SB(sb)->s_uspi->s_ncg))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\n\t/* Too bad, we had an error */\n\nEbadsize:\n\tufs_error(sb, \"ufs_check_page\",\n\t\t  \"size of directory #%lu is not a multiple of chunk size\",\n\t\t  dir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tufs_error (sb, \"ufs_check_page\", \"bad entry in directory #%lu: %s - \"\n\t\t   \"offset=%lu, rec_len=%d, name_len=%d\",\n\t\t   dir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t   rec_len, ufs_get_de_namlen(sb, p));\n\tgoto fail;\nEend:\n\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\tufs_error(sb, __func__,\n\t\t   \"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\",\n\t\t   dir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs);\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "__func__",
            "\"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\"",
            "dir->i_ino",
            "(page->index<<PAGE_CACHE_SHIFT)+offs"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "p"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "p->d_ino"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "ufs_get_de_namlen(sb, p)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "p->d_reclen"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void ufs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tconst unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;\n\tstruct ufs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & chunk_mask)\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - UFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\t\trec_len = fs16_to_cpu(sb, p->d_reclen);\n\n\t\tif (rec_len < UFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, p)))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~chunk_mask)\n\t\t\tgoto Espan;\n\t\tif (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *\n\t\t\t\t\t\t  UFS_SB(sb)->s_uspi->s_ncg))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\n\t/* Too bad, we had an error */\n\nEbadsize:\n\tufs_error(sb, \"ufs_check_page\",\n\t\t  \"size of directory #%lu is not a multiple of chunk size\",\n\t\t  dir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"inode out of bounds\";\nbad_entry:\n\tufs_error (sb, \"ufs_check_page\", \"bad entry in directory #%lu: %s - \"\n\t\t   \"offset=%lu, rec_len=%d, name_len=%d\",\n\t\t   dir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t   rec_len, ufs_get_de_namlen(sb, p));\n\tgoto fail;\nEend:\n\tp = (struct ufs_dir_entry *)(kaddr + offs);\n\tufs_error(sb, __func__,\n\t\t   \"entry in directory #%lu spans the page boundary\"\n\t\t   \"offset=%lu\",\n\t\t   dir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs);\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
  },
  {
    "function_name": "ufs_set_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "89-108",
    "snippet": "void ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,\n\t\t  struct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = fs16_to_cpu(dir->i_sb, de->d_reclen);\n\tint err;\n\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\n\tde->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);\n\tufs_set_de_type(dir->i_sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, len);\n\tufs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_commit_chunk",
          "args": [
            "page",
            "pos",
            "len"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "43-60",
          "snippet": "static int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_de_type",
          "args": [
            "dir->i_sb",
            "de",
            "inode->i_mode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "154-188",
          "snippet": "static inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "dir->i_sb",
            "inode->i_ino"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_prepare_chunk",
          "args": [
            "page",
            "pos",
            "len"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "524-527",
          "snippet": "int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "dir->i_sb",
            "de->d_reclen"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,\n\t\t  struct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = fs16_to_cpu(dir->i_sb, de->d_reclen);\n\tint err;\n\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\n\tde->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);\n\tufs_set_de_type(dir->i_sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, len);\n\tufs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}"
  },
  {
    "function_name": "ufs_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "73-85",
    "snippet": "ino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_put_page",
          "args": [
            "page"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "62-66",
          "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "dir->i_sb",
            "de->d_ino"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_find_entry",
          "args": [
            "dir",
            "qstr",
            "&page"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "251-307",
          "snippet": "struct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "ufs_dir_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "68-71",
    "snippet": "static inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline unsigned long ufs_dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
  },
  {
    "function_name": "ufs_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "62-66",
    "snippet": "static inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void ufs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "ufs_commit_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "43-60",
    "snippet": "static int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_page",
          "args": [
            "page",
            "1"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "pos+len"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "NULL",
            "mapping",
            "pos",
            "len",
            "len",
            "page",
            "NULL"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
    "lines": "33-41",
    "snippet": "static inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->d_name",
            "len"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_de_namlen",
          "args": [
            "sb",
            "de"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_de_namlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "136-143",
          "snippet": "static inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u16\nufs_get_de_namlen(struct super_block *sb, struct ufs_dir_entry *de)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) == UFS_DE_OLD)\n\t\treturn fs16_to_cpu(sb, de->d_u.d_namlen);\n\telse\n\t\treturn de->d_u.d_44.d_namlen; /* XXX this seems wrong */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_match(struct super_block *sb, int len,\n\t\tconst unsigned char *name, struct ufs_dir_entry *de)\n{\n\tif (len != ufs_get_de_namlen(sb, de))\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}"
  }
]