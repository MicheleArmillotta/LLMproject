[
  {
    "function_name": "exit_befs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "967-973",
    "snippet": "static void __exit\nexit_befs_fs(void)\n{\n\tbefs_destroy_inodecache();\n\n\tunregister_filesystem(&befs_fs_type);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inodecache(void);",
      "static struct file_system_type befs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"befs\",\n\t.mount\t\t= befs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\t\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&befs_fs_type"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_destroy_inodecache",
          "args": [],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "befs_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "455-464",
          "snippet": "static void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void befs_destroy_inodecache(void);",
            "static struct kmem_cache *befs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inodecache(void);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inodecache(void);\nstatic struct file_system_type befs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"befs\",\n\t.mount\t\t= befs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\t\n};\n\nstatic void __exit\nexit_befs_fs(void)\n{\n\tbefs_destroy_inodecache();\n\n\tunregister_filesystem(&befs_fs_type);\n}"
  },
  {
    "function_name": "init_befs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "943-965",
    "snippet": "static int __init\ninit_befs_fs(void)\n{\n\tint err;\n\n\tpr_info(\"version: %s\\n\", BEFS_VERSION);\n\n\terr = befs_init_inodecache();\n\tif (err)\n\t\tgoto unacquire_none;\n\n\terr = register_filesystem(&befs_fs_type);\n\tif (err)\n\t\tgoto unacquire_inodecache;\n\n\treturn 0;\n\nunacquire_inodecache:\n\tbefs_destroy_inodecache();\n\nunacquire_none:\n\treturn err;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inodecache(void);",
      "static struct file_system_type befs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"befs\",\n\t.mount\t\t= befs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\t\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_destroy_inodecache",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "befs_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "455-464",
          "snippet": "static void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void befs_destroy_inodecache(void);",
            "static struct kmem_cache *befs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inodecache(void);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&befs_fs_type"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_init_inodecache",
          "args": [],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "befs_init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "436-449",
          "snippet": "static int __init\nbefs_init_inodecache(void)\n{\n\tbefs_inode_cachep = kmem_cache_create(\"befs_inode_cache\",\n\t\t\t\t\t      sizeof (struct befs_inode_info),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (befs_inode_cachep == NULL) {\n\t\tpr_err(\"%s: Couldn't initialize inode slabcache\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void befs_destroy_inode(struct inode *inode);",
            "static struct kmem_cache *befs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic int __init\nbefs_init_inodecache(void)\n{\n\tbefs_inode_cachep = kmem_cache_create(\"befs_inode_cache\",\n\t\t\t\t\t      sizeof (struct befs_inode_info),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (befs_inode_cachep == NULL) {\n\t\tpr_err(\"%s: Couldn't initialize inode slabcache\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"version: %s\\n\"",
            "BEFS_VERSION"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inodecache(void);\nstatic struct file_system_type befs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"befs\",\n\t.mount\t\t= befs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\t\n};\n\nstatic int __init\ninit_befs_fs(void)\n{\n\tint err;\n\n\tpr_info(\"version: %s\\n\", BEFS_VERSION);\n\n\terr = befs_init_inodecache();\n\tif (err)\n\t\tgoto unacquire_none;\n\n\terr = register_filesystem(&befs_fs_type);\n\tif (err)\n\t\tgoto unacquire_inodecache;\n\n\treturn 0;\n\nunacquire_inodecache:\n\tbefs_destroy_inodecache();\n\nunacquire_none:\n\treturn err;\n}"
  },
  {
    "function_name": "befs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "927-932",
    "snippet": "static struct dentry *\nbefs_mount(struct file_system_type *fs_type, int flags, const char *dev_name,\n\t    void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, befs_fill_super);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "befs_fill_super"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic struct dentry *\nbefs_mount(struct file_system_type *fs_type, int flags, const char *dev_name,\n\t    void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, befs_fill_super);\n}"
  },
  {
    "function_name": "befs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "903-925",
    "snippet": "static int\nbefs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tbuf->f_type = BEFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = BEFS_SB(sb)->num_blocks;\n\tbuf->f_bfree = BEFS_SB(sb)->num_blocks - BEFS_SB(sb)->used_blocks;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0;\t/* UNKNOWN */\n\tbuf->f_ffree = 0;\t/* UNKNOWN */\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = BEFS_NAME_LEN;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);",
      "static int befs_statfs(struct dentry *, struct kstatfs *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s\"",
            "__func__"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic int befs_statfs(struct dentry *, struct kstatfs *);\n\nstatic int\nbefs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tbuf->f_type = BEFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = BEFS_SB(sb)->num_blocks;\n\tbuf->f_bfree = BEFS_SB(sb)->num_blocks - BEFS_SB(sb)->used_blocks;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0;\t/* UNKNOWN */\n\tbuf->f_ffree = 0;\t/* UNKNOWN */\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = BEFS_NAME_LEN;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "befs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "894-901",
    "snippet": "static int\nbefs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "befs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "768-892",
    "snippet": "static int\nbefs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tbefs_sb_info *befs_sb;\n\tbefs_super_block *disk_sb;\n\tstruct inode *root;\n\tlong ret = -EINVAL;\n\tconst unsigned long sb_block = 0;\n\tconst off_t x86_sb_off = 512;\n\n\tsave_mount_options(sb, data);\n\n\tsb->s_fs_info = kzalloc(sizeof(*befs_sb), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL) {\n\t\tpr_err(\"(%s): Unable to allocate memory for private \"\n\t\t       \"portion of superblock. Bailing.\\n\", sb->s_id);\n\t\tgoto unacquire_none;\n\t}\n\tbefs_sb = BEFS_SB(sb);\n\n\tif (!parse_options((char *) data, &befs_sb->mount_opts)) {\n\t\tbefs_error(sb, \"cannot parse mount options\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tbefs_warning(sb,\n\t\t\t     \"No write support. Marking filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/*\n\t * Set dummy blocksize to read super block.\n\t * Will be set to real fs blocksize later.\n\t *\n\t * Linux 2.4.10 and later refuse to read blocks smaller than\n\t * the hardsect size for the device. But we also need to read at \n\t * least 1k to get the second 512 bytes of the volume.\n\t * -WD 10-26-01\n\t */ \n\tsb_min_blocksize(sb, 1024);\n\n\tif (!(bh = sb_bread(sb, sb_block))) {\n\t\tbefs_error(sb, \"unable to read superblock\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/* account for offset of super block on x86 */\n\tdisk_sb = (befs_super_block *) bh->b_data;\n\tif ((disk_sb->magic1 == BEFS_SUPER_MAGIC1_LE) ||\n\t    (disk_sb->magic1 == BEFS_SUPER_MAGIC1_BE)) {\n\t\tbefs_debug(sb, \"Using PPC superblock location\");\n\t} else {\n\t\tbefs_debug(sb, \"Using x86 superblock location\");\n\t\tdisk_sb =\n\t\t    (befs_super_block *) ((void *) bh->b_data + x86_sb_off);\n\t}\n\n\tif ((befs_load_sb(sb, disk_sb) != BEFS_OK) ||\n\t    (befs_check_sb(sb) != BEFS_OK))\n\t\tgoto unacquire_bh;\n\n\tbefs_dump_super_block(sb, disk_sb);\n\n\tbrelse(bh);\n\n\tif( befs_sb->num_blocks > ~((sector_t)0) ) {\n\t\tbefs_error(sb, \"blocks count: %llu \"\n\t\t\t\"is larger than the host can use\",\n\t\t\tbefs_sb->num_blocks);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/*\n\t * set up enough so that it can read an inode\n\t * Fill in kernel superblock fields from private sb\n\t */\n\tsb->s_magic = BEFS_SUPER_MAGIC;\n\t/* Set real blocksize of fs */\n\tsb_set_blocksize(sb, (ulong) befs_sb->block_size);\n\tsb->s_op = &befs_sops;\n\troot = befs_iget(sb, iaddr2blockno(sb, &(befs_sb->root_dir)));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tbefs_error(sb, \"get root inode failed\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/* load nls library */\n\tif (befs_sb->mount_opts.iocharset) {\n\t\tbefs_debug(sb, \"Loading nls: %s\",\n\t\t\t   befs_sb->mount_opts.iocharset);\n\t\tbefs_sb->nls = load_nls(befs_sb->mount_opts.iocharset);\n\t\tif (!befs_sb->nls) {\n\t\t\tbefs_warning(sb, \"Cannot load nls %s\"\n\t\t\t\t\t\" loading default nls\",\n\t\t\t\t\tbefs_sb->mount_opts.iocharset);\n\t\t\tbefs_sb->nls = load_nls_default();\n\t\t}\n\t/* load default nls if none is specified  in mount options */\n\t} else {\n\t\tbefs_debug(sb, \"Loading default nls\");\n\t\tbefs_sb->nls = load_nls_default();\n\t}\n\n\treturn 0;\n/*****************/\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_priv_sbp:\n\tkfree(befs_sb->mount_opts.iocharset);\n\tkfree(sb->s_fs_info);\n\n      unacquire_none:\n\tsb->s_fs_info = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);",
      "static sector_t befs_bmap(struct address_space *mapping, sector_t block);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);",
      "static const struct super_operations befs_sops = {\n\t.alloc_inode\t= befs_alloc_inode,\t/* allocate a new inode */\n\t.destroy_inode\t= befs_destroy_inode, /* deallocate an inode */\n\t.put_super\t= befs_put_super,\t/* uninit super */\n\t.statfs\t\t= befs_statfs,\t/* statfs */\n\t.remount_fs\t= befs_remount,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "befs_sb->mount_opts.iocharset"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"Loading default nls\""
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_warning",
          "args": [
            "sb",
            "\"Cannot load nls %s\"\n\t\t\t\t\t\" loading default nls\"",
            "befs_sb->mount_opts.iocharset"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_nls",
          "args": [
            "befs_sb->mount_opts.iocharset"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"get root inode failed\""
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_iget",
          "args": [
            "sb",
            "iaddr2blockno(sb, &(befs_sb->root_dir))"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "befs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "303-430",
          "snippet": "static struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VFS_BLOCK_SIZE 512"
          ],
          "globals_used": [
            "static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);",
            "static int befs_readpage(struct file *file, struct page *page);",
            "static sector_t befs_bmap(struct address_space *mapping, sector_t block);",
            "static struct inode *befs_iget(struct super_block *, unsigned long);",
            "static struct inode *befs_alloc_inode(struct super_block *sb);",
            "static void befs_destroy_inode(struct inode *inode);",
            "static void befs_put_super(struct super_block *);",
            "static int befs_remount(struct super_block *, int *, char *);",
            "static const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
            "static const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};",
            "static const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};",
            "static const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};",
            "static const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define VFS_BLOCK_SIZE 512\n\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic int befs_readpage(struct file *file, struct page *page);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};\nstatic const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};\nstatic const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};\nstatic const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};\n\nstatic struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iaddr2blockno",
          "args": [
            "sb",
            "&(befs_sb->root_dir)"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "iaddr2blockno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "120-125",
          "snippet": "static inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "(ulong) befs_sb->block_size"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_dump_super_block",
          "args": [
            "sb",
            "disk_sb"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "befs_dump_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "153-199",
          "snippet": "void\nbefs_dump_super_block(const struct super_block *sb, befs_super_block * sup)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_super_block information\");\n\n\tbefs_debug(sb, \"  name %s\", sup->name);\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, sup->magic1));\n\tbefs_debug(sb, \"  fs_byte_order %08x\",\n\t\t   fs32_to_cpu(sb, sup->fs_byte_order));\n\n\tbefs_debug(sb, \"  block_size %u\", fs32_to_cpu(sb, sup->block_size));\n\tbefs_debug(sb, \"  block_shift %u\", fs32_to_cpu(sb, sup->block_shift));\n\n\tbefs_debug(sb, \"  num_blocks %llu\", fs64_to_cpu(sb, sup->num_blocks));\n\tbefs_debug(sb, \"  used_blocks %llu\", fs64_to_cpu(sb, sup->used_blocks));\n\n\tbefs_debug(sb, \"  magic2 %08x\", fs32_to_cpu(sb, sup->magic2));\n\tbefs_debug(sb, \"  blocks_per_ag %u\",\n\t\t   fs32_to_cpu(sb, sup->blocks_per_ag));\n\tbefs_debug(sb, \"  ag_shift %u\", fs32_to_cpu(sb, sup->ag_shift));\n\tbefs_debug(sb, \"  num_ags %u\", fs32_to_cpu(sb, sup->num_ags));\n\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, sup->flags));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->log_blocks);\n\tbefs_debug(sb, \"  log_blocks %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  log_start %lld\", fs64_to_cpu(sb, sup->log_start));\n\tbefs_debug(sb, \"  log_end %lld\", fs64_to_cpu(sb, sup->log_end));\n\n\tbefs_debug(sb, \"  magic3 %08x\", fs32_to_cpu(sb, sup->magic3));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->root_dir);\n\tbefs_debug(sb, \"  root_dir %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, sup->indices);\n\tbefs_debug(sb, \"  indices %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_dump_super_block(const struct super_block *sb, befs_super_block * sup)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_super_block information\");\n\n\tbefs_debug(sb, \"  name %s\", sup->name);\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, sup->magic1));\n\tbefs_debug(sb, \"  fs_byte_order %08x\",\n\t\t   fs32_to_cpu(sb, sup->fs_byte_order));\n\n\tbefs_debug(sb, \"  block_size %u\", fs32_to_cpu(sb, sup->block_size));\n\tbefs_debug(sb, \"  block_shift %u\", fs32_to_cpu(sb, sup->block_shift));\n\n\tbefs_debug(sb, \"  num_blocks %llu\", fs64_to_cpu(sb, sup->num_blocks));\n\tbefs_debug(sb, \"  used_blocks %llu\", fs64_to_cpu(sb, sup->used_blocks));\n\n\tbefs_debug(sb, \"  magic2 %08x\", fs32_to_cpu(sb, sup->magic2));\n\tbefs_debug(sb, \"  blocks_per_ag %u\",\n\t\t   fs32_to_cpu(sb, sup->blocks_per_ag));\n\tbefs_debug(sb, \"  ag_shift %u\", fs32_to_cpu(sb, sup->ag_shift));\n\tbefs_debug(sb, \"  num_ags %u\", fs32_to_cpu(sb, sup->num_ags));\n\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, sup->flags));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->log_blocks);\n\tbefs_debug(sb, \"  log_blocks %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  log_start %lld\", fs64_to_cpu(sb, sup->log_start));\n\tbefs_debug(sb, \"  log_end %lld\", fs64_to_cpu(sb, sup->log_end));\n\n\tbefs_debug(sb, \"  magic3 %08x\", fs32_to_cpu(sb, sup->magic3));\n\n\ttmp_run = fsrun_to_cpu(sb, sup->root_dir);\n\tbefs_debug(sb, \"  root_dir %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, sup->indices);\n\tbefs_debug(sb, \"  indices %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_check_sb",
          "args": [
            "sb"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "befs_check_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/super.c",
          "lines": "59-112",
          "snippet": "int\nbefs_check_sb(struct super_block *sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check magic headers of super block */\n\tif ((befs_sb->magic1 != BEFS_SUPER_MAGIC1)\n\t    || (befs_sb->magic2 != BEFS_SUPER_MAGIC2)\n\t    || (befs_sb->magic3 != BEFS_SUPER_MAGIC3)) {\n\t\tbefs_error(sb, \"invalid magic header\");\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t * Check blocksize of BEFS.\n\t *\n\t * Blocksize of BEFS is 1024, 2048, 4096 or 8192.\n\t */\n\n\tif ((befs_sb->block_size != 1024)\n\t    && (befs_sb->block_size != 2048)\n\t    && (befs_sb->block_size != 4096)\n\t    && (befs_sb->block_size != 8192)) {\n\t\tbefs_error(sb, \"invalid blocksize: %u\", befs_sb->block_size);\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->block_size > PAGE_SIZE) {\n\t\tbefs_error(sb, \"blocksize(%u) cannot be larger\"\n\t\t\t   \"than system pagesize(%lu)\", befs_sb->block_size,\n\t\t\t   PAGE_SIZE);\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t   * block_shift and block_size encode the same information\n\t   * in different ways as a consistency check.\n\t */\n\n\tif ((1 << befs_sb->block_shift) != befs_sb->block_size) {\n\t\tbefs_error(sb, \"block_shift disagrees with block_size. \"\n\t\t\t   \"Corruption likely.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->log_start != befs_sb->log_end) {\n\t\tbefs_error(sb, \"Filesystem not clean! There are blocks in the \"\n\t\t\t   \"journal. You must boot into BeOS and mount this volume \"\n\t\t\t   \"to make it clean.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\treturn BEFS_OK;\n}",
          "includes": [
            "#include \"super.h\"",
            "#include \"befs.h\"",
            "#include <asm/page.h> /* for PAGE_SIZE */",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include \"befs.h\"\n#include <asm/page.h> /* for PAGE_SIZE */\n#include <linux/fs.h>\n\nint\nbefs_check_sb(struct super_block *sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check magic headers of super block */\n\tif ((befs_sb->magic1 != BEFS_SUPER_MAGIC1)\n\t    || (befs_sb->magic2 != BEFS_SUPER_MAGIC2)\n\t    || (befs_sb->magic3 != BEFS_SUPER_MAGIC3)) {\n\t\tbefs_error(sb, \"invalid magic header\");\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t * Check blocksize of BEFS.\n\t *\n\t * Blocksize of BEFS is 1024, 2048, 4096 or 8192.\n\t */\n\n\tif ((befs_sb->block_size != 1024)\n\t    && (befs_sb->block_size != 2048)\n\t    && (befs_sb->block_size != 4096)\n\t    && (befs_sb->block_size != 8192)) {\n\t\tbefs_error(sb, \"invalid blocksize: %u\", befs_sb->block_size);\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->block_size > PAGE_SIZE) {\n\t\tbefs_error(sb, \"blocksize(%u) cannot be larger\"\n\t\t\t   \"than system pagesize(%lu)\", befs_sb->block_size,\n\t\t\t   PAGE_SIZE);\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t   * block_shift and block_size encode the same information\n\t   * in different ways as a consistency check.\n\t */\n\n\tif ((1 << befs_sb->block_shift) != befs_sb->block_size) {\n\t\tbefs_error(sb, \"block_shift disagrees with block_size. \"\n\t\t\t   \"Corruption likely.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->log_start != befs_sb->log_end) {\n\t\tbefs_error(sb, \"Filesystem not clean! There are blocks in the \"\n\t\t\t   \"journal. You must boot into BeOS and mount this volume \"\n\t\t\t   \"to make it clean.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\treturn BEFS_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_load_sb",
          "args": [
            "sb",
            "disk_sb"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "befs_load_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/super.c",
          "lines": "24-57",
          "snippet": "int\nbefs_load_sb(struct super_block *sb, befs_super_block * disk_sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check the byte order of the filesystem */\n\tif (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_LE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_LE;\n\telse if (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_BE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_BE;\n\n\tbefs_sb->magic1 = fs32_to_cpu(sb, disk_sb->magic1);\n\tbefs_sb->magic2 = fs32_to_cpu(sb, disk_sb->magic2);\n\tbefs_sb->magic3 = fs32_to_cpu(sb, disk_sb->magic3);\n\tbefs_sb->block_size = fs32_to_cpu(sb, disk_sb->block_size);\n\tbefs_sb->block_shift = fs32_to_cpu(sb, disk_sb->block_shift);\n\tbefs_sb->num_blocks = fs64_to_cpu(sb, disk_sb->num_blocks);\n\tbefs_sb->used_blocks = fs64_to_cpu(sb, disk_sb->used_blocks);\n\tbefs_sb->inode_size = fs32_to_cpu(sb, disk_sb->inode_size);\n\n\tbefs_sb->blocks_per_ag = fs32_to_cpu(sb, disk_sb->blocks_per_ag);\n\tbefs_sb->ag_shift = fs32_to_cpu(sb, disk_sb->ag_shift);\n\tbefs_sb->num_ags = fs32_to_cpu(sb, disk_sb->num_ags);\n\n\tbefs_sb->log_blocks = fsrun_to_cpu(sb, disk_sb->log_blocks);\n\tbefs_sb->log_start = fs64_to_cpu(sb, disk_sb->log_start);\n\tbefs_sb->log_end = fs64_to_cpu(sb, disk_sb->log_end);\n\n\tbefs_sb->root_dir = fsrun_to_cpu(sb, disk_sb->root_dir);\n\tbefs_sb->indices = fsrun_to_cpu(sb, disk_sb->indices);\n\tbefs_sb->nls = NULL;\n\n\treturn BEFS_OK;\n}",
          "includes": [
            "#include \"super.h\"",
            "#include \"befs.h\"",
            "#include <asm/page.h> /* for PAGE_SIZE */",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include \"befs.h\"\n#include <asm/page.h> /* for PAGE_SIZE */\n#include <linux/fs.h>\n\nint\nbefs_load_sb(struct super_block *sb, befs_super_block * disk_sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check the byte order of the filesystem */\n\tif (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_LE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_LE;\n\telse if (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_BE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_BE;\n\n\tbefs_sb->magic1 = fs32_to_cpu(sb, disk_sb->magic1);\n\tbefs_sb->magic2 = fs32_to_cpu(sb, disk_sb->magic2);\n\tbefs_sb->magic3 = fs32_to_cpu(sb, disk_sb->magic3);\n\tbefs_sb->block_size = fs32_to_cpu(sb, disk_sb->block_size);\n\tbefs_sb->block_shift = fs32_to_cpu(sb, disk_sb->block_shift);\n\tbefs_sb->num_blocks = fs64_to_cpu(sb, disk_sb->num_blocks);\n\tbefs_sb->used_blocks = fs64_to_cpu(sb, disk_sb->used_blocks);\n\tbefs_sb->inode_size = fs32_to_cpu(sb, disk_sb->inode_size);\n\n\tbefs_sb->blocks_per_ag = fs32_to_cpu(sb, disk_sb->blocks_per_ag);\n\tbefs_sb->ag_shift = fs32_to_cpu(sb, disk_sb->ag_shift);\n\tbefs_sb->num_ags = fs32_to_cpu(sb, disk_sb->num_ags);\n\n\tbefs_sb->log_blocks = fsrun_to_cpu(sb, disk_sb->log_blocks);\n\tbefs_sb->log_start = fs64_to_cpu(sb, disk_sb->log_start);\n\tbefs_sb->log_end = fs64_to_cpu(sb, disk_sb->log_end);\n\n\tbefs_sb->root_dir = fsrun_to_cpu(sb, disk_sb->root_dir);\n\tbefs_sb->indices = fsrun_to_cpu(sb, disk_sb->indices);\n\tbefs_sb->nls = NULL;\n\n\treturn BEFS_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "sb_block"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "1024"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "&befs_sb->mount_opts"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "671-745",
          "snippet": "static int\nparse_options(char *options, befs_mount_options * opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/* Initialize options */\n\topts->uid = GLOBAL_ROOT_UID;\n\topts->gid = GLOBAL_ROOT_GID;\n\topts->use_uid = 0;\n\topts->use_gid = 0;\n\topts->iocharset = NULL;\n\topts->debug = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, befs_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = INVALID_UID;\n\t\t\tif (option >= 0)\n\t\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\tpr_err(\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->uid = uid;\n\t\t\topts->use_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = INVALID_GID;\n\t\t\tif (option >= 0)\n\t\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\tpr_err(\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->gid = gid;\n\t\t\topts->use_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_charset:\n\t\t\tkfree(opts->iocharset);\n\t\t\topts->iocharset = match_strdup(&args[0]);\n\t\t\tif (!opts->iocharset) {\n\t\t\t\tpr_err(\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\topts->debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int parse_options(char *, befs_mount_options *);",
            "static const match_table_t befs_tokens = {\n\t{Opt_uid, \"uid=%d\"},\n\t{Opt_gid, \"gid=%d\"},\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int parse_options(char *, befs_mount_options *);\nstatic const match_table_t befs_tokens = {\n\t{Opt_uid, \"uid=%d\"},\n\t{Opt_gid, \"gid=%d\"},\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_err, NULL}\n};\n\nstatic int\nparse_options(char *options, befs_mount_options * opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/* Initialize options */\n\topts->uid = GLOBAL_ROOT_UID;\n\topts->gid = GLOBAL_ROOT_GID;\n\topts->use_uid = 0;\n\topts->use_gid = 0;\n\topts->iocharset = NULL;\n\topts->debug = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, befs_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = INVALID_UID;\n\t\t\tif (option >= 0)\n\t\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\tpr_err(\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->uid = uid;\n\t\t\topts->use_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = INVALID_GID;\n\t\t\tif (option >= 0)\n\t\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\tpr_err(\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->gid = gid;\n\t\t\topts->use_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_charset:\n\t\t\tkfree(opts->iocharset);\n\t\t\topts->iocharset = match_strdup(&args[0]);\n\t\t\tif (!opts->iocharset) {\n\t\t\t\tpr_err(\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\topts->debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"(%s): Unable to allocate memory for private \"\n\t\t       \"portion of superblock. Bailing.\\n\"",
            "sb->s_id"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*befs_sb)",
            "GFP_KERNEL"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic const struct super_operations befs_sops = {\n\t.alloc_inode\t= befs_alloc_inode,\t/* allocate a new inode */\n\t.destroy_inode\t= befs_destroy_inode, /* deallocate an inode */\n\t.put_super\t= befs_put_super,\t/* uninit super */\n\t.statfs\t\t= befs_statfs,\t/* statfs */\n\t.remount_fs\t= befs_remount,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int\nbefs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tbefs_sb_info *befs_sb;\n\tbefs_super_block *disk_sb;\n\tstruct inode *root;\n\tlong ret = -EINVAL;\n\tconst unsigned long sb_block = 0;\n\tconst off_t x86_sb_off = 512;\n\n\tsave_mount_options(sb, data);\n\n\tsb->s_fs_info = kzalloc(sizeof(*befs_sb), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL) {\n\t\tpr_err(\"(%s): Unable to allocate memory for private \"\n\t\t       \"portion of superblock. Bailing.\\n\", sb->s_id);\n\t\tgoto unacquire_none;\n\t}\n\tbefs_sb = BEFS_SB(sb);\n\n\tif (!parse_options((char *) data, &befs_sb->mount_opts)) {\n\t\tbefs_error(sb, \"cannot parse mount options\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tbefs_warning(sb,\n\t\t\t     \"No write support. Marking filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/*\n\t * Set dummy blocksize to read super block.\n\t * Will be set to real fs blocksize later.\n\t *\n\t * Linux 2.4.10 and later refuse to read blocks smaller than\n\t * the hardsect size for the device. But we also need to read at \n\t * least 1k to get the second 512 bytes of the volume.\n\t * -WD 10-26-01\n\t */ \n\tsb_min_blocksize(sb, 1024);\n\n\tif (!(bh = sb_bread(sb, sb_block))) {\n\t\tbefs_error(sb, \"unable to read superblock\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/* account for offset of super block on x86 */\n\tdisk_sb = (befs_super_block *) bh->b_data;\n\tif ((disk_sb->magic1 == BEFS_SUPER_MAGIC1_LE) ||\n\t    (disk_sb->magic1 == BEFS_SUPER_MAGIC1_BE)) {\n\t\tbefs_debug(sb, \"Using PPC superblock location\");\n\t} else {\n\t\tbefs_debug(sb, \"Using x86 superblock location\");\n\t\tdisk_sb =\n\t\t    (befs_super_block *) ((void *) bh->b_data + x86_sb_off);\n\t}\n\n\tif ((befs_load_sb(sb, disk_sb) != BEFS_OK) ||\n\t    (befs_check_sb(sb) != BEFS_OK))\n\t\tgoto unacquire_bh;\n\n\tbefs_dump_super_block(sb, disk_sb);\n\n\tbrelse(bh);\n\n\tif( befs_sb->num_blocks > ~((sector_t)0) ) {\n\t\tbefs_error(sb, \"blocks count: %llu \"\n\t\t\t\"is larger than the host can use\",\n\t\t\tbefs_sb->num_blocks);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/*\n\t * set up enough so that it can read an inode\n\t * Fill in kernel superblock fields from private sb\n\t */\n\tsb->s_magic = BEFS_SUPER_MAGIC;\n\t/* Set real blocksize of fs */\n\tsb_set_blocksize(sb, (ulong) befs_sb->block_size);\n\tsb->s_op = &befs_sops;\n\troot = befs_iget(sb, iaddr2blockno(sb, &(befs_sb->root_dir)));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto unacquire_priv_sbp;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tbefs_error(sb, \"get root inode failed\");\n\t\tgoto unacquire_priv_sbp;\n\t}\n\n\t/* load nls library */\n\tif (befs_sb->mount_opts.iocharset) {\n\t\tbefs_debug(sb, \"Loading nls: %s\",\n\t\t\t   befs_sb->mount_opts.iocharset);\n\t\tbefs_sb->nls = load_nls(befs_sb->mount_opts.iocharset);\n\t\tif (!befs_sb->nls) {\n\t\t\tbefs_warning(sb, \"Cannot load nls %s\"\n\t\t\t\t\t\" loading default nls\",\n\t\t\t\t\tbefs_sb->mount_opts.iocharset);\n\t\t\tbefs_sb->nls = load_nls_default();\n\t\t}\n\t/* load default nls if none is specified  in mount options */\n\t} else {\n\t\tbefs_debug(sb, \"Loading default nls\");\n\t\tbefs_sb->nls = load_nls_default();\n\t}\n\n\treturn 0;\n/*****************/\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_priv_sbp:\n\tkfree(befs_sb->mount_opts.iocharset);\n\tkfree(sb->s_fs_info);\n\n      unacquire_none:\n\tsb->s_fs_info = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "befs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "752-760",
    "snippet": "static void\nbefs_put_super(struct super_block *sb)\n{\n\tkfree(BEFS_SB(sb)->mount_opts.iocharset);\n\tBEFS_SB(sb)->mount_opts.iocharset = NULL;\n\tunload_nls(BEFS_SB(sb)->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "BEFS_SB(sb)->nls"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "BEFS_SB(sb)->mount_opts.iocharset"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic void\nbefs_put_super(struct super_block *sb)\n{\n\tkfree(BEFS_SB(sb)->mount_opts.iocharset);\n\tBEFS_SB(sb)->mount_opts.iocharset = NULL;\n\tunload_nls(BEFS_SB(sb)->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "671-745",
    "snippet": "static int\nparse_options(char *options, befs_mount_options * opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/* Initialize options */\n\topts->uid = GLOBAL_ROOT_UID;\n\topts->gid = GLOBAL_ROOT_GID;\n\topts->use_uid = 0;\n\topts->use_gid = 0;\n\topts->iocharset = NULL;\n\topts->debug = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, befs_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = INVALID_UID;\n\t\t\tif (option >= 0)\n\t\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\tpr_err(\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->uid = uid;\n\t\t\topts->use_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = INVALID_GID;\n\t\t\tif (option >= 0)\n\t\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\tpr_err(\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->gid = gid;\n\t\t\topts->use_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_charset:\n\t\t\tkfree(opts->iocharset);\n\t\t\topts->iocharset = match_strdup(&args[0]);\n\t\t\tif (!opts->iocharset) {\n\t\t\t\tpr_err(\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\topts->debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int parse_options(char *, befs_mount_options *);",
      "static const match_table_t befs_tokens = {\n\t{Opt_uid, \"uid=%d\"},\n\t{Opt_gid, \"gid=%d\"},\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\"",
            "p"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\""
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "opts->iocharset"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\"",
            "option"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\"",
            "option"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "befs_tokens",
            "args"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int parse_options(char *, befs_mount_options *);\nstatic const match_table_t befs_tokens = {\n\t{Opt_uid, \"uid=%d\"},\n\t{Opt_gid, \"gid=%d\"},\n\t{Opt_charset, \"iocharset=%s\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_err, NULL}\n};\n\nstatic int\nparse_options(char *options, befs_mount_options * opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/* Initialize options */\n\topts->uid = GLOBAL_ROOT_UID;\n\topts->gid = GLOBAL_ROOT_GID;\n\topts->use_uid = 0;\n\topts->use_gid = 0;\n\topts->iocharset = NULL;\n\topts->debug = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, befs_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = INVALID_UID;\n\t\t\tif (option >= 0)\n\t\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\tpr_err(\"Invalid uid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->uid = uid;\n\t\t\topts->use_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = INVALID_GID;\n\t\t\tif (option >= 0)\n\t\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\tpr_err(\"Invalid gid %d, \"\n\t\t\t\t       \"using default\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topts->gid = gid;\n\t\t\topts->use_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_charset:\n\t\t\tkfree(opts->iocharset);\n\t\t\topts->iocharset = match_strdup(&args[0]);\n\t\t\tif (!opts->iocharset) {\n\t\t\t\tpr_err(\"allocation failure for \"\n\t\t\t\t       \"iocharset string\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\topts->debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "befs_nls2utf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "598-653",
    "snippet": "static int\nbefs_nls2utf(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\twchar_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* There're nls characters that will translate to 3-chars-wide UTF-8\n\t * characters, a additional byte is needed to save the final \\0\n\t * in special cases */\n\tint maxlen = (3 * in_len) + 1;\n\n\tbefs_debug(sb, \"---> %s\\n\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded.\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\n\n\t\t/* convert from nls to unicode */\n\t\tunilen = nls->char2uni(&in[i], in_len - i, &uni);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from unicode to UTF-8 */\n\t\tutflen = utf32_to_utf8(uni, &result[o], 3);\n\t\tif (utflen <= 0)\n\t\t\tgoto conv_err;\n\t}\n\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn i;\n\n      conv_err:\n\tbefs_error(sb, \"Name using charecter set %s contains a charecter that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
      "static int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s\"",
            "__func__"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"Name using charecter set %s contains a charecter that \"\n\t\t   \"cannot be converted to unicode.\"",
            "nls->charset"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utf32_to_utf8",
          "args": [
            "uni",
            "&result[o]",
            "3"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "utf32_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "86-114",
          "snippet": "int utf32_to_utf8(unicode_t u, u8 *s, int maxout)\n{\n\tunsigned long l;\n\tint c, nc;\n\tconst struct utf8_table *t;\n\n\tif (!s)\n\t\treturn 0;\n\n\tl = u;\n\tif (l > UNICODE_MAX || (l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\treturn -1;\n\n\tnc = 0;\n\tfor (t = utf8_table; t->cmask && maxout; t++, maxout--) {\n\t\tnc++;\n\t\tif (l <= t->lmask) {\n\t\t\tc = t->shift;\n\t\t\t*s = (u8) (t->cval | (l >> c));\n\t\t\twhile (c > 0) {\n\t\t\t\tc -= 6;\n\t\t\t\ts++;\n\t\t\t\t*s = (u8) (0x80 | ((l >> c) & 0x3F));\n\t\t\t}\n\t\t\treturn nc;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SURROGATE_PAIR\t0x0000d800",
            "#define SURROGATE_MASK\t0xfffff800",
            "#define UNICODE_MAX\t0x0010ffff"
          ],
          "globals_used": [
            "static const struct utf8_table utf8_table[] =\n{\n    {0x80,  0x00,   0*6,    0x7F,           0,         /* 1 byte sequence */},\n    {0xE0,  0xC0,   1*6,    0x7FF,          0x80,      /* 2 byte sequence */},\n    {0xF0,  0xE0,   2*6,    0xFFFF,         0x800,     /* 3 byte sequence */},\n    {0xF8,  0xF0,   3*6,    0x1FFFFF,       0x10000,   /* 4 byte sequence */},\n    {0xFC,  0xF8,   4*6,    0x3FFFFFF,      0x200000,  /* 5 byte sequence */},\n    {0xFE,  0xFC,   5*6,    0x7FFFFFFF,     0x4000000, /* 6 byte sequence */},\n    {0,\t\t\t\t\t\t       /* end of table    */}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define SURROGATE_PAIR\t0x0000d800\n#define SURROGATE_MASK\t0xfffff800\n#define UNICODE_MAX\t0x0010ffff\n\nstatic const struct utf8_table utf8_table[] =\n{\n    {0x80,  0x00,   0*6,    0x7F,           0,         /* 1 byte sequence */},\n    {0xE0,  0xC0,   1*6,    0x7FF,          0x80,      /* 2 byte sequence */},\n    {0xF0,  0xE0,   2*6,    0xFFFF,         0x800,     /* 3 byte sequence */},\n    {0xF8,  0xF0,   3*6,    0x1FFFFF,       0x10000,   /* 4 byte sequence */},\n    {0xFC,  0xF8,   4*6,    0x3FFFFFF,      0x200000,  /* 5 byte sequence */},\n    {0xFE,  0xFC,   5*6,    0x7FFFFFFF,     0x4000000, /* 6 byte sequence */},\n    {0,\t\t\t\t\t\t       /* end of table    */}\n};\n\nint utf32_to_utf8(unicode_t u, u8 *s, int maxout)\n{\n\tunsigned long l;\n\tint c, nc;\n\tconst struct utf8_table *t;\n\n\tif (!s)\n\t\treturn 0;\n\n\tl = u;\n\tif (l > UNICODE_MAX || (l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\treturn -1;\n\n\tnc = 0;\n\tfor (t = utf8_table; t->cmask && maxout; t++, maxout--) {\n\t\tnc++;\n\t\tif (l <= t->lmask) {\n\t\t\tc = t->shift;\n\t\t\t*s = (u8) (t->cval | (l >> c));\n\t\t\twhile (c > 0) {\n\t\t\t\tc -= 6;\n\t\t\t\ts++;\n\t\t\t\t*s = (u8) (0x80 | ((l >> c) & 0x3F));\n\t\t\t}\n\t\t\treturn nc;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nls->char2uni",
          "args": [
            "&in[i]",
            "in_len - i",
            "&uni"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "maxlen",
            "GFP_NOFS"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_nls2utf(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\twchar_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* There're nls characters that will translate to 3-chars-wide UTF-8\n\t * characters, a additional byte is needed to save the final \\0\n\t * in special cases */\n\tint maxlen = (3 * in_len) + 1;\n\n\tbefs_debug(sb, \"---> %s\\n\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded.\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\n\n\t\t/* convert from nls to unicode */\n\t\tunilen = nls->char2uni(&in[i], in_len - i, &uni);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from unicode to UTF-8 */\n\t\tutflen = utf32_to_utf8(uni, &result[o], 3);\n\t\tif (utflen <= 0)\n\t\t\tgoto conv_err;\n\t}\n\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn i;\n\n      conv_err:\n\tbefs_error(sb, \"Name using charecter set %s contains a charecter that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}"
  },
  {
    "function_name": "befs_utf2nls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "518-574",
    "snippet": "static int\nbefs_utf2nls(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\tunicode_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* The utf8->nls conversion won't make the final nls string bigger\n\t * than the utf one, but if the string is pure ascii they'll have the\n\t * same width and an extra char is needed to save the additional \\0\n\t */\n\tint maxlen = in_len + 1;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\n\n\t\t/* convert from UTF-8 to Unicode */\n\t\tutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\n\t\tif (utflen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from Unicode to nls */\n\t\tif (uni > MAX_WCHAR_T)\n\t\t\tgoto conv_err;\n\t\tunilen = nls->uni2char(uni, &result[o], in_len - o);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\t}\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn o;\n\n      conv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
      "static int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s\"",
            "__func__"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\"",
            "nls->charset"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nls->uni2char",
          "args": [
            "uni",
            "&result[o]",
            "in_len - o"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utf8_to_utf32",
          "args": [
            "&in[i]",
            "in_len - i",
            "&uni"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "utf8_to_utf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "55-83",
          "snippet": "int utf8_to_utf32(const u8 *s, int inlen, unicode_t *pu)\n{\n\tunsigned long l;\n\tint c0, c, nc;\n\tconst struct utf8_table *t;\n  \n\tnc = 0;\n\tc0 = *s;\n\tl = c0;\n\tfor (t = utf8_table; t->cmask; t++) {\n\t\tnc++;\n\t\tif ((c0 & t->cmask) == t->cval) {\n\t\t\tl &= t->lmask;\n\t\t\tif (l < t->lval || l > UNICODE_MAX ||\n\t\t\t\t\t(l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\t\t\treturn -1;\n\t\t\t*pu = (unicode_t) l;\n\t\t\treturn nc;\n\t\t}\n\t\tif (inlen <= nc)\n\t\t\treturn -1;\n\t\ts++;\n\t\tc = (*s ^ 0x80) & 0xFF;\n\t\tif (c & 0xC0)\n\t\t\treturn -1;\n\t\tl = (l << 6) | c;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SURROGATE_PAIR\t0x0000d800",
            "#define SURROGATE_MASK\t0xfffff800",
            "#define UNICODE_MAX\t0x0010ffff"
          ],
          "globals_used": [
            "static const struct utf8_table utf8_table[] =\n{\n    {0x80,  0x00,   0*6,    0x7F,           0,         /* 1 byte sequence */},\n    {0xE0,  0xC0,   1*6,    0x7FF,          0x80,      /* 2 byte sequence */},\n    {0xF0,  0xE0,   2*6,    0xFFFF,         0x800,     /* 3 byte sequence */},\n    {0xF8,  0xF0,   3*6,    0x1FFFFF,       0x10000,   /* 4 byte sequence */},\n    {0xFC,  0xF8,   4*6,    0x3FFFFFF,      0x200000,  /* 5 byte sequence */},\n    {0xFE,  0xFC,   5*6,    0x7FFFFFFF,     0x4000000, /* 6 byte sequence */},\n    {0,\t\t\t\t\t\t       /* end of table    */}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n#define SURROGATE_PAIR\t0x0000d800\n#define SURROGATE_MASK\t0xfffff800\n#define UNICODE_MAX\t0x0010ffff\n\nstatic const struct utf8_table utf8_table[] =\n{\n    {0x80,  0x00,   0*6,    0x7F,           0,         /* 1 byte sequence */},\n    {0xE0,  0xC0,   1*6,    0x7FF,          0x80,      /* 2 byte sequence */},\n    {0xF0,  0xE0,   2*6,    0xFFFF,         0x800,     /* 3 byte sequence */},\n    {0xF8,  0xF0,   3*6,    0x1FFFFF,       0x10000,   /* 4 byte sequence */},\n    {0xFC,  0xF8,   4*6,    0x3FFFFFF,      0x200000,  /* 5 byte sequence */},\n    {0xFE,  0xFC,   5*6,    0x7FFFFFFF,     0x4000000, /* 6 byte sequence */},\n    {0,\t\t\t\t\t\t       /* end of table    */}\n};\n\nint utf8_to_utf32(const u8 *s, int inlen, unicode_t *pu)\n{\n\tunsigned long l;\n\tint c0, c, nc;\n\tconst struct utf8_table *t;\n  \n\tnc = 0;\n\tc0 = *s;\n\tl = c0;\n\tfor (t = utf8_table; t->cmask; t++) {\n\t\tnc++;\n\t\tif ((c0 & t->cmask) == t->cval) {\n\t\t\tl &= t->lmask;\n\t\t\tif (l < t->lval || l > UNICODE_MAX ||\n\t\t\t\t\t(l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\t\t\treturn -1;\n\t\t\t*pu = (unicode_t) l;\n\t\t\treturn nc;\n\t\t}\n\t\tif (inlen <= nc)\n\t\t\treturn -1;\n\t\ts++;\n\t\tc = (*s ^ 0x80) & 0xFF;\n\t\tif (c & 0xC0)\n\t\t\treturn -1;\n\t\tl = (l << 6) | c;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "maxlen",
            "GFP_NOFS"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_utf2nls(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\tunicode_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* The utf8->nls conversion won't make the final nls string bigger\n\t * than the utf one, but if the string is pure ascii they'll have the\n\t * same width and an extra char is needed to save the additional \\0\n\t */\n\tint maxlen = in_len + 1;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\n\n\t\t/* convert from UTF-8 to Unicode */\n\t\tutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\n\t\tif (utflen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from Unicode to nls */\n\t\tif (uni > MAX_WCHAR_T)\n\t\t\tgoto conv_err;\n\t\tunilen = nls->uni2char(uni, &result[o], in_len - o);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\t}\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn o;\n\n      conv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}"
  },
  {
    "function_name": "befs_fast_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "502-508",
    "snippet": "static void *\nbefs_fast_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\n\tnd_set_link(nd, befs_ino->i_data.symlink);\n\treturn NULL;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);",
      "static void *befs_follow_link(struct dentry *, struct nameidata *);",
      "static void *befs_fast_follow_link(struct dentry *, struct nameidata *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "befs_ino->i_data.symlink"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);\nstatic void *befs_follow_link(struct dentry *, struct nameidata *);\nstatic void *befs_fast_follow_link(struct dentry *, struct nameidata *);\n\nstatic void *\nbefs_fast_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\n\tnd_set_link(nd, befs_ino->i_data.symlink);\n\treturn NULL;\n}"
  },
  {
    "function_name": "befs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "471-499",
    "snippet": "static void *\nbefs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\n\tbefs_data_stream *data = &befs_ino->i_data.ds;\n\tbefs_off_t len = data->size;\n\tchar *link;\n\n\tif (len == 0) {\n\t\tbefs_error(sb, \"Long symlink with illegal length\");\n\t\tlink = ERR_PTR(-EIO);\n\t} else {\n\t\tbefs_debug(sb, \"Follow long symlink\");\n\n\t\tlink = kmalloc(len, GFP_NOFS);\n\t\tif (!link) {\n\t\t\tlink = ERR_PTR(-ENOMEM);\n\t\t} else if (befs_read_lsymlink(sb, data, link, len) != len) {\n\t\t\tkfree(link);\n\t\t\tbefs_error(sb, \"Failed to read entire long symlink\");\n\t\t\tlink = ERR_PTR(-EIO);\n\t\t} else {\n\t\t\tlink[len - 1] = '\\0';\n\t\t}\n\t}\n\tnd_set_link(nd, link);\n\treturn NULL;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void *befs_follow_link(struct dentry *, struct nameidata *);",
      "static void *befs_fast_follow_link(struct dentry *, struct nameidata *);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "link"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"Failed to read entire long symlink\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_read_lsymlink",
          "args": [
            "sb",
            "data",
            "link",
            "len"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "befs_read_lsymlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/datastream.c",
          "lines": "124-152",
          "snippet": "size_t\nbefs_read_lsymlink(struct super_block * sb, befs_data_stream * ds, void *buff,\n\t\t   befs_off_t len)\n{\n\tbefs_off_t bytes_read = 0;\t/* bytes readed */\n\tu16 plen;\n\tstruct buffer_head *bh = NULL;\n\tbefs_debug(sb, \"---> %s length: %llu\", __func__, len);\n\n\twhile (bytes_read < len) {\n\t\tbh = befs_read_datastream(sb, ds, bytes_read, NULL);\n\t\tif (!bh) {\n\t\t\tbefs_error(sb, \"BeFS: Error reading datastream block \"\n\t\t\t\t   \"starting from %llu\", bytes_read);\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn bytes_read;\n\n\t\t}\n\t\tplen = ((bytes_read + BEFS_SB(sb)->block_size) < len) ?\n\t\t    BEFS_SB(sb)->block_size : len - bytes_read;\n\t\tmemcpy(buff + bytes_read, bh->b_data, plen);\n\t\tbrelse(bh);\n\t\tbytes_read += plen;\n\t}\n\n\tbefs_debug(sb, \"<--- %s read %u bytes\", __func__, (unsigned int)\n\t\t   bytes_read);\n\treturn bytes_read;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"datastream.h\"",
            "#include \"befs.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"datastream.h\"\n#include \"befs.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nsize_t\nbefs_read_lsymlink(struct super_block * sb, befs_data_stream * ds, void *buff,\n\t\t   befs_off_t len)\n{\n\tbefs_off_t bytes_read = 0;\t/* bytes readed */\n\tu16 plen;\n\tstruct buffer_head *bh = NULL;\n\tbefs_debug(sb, \"---> %s length: %llu\", __func__, len);\n\n\twhile (bytes_read < len) {\n\t\tbh = befs_read_datastream(sb, ds, bytes_read, NULL);\n\t\tif (!bh) {\n\t\t\tbefs_error(sb, \"BeFS: Error reading datastream block \"\n\t\t\t\t   \"starting from %llu\", bytes_read);\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn bytes_read;\n\n\t\t}\n\t\tplen = ((bytes_read + BEFS_SB(sb)->block_size) < len) ?\n\t\t    BEFS_SB(sb)->block_size : len - bytes_read;\n\t\tmemcpy(buff + bytes_read, bh->b_data, plen);\n\t\tbrelse(bh);\n\t\tbytes_read += plen;\n\t}\n\n\tbefs_debug(sb, \"<--- %s read %u bytes\", __func__, (unsigned int)\n\t\t   bytes_read);\n\treturn bytes_read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"Follow long symlink\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void *befs_follow_link(struct dentry *, struct nameidata *);\nstatic void *befs_fast_follow_link(struct dentry *, struct nameidata *);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic void *\nbefs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tbefs_inode_info *befs_ino = BEFS_I(dentry->d_inode);\n\tbefs_data_stream *data = &befs_ino->i_data.ds;\n\tbefs_off_t len = data->size;\n\tchar *link;\n\n\tif (len == 0) {\n\t\tbefs_error(sb, \"Long symlink with illegal length\");\n\t\tlink = ERR_PTR(-EIO);\n\t} else {\n\t\tbefs_debug(sb, \"Follow long symlink\");\n\n\t\tlink = kmalloc(len, GFP_NOFS);\n\t\tif (!link) {\n\t\t\tlink = ERR_PTR(-ENOMEM);\n\t\t} else if (befs_read_lsymlink(sb, data, link, len) != len) {\n\t\t\tkfree(link);\n\t\t\tbefs_error(sb, \"Failed to read entire long symlink\");\n\t\t\tlink = ERR_PTR(-EIO);\n\t\t} else {\n\t\t\tlink[len - 1] = '\\0';\n\t\t}\n\t}\n\tnd_set_link(nd, link);\n\treturn NULL;\n}"
  },
  {
    "function_name": "befs_destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "455-464",
    "snippet": "static void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inodecache(void);",
      "static struct kmem_cache *befs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "befs_inode_cachep"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inodecache(void);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic void\nbefs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(befs_inode_cachep);\n}"
  },
  {
    "function_name": "befs_init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "436-449",
    "snippet": "static int __init\nbefs_init_inodecache(void)\n{\n\tbefs_inode_cachep = kmem_cache_create(\"befs_inode_cache\",\n\t\t\t\t\t      sizeof (struct befs_inode_info),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (befs_inode_cachep == NULL) {\n\t\tpr_err(\"%s: Couldn't initialize inode slabcache\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *befs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Couldn't initialize inode slabcache\\n\"",
            "__func__"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"befs_inode_cache\"",
            "sizeof (struct befs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic int __init\nbefs_init_inodecache(void)\n{\n\tbefs_inode_cachep = kmem_cache_create(\"befs_inode_cache\",\n\t\t\t\t\t      sizeof (struct befs_inode_info),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (befs_inode_cachep == NULL) {\n\t\tpr_err(\"%s: Couldn't initialize inode slabcache\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "befs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "303-430",
    "snippet": "static struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VFS_BLOCK_SIZE 512"
    ],
    "globals_used": [
      "static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);",
      "static int befs_readpage(struct file *file, struct page *page);",
      "static sector_t befs_bmap(struct address_space *mapping, sector_t block);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);",
      "static const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};",
      "static const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};",
      "static const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};",
      "static const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s - Bad inode\"",
            "__func__"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\"",
            "inode->i_ino"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_count_blocks",
          "args": [
            "sb",
            "&befs_ino->i_data.ds"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "befs_count_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/datastream.c",
          "lines": "165-213",
          "snippet": "befs_blocknr_t\nbefs_count_blocks(struct super_block * sb, befs_data_stream * ds)\n{\n\tbefs_blocknr_t blocks;\n\tbefs_blocknr_t datablocks;\t/* File data blocks */\n\tbefs_blocknr_t metablocks;\t/* FS metadata blocks */\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tdatablocks = ds->size >> befs_sb->block_shift;\n\tif (ds->size & (befs_sb->block_size - 1))\n\t\tdatablocks += 1;\n\n\tmetablocks = 1;\t\t/* Start with 1 block for inode */\n\n\t/* Size of indirect block */\n\tif (ds->size > ds->max_direct_range)\n\t\tmetablocks += ds->indirect.len;\n\n\t/*\n\t   Double indir block, plus all the indirect blocks it mapps\n\t   In the double-indirect range, all block runs of data are\n\t   BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know \n\t   how many data block runs are in the double-indirect region,\n\t   and from that we know how many indirect blocks it takes to\n\t   map them. We assume that the indirect blocks are also\n\t   BEFS_DBLINDIR_BRUN_LEN blocks long.\n\t */\n\tif (ds->size > ds->max_indirect_range && ds->max_indirect_range != 0) {\n\t\tuint dbl_bytes;\n\t\tuint dbl_bruns;\n\t\tuint indirblocks;\n\n\t\tdbl_bytes =\n\t\t    ds->max_double_indirect_range - ds->max_indirect_range;\n\t\tdbl_bruns =\n\t\t    dbl_bytes / (befs_sb->block_size * BEFS_DBLINDIR_BRUN_LEN);\n\t\tindirblocks = dbl_bruns / befs_iaddrs_per_block(sb);\n\n\t\tmetablocks += ds->double_indirect.len;\n\t\tmetablocks += indirblocks;\n\t}\n\n\tblocks = datablocks + metablocks;\n\tbefs_debug(sb, \"<--- %s %u blocks\", __func__, (unsigned int)blocks);\n\n\treturn blocks;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"datastream.h\"",
            "#include \"befs.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"datastream.h\"\n#include \"befs.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nbefs_blocknr_t\nbefs_count_blocks(struct super_block * sb, befs_data_stream * ds)\n{\n\tbefs_blocknr_t blocks;\n\tbefs_blocknr_t datablocks;\t/* File data blocks */\n\tbefs_blocknr_t metablocks;\t/* FS metadata blocks */\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tdatablocks = ds->size >> befs_sb->block_shift;\n\tif (ds->size & (befs_sb->block_size - 1))\n\t\tdatablocks += 1;\n\n\tmetablocks = 1;\t\t/* Start with 1 block for inode */\n\n\t/* Size of indirect block */\n\tif (ds->size > ds->max_direct_range)\n\t\tmetablocks += ds->indirect.len;\n\n\t/*\n\t   Double indir block, plus all the indirect blocks it mapps\n\t   In the double-indirect range, all block runs of data are\n\t   BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know \n\t   how many data block runs are in the double-indirect region,\n\t   and from that we know how many indirect blocks it takes to\n\t   map them. We assume that the indirect blocks are also\n\t   BEFS_DBLINDIR_BRUN_LEN blocks long.\n\t */\n\tif (ds->size > ds->max_indirect_range && ds->max_indirect_range != 0) {\n\t\tuint dbl_bytes;\n\t\tuint dbl_bruns;\n\t\tuint indirblocks;\n\n\t\tdbl_bytes =\n\t\t    ds->max_double_indirect_range - ds->max_indirect_range;\n\t\tdbl_bruns =\n\t\t    dbl_bytes / (befs_sb->block_size * BEFS_DBLINDIR_BRUN_LEN);\n\t\tindirblocks = dbl_bruns / befs_iaddrs_per_block(sb);\n\n\t\tmetablocks += ds->double_indirect.len;\n\t\tmetablocks += indirblocks;\n\t}\n\n\tblocks = datablocks + metablocks;\n\tbefs_debug(sb, \"<--- %s %u blocks\", __func__, (unsigned int)blocks);\n\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsds_to_cpu",
          "args": [
            "sb",
            "&raw_inode->data.datastream"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "fsds_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "104-123",
          "snippet": "static inline befs_data_stream\nfsds_to_cpu(const struct super_block *sb, const befs_disk_data_stream *n)\n{\n\tbefs_data_stream data;\n\tint i;\n\n\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; ++i)\n\t\tdata.direct[i] = fsrun_to_cpu(sb, n->direct[i]);\n\n\tdata.max_direct_range = fs64_to_cpu(sb, n->max_direct_range);\n\tdata.indirect = fsrun_to_cpu(sb, n->indirect);\n\tdata.max_indirect_range = fs64_to_cpu(sb, n->max_indirect_range);\n\tdata.double_indirect = fsrun_to_cpu(sb, n->double_indirect);\n\tdata.max_double_indirect_range = fs64_to_cpu(sb,\n\t\t\t\t\t\t     n->\n\t\t\t\t\t\t     max_double_indirect_range);\n\tdata.size = fs64_to_cpu(sb, n->size);\n\n\treturn data;\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline befs_data_stream\nfsds_to_cpu(const struct super_block *sb, const befs_disk_data_stream *n)\n{\n\tbefs_data_stream data;\n\tint i;\n\n\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; ++i)\n\t\tdata.direct[i] = fsrun_to_cpu(sb, n->direct[i]);\n\n\tdata.max_direct_range = fs64_to_cpu(sb, n->max_direct_range);\n\tdata.indirect = fsrun_to_cpu(sb, n->indirect);\n\tdata.max_indirect_range = fs64_to_cpu(sb, n->max_indirect_range);\n\tdata.double_indirect = fsrun_to_cpu(sb, n->double_indirect);\n\tdata.max_double_indirect_range = fs64_to_cpu(sb,\n\t\t\t\t\t\t     n->\n\t\t\t\t\t\t     max_double_indirect_range);\n\tdata.size = fs64_to_cpu(sb, n->size);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "befs_ino->i_data.symlink",
            "raw_inode->data.symlink",
            "BEFS_SYMLINK_LEN"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "raw_inode->flags"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "32-39",
          "snippet": "static inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsrun_to_cpu",
          "args": [
            "sb",
            "raw_inode->attributes"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "fsrun_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "70-85",
          "snippet": "static inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "raw_inode->last_modified_time"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "14-21",
          "snippet": "static inline u64\nfs64_to_cpu(const struct super_block *sb, fs64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline u64\nfs64_to_cpu(const struct super_block *sb, fs64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "fs32_to_cpu(sb, raw_inode->gid)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "fs32_to_cpu(sb, raw_inode->uid)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_check_inode",
          "args": [
            "sb",
            "raw_inode",
            "inode->i_ino"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "befs_check_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/inode.c",
          "lines": "17-54",
          "snippet": "int\nbefs_check_inode(struct super_block *sb, befs_inode * raw_inode,\n\t\t befs_blocknr_t inode)\n{\n\tu32 magic1 = fs32_to_cpu(sb, raw_inode->magic1);\n\tbefs_inode_addr ino_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tu32 flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\t/* check magic header. */\n\tif (magic1 != BEFS_INODE_MAGIC1) {\n\t\tbefs_error(sb,\n\t\t\t   \"Inode has a bad magic header - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * Sanity check2: inodes store their own block address. Check it.\n\t */\n\tif (inode != iaddr2blockno(sb, &ino_num)) {\n\t\tbefs_error(sb, \"inode blocknr field disagrees with vfs \"\n\t\t\t   \"VFS: %lu, Inode %lu\", (unsigned long)\n\t\t\t   inode, (unsigned long)iaddr2blockno(sb, &ino_num));\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * check flag\n\t */\n\n\tif (!(flags & BEFS_INODE_IN_USE)) {\n\t\tbefs_error(sb, \"inode is not used - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\treturn BEFS_OK;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include \"befs.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include \"befs.h\"\n#include <linux/fs.h>\n\nint\nbefs_check_inode(struct super_block *sb, befs_inode * raw_inode,\n\t\t befs_blocknr_t inode)\n{\n\tu32 magic1 = fs32_to_cpu(sb, raw_inode->magic1);\n\tbefs_inode_addr ino_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tu32 flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\t/* check magic header. */\n\tif (magic1 != BEFS_INODE_MAGIC1) {\n\t\tbefs_error(sb,\n\t\t\t   \"Inode has a bad magic header - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * Sanity check2: inodes store their own block address. Check it.\n\t */\n\tif (inode != iaddr2blockno(sb, &ino_num)) {\n\t\tbefs_error(sb, \"inode blocknr field disagrees with vfs \"\n\t\t\t   \"VFS: %lu, Inode %lu\", (unsigned long)\n\t\t\t   inode, (unsigned long)iaddr2blockno(sb, &ino_num));\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\t/*\n\t * check flag\n\t */\n\n\tif (!(flags & BEFS_INODE_IN_USE)) {\n\t\tbefs_error(sb, \"inode is not used - inode = %lu\",\n\t\t\t   (unsigned long)inode);\n\t\treturn BEFS_BAD_INODE;\n\t}\n\n\treturn BEFS_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_dump_inode",
          "args": [
            "sb",
            "raw_inode"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "befs_dump_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "69-147",
          "snippet": "void\nbefs_dump_inode(const struct super_block *sb, befs_inode * inode)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_inode information\");\n\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, inode->magic1));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->inode_num);\n\tbefs_debug(sb, \"  inode_num %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  uid %u\", fs32_to_cpu(sb, inode->uid));\n\tbefs_debug(sb, \"  gid %u\", fs32_to_cpu(sb, inode->gid));\n\tbefs_debug(sb, \"  mode %08x\", fs32_to_cpu(sb, inode->mode));\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, inode->flags));\n\tbefs_debug(sb, \"  create_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->create_time));\n\tbefs_debug(sb, \"  last_modified_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->last_modified_time));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->parent);\n\tbefs_debug(sb, \"  parent [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, inode->attributes);\n\tbefs_debug(sb, \"  attributes [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  type %08x\", fs32_to_cpu(sb, inode->type));\n\tbefs_debug(sb, \"  inode_size %u\", fs32_to_cpu(sb, inode->inode_size));\n\n\tif (S_ISLNK(fs32_to_cpu(sb, inode->mode))) {\n\t\tbefs_debug(sb, \"  Symbolic link [%s]\", inode->data.symlink);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; i++) {\n\t\t\ttmp_run =\n\t\t\t    fsrun_to_cpu(sb, inode->data.datastream.direct[i]);\n\t\t\tbefs_debug(sb, \"  direct %d [%u, %hu, %hu]\", i,\n\t\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t\t   tmp_run.len);\n\t\t}\n\t\tbefs_debug(sb, \"  max_direct_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_direct_range));\n\n\t\ttmp_run = fsrun_to_cpu(sb, inode->data.datastream.indirect);\n\t\tbefs_debug(sb, \"  indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group,\n\t\t\t   tmp_run.start, tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_indirect_range));\n\n\t\ttmp_run =\n\t\t    fsrun_to_cpu(sb, inode->data.datastream.double_indirect);\n\t\tbefs_debug(sb, \"  double indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t   tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_double_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_double_indirect_range));\n\n\t\tbefs_debug(sb, \"  size %llu\",\n\t\t\t   fs64_to_cpu(sb, inode->data.datastream.size));\n\t}\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_dump_inode(const struct super_block *sb, befs_inode * inode)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tbefs_block_run tmp_run;\n\n\tbefs_debug(sb, \"befs_inode information\");\n\n\tbefs_debug(sb, \"  magic1 %08x\", fs32_to_cpu(sb, inode->magic1));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->inode_num);\n\tbefs_debug(sb, \"  inode_num %u, %hu, %hu\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  uid %u\", fs32_to_cpu(sb, inode->uid));\n\tbefs_debug(sb, \"  gid %u\", fs32_to_cpu(sb, inode->gid));\n\tbefs_debug(sb, \"  mode %08x\", fs32_to_cpu(sb, inode->mode));\n\tbefs_debug(sb, \"  flags %08x\", fs32_to_cpu(sb, inode->flags));\n\tbefs_debug(sb, \"  create_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->create_time));\n\tbefs_debug(sb, \"  last_modified_time %llu\",\n\t\t   fs64_to_cpu(sb, inode->last_modified_time));\n\n\ttmp_run = fsrun_to_cpu(sb, inode->parent);\n\tbefs_debug(sb, \"  parent [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\ttmp_run = fsrun_to_cpu(sb, inode->attributes);\n\tbefs_debug(sb, \"  attributes [%u, %hu, %hu]\",\n\t\t   tmp_run.allocation_group, tmp_run.start, tmp_run.len);\n\n\tbefs_debug(sb, \"  type %08x\", fs32_to_cpu(sb, inode->type));\n\tbefs_debug(sb, \"  inode_size %u\", fs32_to_cpu(sb, inode->inode_size));\n\n\tif (S_ISLNK(fs32_to_cpu(sb, inode->mode))) {\n\t\tbefs_debug(sb, \"  Symbolic link [%s]\", inode->data.symlink);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < BEFS_NUM_DIRECT_BLOCKS; i++) {\n\t\t\ttmp_run =\n\t\t\t    fsrun_to_cpu(sb, inode->data.datastream.direct[i]);\n\t\t\tbefs_debug(sb, \"  direct %d [%u, %hu, %hu]\", i,\n\t\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t\t   tmp_run.len);\n\t\t}\n\t\tbefs_debug(sb, \"  max_direct_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_direct_range));\n\n\t\ttmp_run = fsrun_to_cpu(sb, inode->data.datastream.indirect);\n\t\tbefs_debug(sb, \"  indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group,\n\t\t\t   tmp_run.start, tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_indirect_range));\n\n\t\ttmp_run =\n\t\t    fsrun_to_cpu(sb, inode->data.datastream.double_indirect);\n\t\tbefs_debug(sb, \"  double indirect [%u, %hu, %hu]\",\n\t\t\t   tmp_run.allocation_group, tmp_run.start,\n\t\t\t   tmp_run.len);\n\n\t\tbefs_debug(sb, \"  max_double_indirect_range %llu\",\n\t\t\t   fs64_to_cpu(sb,\n\t\t\t\t       inode->data.datastream.\n\t\t\t\t       max_double_indirect_range));\n\n\t\tbefs_debug(sb, \"  size %llu\",\n\t\t\t   fs64_to_cpu(sb, inode->data.datastream.size));\n\t}\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "befs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/io.c",
          "lines": "63-85",
          "snippet": "struct buffer_head *\nbefs_bread(struct super_block *sb, befs_blocknr_t block)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbefs_debug(sb, \"---> Enter %s %lu\", __func__, (unsigned long)block);\n\n\tbh = sb_bread(sb, block);\n\n\tif (bh == NULL) {\n\t\tbefs_error(sb, \"Failed to read block %lu\",\n\t\t\t   (unsigned long)block);\n\t\tgoto error;\n\t}\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn bh;\n\n      error:\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn NULL;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"befs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"befs.h\"\n#include <linux/buffer_head.h>\n\nstruct buffer_head *\nbefs_bread(struct super_block *sb, befs_blocknr_t block)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbefs_debug(sb, \"---> Enter %s %lu\", __func__, (unsigned long)block);\n\n\tbh = sb_bread(sb, block);\n\n\tif (bh == NULL) {\n\t\tbefs_error(sb, \"Failed to read block %lu\",\n\t\t\t   (unsigned long)block);\n\t\tgoto error;\n\t}\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn bh;\n\n      error:\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockno2iaddr",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "blockno2iaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "127-137",
          "snippet": "static inline befs_inode_addr\nblockno2iaddr(struct super_block *sb, befs_blocknr_t blockno)\n{\n\tbefs_inode_addr iaddr;\n\tiaddr.allocation_group = blockno >> BEFS_SB(sb)->ag_shift;\n\tiaddr.start =\n\t    blockno - (iaddr.allocation_group << BEFS_SB(sb)->ag_shift);\n\tiaddr.len = 1;\n\n\treturn iaddr;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_addr\nblockno2iaddr(struct super_block *sb, befs_blocknr_t blockno)\n{\n\tbefs_inode_addr iaddr;\n\tiaddr.allocation_group = blockno >> BEFS_SB(sb)->ag_shift;\n\tiaddr.start =\n\t    blockno - (iaddr.allocation_group << BEFS_SB(sb)->ag_shift);\n\tiaddr.len = 1;\n\n\treturn iaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "inode"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define VFS_BLOCK_SIZE 512\n\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic int befs_readpage(struct file *file, struct page *page);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};\nstatic const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};\nstatic const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};\nstatic const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};\n\nstatic struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "296-301",
    "snippet": "static void init_once(void *foo)\n{\n        struct befs_inode_info *bi = (struct befs_inode_info *) foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&bi->vfs_inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n        struct befs_inode_info *bi = (struct befs_inode_info *) foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}"
  },
  {
    "function_name": "befs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "291-294",
    "snippet": "static void befs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, befs_i_callback);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "befs_i_callback"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inode(struct inode *inode);\n\nstatic void befs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, befs_i_callback);\n}"
  },
  {
    "function_name": "befs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "285-289",
    "snippet": "static void befs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n        kmem_cache_free(befs_inode_cachep, BEFS_I(inode));\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void befs_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *befs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "befs_inode_cachep",
            "BEFS_I(inode)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void befs_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic void befs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n        kmem_cache_free(befs_inode_cachep, BEFS_I(inode));\n}"
  },
  {
    "function_name": "befs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "274-283",
    "snippet": "static struct inode *\nbefs_alloc_inode(struct super_block *sb)\n{\n\tstruct befs_inode_info *bi;\n\n\tbi = kmem_cache_alloc(befs_inode_cachep, GFP_KERNEL);\n        if (!bi)\n                return NULL;\n        return &bi->vfs_inode;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);",
      "static struct kmem_cache *befs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "befs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic struct kmem_cache *befs_inode_cachep;\n\nstatic struct inode *\nbefs_alloc_inode(struct super_block *sb)\n{\n\tstruct befs_inode_info *bi;\n\n\tbi = kmem_cache_alloc(befs_inode_cachep, GFP_KERNEL);\n        if (!bi)\n                return NULL;\n        return &bi->vfs_inode;\n}"
  },
  {
    "function_name": "befs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "213-272",
    "snippet": "static int\nbefs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_off_t value;\n\tint result;\n\tsize_t keysize;\n\tunsigned char d_type;\n\tchar keybuf[BEFS_NAME_LEN + 1];\n\n\tbefs_debug(sb, \"---> %s name %pD, inode %ld, ctx->pos %lld\",\n\t\t  __func__, file, inode->i_ino, ctx->pos);\n\nmore:\n\tresult = befs_btree_read(sb, ds, ctx->pos, BEFS_NAME_LEN + 1,\n\t\t\t\t keybuf, &keysize, &value);\n\n\tif (result == BEFS_ERR) {\n\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\tbefs_error(sb, \"IO error reading %pD (inode %lu)\",\n\t\t\t   file, inode->i_ino);\n\t\treturn -EIO;\n\n\t} else if (result == BEFS_BT_END) {\n\t\tbefs_debug(sb, \"<--- %s END\", __func__);\n\t\treturn 0;\n\n\t} else if (result == BEFS_BT_EMPTY) {\n\t\tbefs_debug(sb, \"<--- %s Empty directory\", __func__);\n\t\treturn 0;\n\t}\n\n\td_type = DT_UNKNOWN;\n\n\t/* Convert to NLS */\n\tif (BEFS_SB(sb)->nls) {\n\t\tchar *nlsname;\n\t\tint nlsnamelen;\n\t\tresult =\n\t\t    befs_utf2nls(sb, keybuf, keysize, &nlsname, &nlsnamelen);\n\t\tif (result < 0) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn result;\n\t\t}\n\t\tif (!dir_emit(ctx, nlsname, nlsnamelen,\n\t\t\t\t (ino_t) value, d_type)) {\n\t\t\tkfree(nlsname);\n\t\t\treturn 0;\n\t\t}\n\t\tkfree(nlsname);\n\t} else {\n\t\tif (!dir_emit(ctx, keybuf, keysize,\n\t\t\t\t (ino_t) value, d_type))\n\t\t\treturn 0;\n\t}\n\tctx->pos++;\n\tgoto more;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int befs_readdir(struct file *, struct dir_context *);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "keybuf",
            "keysize",
            "(ino_t) value",
            "d_type"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nlsname"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nlsname"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "nlsname",
            "nlsnamelen",
            "(ino_t) value",
            "d_type"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s ERROR\"",
            "__func__"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_utf2nls",
          "args": [
            "sb",
            "keybuf",
            "keysize",
            "&nlsname",
            "&nlsnamelen"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "befs_utf2nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "518-574",
          "snippet": "static int\nbefs_utf2nls(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\tunicode_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* The utf8->nls conversion won't make the final nls string bigger\n\t * than the utf one, but if the string is pure ascii they'll have the\n\t * same width and an extra char is needed to save the additional \\0\n\t */\n\tint maxlen = in_len + 1;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\n\n\t\t/* convert from UTF-8 to Unicode */\n\t\tutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\n\t\tif (utflen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from Unicode to nls */\n\t\tif (uni > MAX_WCHAR_T)\n\t\t\tgoto conv_err;\n\t\tunilen = nls->uni2char(uni, &result[o], in_len - o);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\t}\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn o;\n\n      conv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *befs_iget(struct super_block *, unsigned long);",
            "static struct inode *befs_alloc_inode(struct super_block *sb);",
            "static int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
            "static int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
            "static void befs_put_super(struct super_block *);",
            "static int befs_remount(struct super_block *, int *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_utf2nls(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\tunicode_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* The utf8->nls conversion won't make the final nls string bigger\n\t * than the utf one, but if the string is pure ascii they'll have the\n\t * same width and an extra char is needed to save the additional \\0\n\t */\n\tint maxlen = in_len + 1;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += utflen, o += unilen) {\n\n\t\t/* convert from UTF-8 to Unicode */\n\t\tutflen = utf8_to_utf32(&in[i], in_len - i, &uni);\n\t\tif (utflen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from Unicode to nls */\n\t\tif (uni > MAX_WCHAR_T)\n\t\t\tgoto conv_err;\n\t\tunilen = nls->uni2char(uni, &result[o], in_len - o);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\t}\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn o;\n\n      conv_err:\n\tbefs_error(sb, \"Name using character set %s contains a character that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"IO error reading %pD (inode %lu)\"",
            "file",
            "inode->i_ino"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_btree_read",
          "args": [
            "sb",
            "ds",
            "ctx->pos",
            "BEFS_NAME_LEN + 1",
            "keybuf",
            "&keysize",
            "&value"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "befs_btree_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/btree.c",
          "lines": "418-533",
          "snippet": "int\nbefs_btree_read(struct super_block *sb, befs_data_stream * ds,\n\t\tloff_t key_no, size_t bufsize, char *keybuf, size_t * keysize,\n\t\tbefs_off_t * value)\n{\n\tstruct befs_btree_node *this_node;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off = 0;\n\tint cur_key;\n\tfs64 *valarray;\n\tchar *keystart;\n\tu16 keylen;\n\tint res;\n\n\tuint key_sum = 0;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_read() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node), GFP_NOFS);\n\tif (this_node == NULL) {\n\t\tbefs_error(sb, \"befs_btree_read() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tnode_off = bt_super.root_node_ptr;\n\tthis_node->bh = NULL;\n\n\t/* seeks down to first leafnode, reads it into this_node */\n\tres = befs_btree_seekleaf(sb, ds, &bt_super, this_node, &node_off);\n\tif (res == BEFS_BT_EMPTY) {\n\t\tbrelse(this_node->bh);\n\t\tkfree(this_node);\n\t\t*value = 0;\n\t\t*keysize = 0;\n\t\tbefs_debug(sb, \"<--- %s Tree is EMPTY\", __func__);\n\t\treturn BEFS_BT_EMPTY;\n\t} else if (res == BEFS_ERR) {\n\t\tgoto error_alloc;\n\t}\n\n\t/* find the leaf node containing the key_no key */\n\n\twhile (key_sum + this_node->head.all_key_count <= key_no) {\n\n\t\t/* no more nodes to look in: key_no is too large */\n\t\tif (this_node->head.right == befs_bt_inval) {\n\t\t\t*keysize = 0;\n\t\t\t*value = 0;\n\t\t\tbefs_debug(sb,\n\t\t\t\t   \"<--- %s END of keys at %llu\", __func__,\n\t\t\t\t   (unsigned long long)\n\t\t\t\t   key_sum + this_node->head.all_key_count);\n\t\t\tbrelse(this_node->bh);\n\t\t\tkfree(this_node);\n\t\t\treturn BEFS_BT_END;\n\t\t}\n\n\t\tkey_sum += this_node->head.all_key_count;\n\t\tnode_off = this_node->head.right;\n\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"%s failed to read node at %llu\",\n\t\t\t\t  __func__, (unsigned long long)node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t/* how many keys into this_node is key_no */\n\tcur_key = key_no - key_sum;\n\n\t/* get pointers to datastructures within the node body */\n\tvalarray = befs_bt_valarray(this_node);\n\n\tkeystart = befs_bt_get_key(sb, this_node, cur_key, &keylen);\n\n\tbefs_debug(sb, \"Read [%llu,%d]: keysize %d\",\n\t\t   (long long unsigned int)node_off, (int)cur_key,\n\t\t   (int)keylen);\n\n\tif (bufsize < keylen + 1) {\n\t\tbefs_error(sb, \"%s keybuf too small (%zu) \"\n\t\t\t   \"for key of size %d\", __func__, bufsize, keylen);\n\t\tbrelse(this_node->bh);\n\t\tgoto error_alloc;\n\t}\n\n\tstrlcpy(keybuf, keystart, keylen + 1);\n\t*value = fs64_to_cpu(sb, valarray[cur_key]);\n\t*keysize = keylen;\n\n\tbefs_debug(sb, \"Read [%llu,%d]: Key \\\"%.*s\\\", Value %llu\", node_off,\n\t\t   cur_key, keylen, keybuf, *value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n\n      error:\n\t*keysize = 0;\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}",
          "includes": [
            "#include \"datastream.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const befs_off_t befs_bt_inval = 0xffffffffffffffffULL;",
            "static int befs_btree_seekleaf(struct super_block *sb, befs_data_stream * ds,\n\t\t\t       befs_btree_super * bt_super,\n\t\t\t       struct befs_btree_node *this_node,\n\t\t\t       befs_off_t * node_off);",
            "static int befs_bt_read_node(struct super_block *sb, befs_data_stream * ds,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     befs_off_t node_off);",
            "static int befs_leafnode(struct befs_btree_node *node);",
            "static fs16 *befs_bt_keylen_index(struct befs_btree_node *node);",
            "static fs64 *befs_bt_valarray(struct befs_btree_node *node);",
            "static char *befs_bt_keydata(struct befs_btree_node *node);",
            "static int befs_find_key(struct super_block *sb,\n\t\t\t struct befs_btree_node *node,\n\t\t\t const char *findkey, befs_off_t * value);",
            "static char *befs_bt_get_key(struct super_block *sb,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     int index, u16 * keylen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"datastream.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic const befs_off_t befs_bt_inval = 0xffffffffffffffffULL;\nstatic int befs_btree_seekleaf(struct super_block *sb, befs_data_stream * ds,\n\t\t\t       befs_btree_super * bt_super,\n\t\t\t       struct befs_btree_node *this_node,\n\t\t\t       befs_off_t * node_off);\nstatic int befs_bt_read_node(struct super_block *sb, befs_data_stream * ds,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     befs_off_t node_off);\nstatic int befs_leafnode(struct befs_btree_node *node);\nstatic fs16 *befs_bt_keylen_index(struct befs_btree_node *node);\nstatic fs64 *befs_bt_valarray(struct befs_btree_node *node);\nstatic char *befs_bt_keydata(struct befs_btree_node *node);\nstatic int befs_find_key(struct super_block *sb,\n\t\t\t struct befs_btree_node *node,\n\t\t\t const char *findkey, befs_off_t * value);\nstatic char *befs_bt_get_key(struct super_block *sb,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     int index, u16 * keylen);\n\nint\nbefs_btree_read(struct super_block *sb, befs_data_stream * ds,\n\t\tloff_t key_no, size_t bufsize, char *keybuf, size_t * keysize,\n\t\tbefs_off_t * value)\n{\n\tstruct befs_btree_node *this_node;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off = 0;\n\tint cur_key;\n\tfs64 *valarray;\n\tchar *keystart;\n\tu16 keylen;\n\tint res;\n\n\tuint key_sum = 0;\n\n\tbefs_debug(sb, \"---> %s\", __func__);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_read() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node), GFP_NOFS);\n\tif (this_node == NULL) {\n\t\tbefs_error(sb, \"befs_btree_read() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tnode_off = bt_super.root_node_ptr;\n\tthis_node->bh = NULL;\n\n\t/* seeks down to first leafnode, reads it into this_node */\n\tres = befs_btree_seekleaf(sb, ds, &bt_super, this_node, &node_off);\n\tif (res == BEFS_BT_EMPTY) {\n\t\tbrelse(this_node->bh);\n\t\tkfree(this_node);\n\t\t*value = 0;\n\t\t*keysize = 0;\n\t\tbefs_debug(sb, \"<--- %s Tree is EMPTY\", __func__);\n\t\treturn BEFS_BT_EMPTY;\n\t} else if (res == BEFS_ERR) {\n\t\tgoto error_alloc;\n\t}\n\n\t/* find the leaf node containing the key_no key */\n\n\twhile (key_sum + this_node->head.all_key_count <= key_no) {\n\n\t\t/* no more nodes to look in: key_no is too large */\n\t\tif (this_node->head.right == befs_bt_inval) {\n\t\t\t*keysize = 0;\n\t\t\t*value = 0;\n\t\t\tbefs_debug(sb,\n\t\t\t\t   \"<--- %s END of keys at %llu\", __func__,\n\t\t\t\t   (unsigned long long)\n\t\t\t\t   key_sum + this_node->head.all_key_count);\n\t\t\tbrelse(this_node->bh);\n\t\t\tkfree(this_node);\n\t\t\treturn BEFS_BT_END;\n\t\t}\n\n\t\tkey_sum += this_node->head.all_key_count;\n\t\tnode_off = this_node->head.right;\n\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"%s failed to read node at %llu\",\n\t\t\t\t  __func__, (unsigned long long)node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t/* how many keys into this_node is key_no */\n\tcur_key = key_no - key_sum;\n\n\t/* get pointers to datastructures within the node body */\n\tvalarray = befs_bt_valarray(this_node);\n\n\tkeystart = befs_bt_get_key(sb, this_node, cur_key, &keylen);\n\n\tbefs_debug(sb, \"Read [%llu,%d]: keysize %d\",\n\t\t   (long long unsigned int)node_off, (int)cur_key,\n\t\t   (int)keylen);\n\n\tif (bufsize < keylen + 1) {\n\t\tbefs_error(sb, \"%s keybuf too small (%zu) \"\n\t\t\t   \"for key of size %d\", __func__, bufsize, keylen);\n\t\tbrelse(this_node->bh);\n\t\tgoto error_alloc;\n\t}\n\n\tstrlcpy(keybuf, keystart, keylen + 1);\n\t*value = fs64_to_cpu(sb, valarray[cur_key]);\n\t*keysize = keylen;\n\n\tbefs_debug(sb, \"Read [%llu,%d]: Key \\\"%.*s\\\", Value %llu\", node_off,\n\t\t   cur_key, keylen, keybuf, *value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n\n      error:\n\t*keysize = 0;\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "inode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int befs_readdir(struct file *, struct dir_context *);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_off_t value;\n\tint result;\n\tsize_t keysize;\n\tunsigned char d_type;\n\tchar keybuf[BEFS_NAME_LEN + 1];\n\n\tbefs_debug(sb, \"---> %s name %pD, inode %ld, ctx->pos %lld\",\n\t\t  __func__, file, inode->i_ino, ctx->pos);\n\nmore:\n\tresult = befs_btree_read(sb, ds, ctx->pos, BEFS_NAME_LEN + 1,\n\t\t\t\t keybuf, &keysize, &value);\n\n\tif (result == BEFS_ERR) {\n\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\tbefs_error(sb, \"IO error reading %pD (inode %lu)\",\n\t\t\t   file, inode->i_ino);\n\t\treturn -EIO;\n\n\t} else if (result == BEFS_BT_END) {\n\t\tbefs_debug(sb, \"<--- %s END\", __func__);\n\t\treturn 0;\n\n\t} else if (result == BEFS_BT_EMPTY) {\n\t\tbefs_debug(sb, \"<--- %s Empty directory\", __func__);\n\t\treturn 0;\n\t}\n\n\td_type = DT_UNKNOWN;\n\n\t/* Convert to NLS */\n\tif (BEFS_SB(sb)->nls) {\n\t\tchar *nlsname;\n\t\tint nlsnamelen;\n\t\tresult =\n\t\t    befs_utf2nls(sb, keybuf, keysize, &nlsname, &nlsnamelen);\n\t\tif (result < 0) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn result;\n\t\t}\n\t\tif (!dir_emit(ctx, nlsname, nlsnamelen,\n\t\t\t\t (ino_t) value, d_type)) {\n\t\t\tkfree(nlsname);\n\t\t\treturn 0;\n\t\t}\n\t\tkfree(nlsname);\n\t} else {\n\t\tif (!dir_emit(ctx, keybuf, keysize,\n\t\t\t\t (ino_t) value, d_type))\n\t\t\treturn 0;\n\t}\n\tctx->pos++;\n\tgoto more;\n}"
  },
  {
    "function_name": "befs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "163-211",
    "snippet": "static struct dentry *\nbefs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = dir->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(dir)->i_data.ds;\n\tbefs_off_t offset;\n\tint ret;\n\tint utfnamelen;\n\tchar *utfname;\n\tconst char *name = dentry->d_name.name;\n\n\tbefs_debug(sb, \"---> %s name %pd inode %ld\", __func__,\n\t\t   dentry, dir->i_ino);\n\n\t/* Convert to UTF-8 */\n\tif (BEFS_SB(sb)->nls) {\n\t\tret =\n\t\t    befs_nls2utf(sb, name, strlen(name), &utfname, &utfnamelen);\n\t\tif (ret < 0) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\tret = befs_btree_find(sb, ds, utfname, &offset);\n\t\tkfree(utfname);\n\n\t} else {\n\t\tret = befs_btree_find(sb, ds, dentry->d_name.name, &offset);\n\t}\n\n\tif (ret == BEFS_BT_NOT_FOUND) {\n\t\tbefs_debug(sb, \"<--- %s %pd not found\", __func__, dentry);\n\t\treturn ERR_PTR(-ENOENT);\n\n\t} else if (ret != BEFS_OK || offset == 0) {\n\t\tbefs_warning(sb, \"<--- %s Error\", __func__);\n\t\treturn ERR_PTR(-ENODATA);\n\t}\n\n\tinode = befs_iget(dir->i_sb, (ino_t) offset);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\td_add(dentry, inode);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s\"",
            "__func__"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_iget",
          "args": [
            "dir->i_sb",
            "(ino_t) offset"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "befs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "303-430",
          "snippet": "static struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VFS_BLOCK_SIZE 512"
          ],
          "globals_used": [
            "static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);",
            "static int befs_readpage(struct file *file, struct page *page);",
            "static sector_t befs_bmap(struct address_space *mapping, sector_t block);",
            "static struct inode *befs_iget(struct super_block *, unsigned long);",
            "static struct inode *befs_alloc_inode(struct super_block *sb);",
            "static void befs_destroy_inode(struct inode *inode);",
            "static void befs_put_super(struct super_block *);",
            "static int befs_remount(struct super_block *, int *, char *);",
            "static const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
            "static const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};",
            "static const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};",
            "static const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};",
            "static const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define VFS_BLOCK_SIZE 512\n\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic int befs_readpage(struct file *file, struct page *page);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\nstatic const struct file_operations befs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= befs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations befs_dir_inode_operations = {\n\t.lookup\t\t= befs_lookup,\n};\nstatic const struct address_space_operations befs_aops = {\n\t.readpage\t= befs_readpage,\n\t.bmap\t\t= befs_bmap,\n};\nstatic const struct inode_operations befs_fast_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_fast_follow_link,\n};\nstatic const struct inode_operations befs_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= befs_follow_link,\n\t.put_link\t= kfree_put_link,\n};\n\nstatic struct inode *befs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct buffer_head *bh = NULL;\n\tbefs_inode *raw_inode = NULL;\n\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\tbefs_inode_info *befs_ino = NULL;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\n\tbefs_debug(sb, \"---> %s inode = %lu\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbefs_ino = BEFS_I(inode);\n\n\t/* convert from vfs's inode number to befs's inode number */\n\tbefs_ino->i_inode_num = blockno2iaddr(sb, inode->i_ino);\n\n\tbefs_debug(sb, \"  real inode number [%u, %hu, %hu]\",\n\t\t   befs_ino->i_inode_num.allocation_group,\n\t\t   befs_ino->i_inode_num.start, befs_ino->i_inode_num.len);\n\n\tbh = befs_bread(sb, inode->i_ino);\n\tif (!bh) {\n\t\tbefs_error(sb, \"unable to read inode block - \"\n\t\t\t   \"inode = %lu\", inode->i_ino);\n\t\tgoto unacquire_none;\n\t}\n\n\traw_inode = (befs_inode *) bh->b_data;\n\n\tbefs_dump_inode(sb, raw_inode);\n\n\tif (befs_check_inode(sb, raw_inode, inode->i_ino) != BEFS_OK) {\n\t\tbefs_error(sb, \"Bad inode: %lu\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tinode->i_mode = (umode_t) fs32_to_cpu(sb, raw_inode->mode);\n\n\t/*\n\t * set uid and gid.  But since current BeOS is single user OS, so\n\t * you can change by \"uid\" or \"gid\" options.\n\t */   \n\n\tinode->i_uid = befs_sb->mount_opts.use_uid ?\n\t\tbefs_sb->mount_opts.uid :\n\t\tmake_kuid(&init_user_ns, fs32_to_cpu(sb, raw_inode->uid));\n\tinode->i_gid = befs_sb->mount_opts.use_gid ?\n\t\tbefs_sb->mount_opts.gid :\n\t\tmake_kgid(&init_user_ns, fs32_to_cpu(sb, raw_inode->gid));\n\n\tset_nlink(inode, 1);\n\n\t/*\n\t * BEFS's time is 64 bits, but current VFS is 32 bits...\n\t * BEFS don't have access time. Nor inode change time. VFS\n\t * doesn't have creation time.\n\t * Also, the lower 16 bits of the last_modified_time and \n\t * create_time are just a counter to help ensure uniqueness\n\t * for indexing purposes. (PFD, page 54)\n\t */\n\n\tinode->i_mtime.tv_sec =\n\t    fs64_to_cpu(sb, raw_inode->last_modified_time) >> 16;\n\tinode->i_mtime.tv_nsec = 0;   /* lower 16 bits are not a time */\t\n\tinode->i_ctime = inode->i_mtime;\n\tinode->i_atime = inode->i_mtime;\n\n\tbefs_ino->i_inode_num = fsrun_to_cpu(sb, raw_inode->inode_num);\n\tbefs_ino->i_parent = fsrun_to_cpu(sb, raw_inode->parent);\n\tbefs_ino->i_attribute = fsrun_to_cpu(sb, raw_inode->attributes);\n\tbefs_ino->i_flags = fs32_to_cpu(sb, raw_inode->flags);\n\n\tif (S_ISLNK(inode->i_mode) && !(befs_ino->i_flags & BEFS_LONG_SYMLINK)){\n\t\tinode->i_size = 0;\n\t\tinode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;\n\t\tstrlcpy(befs_ino->i_data.symlink, raw_inode->data.symlink,\n\t\t\tBEFS_SYMLINK_LEN);\n\t} else {\n\t\tint num_blks;\n\n\t\tbefs_ino->i_data.ds =\n\t\t    fsds_to_cpu(sb, &raw_inode->data.datastream);\n\n\t\tnum_blks = befs_count_blocks(sb, &befs_ino->i_data.ds);\n\t\tinode->i_blocks =\n\t\t    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);\n\t\tinode->i_size = befs_ino->i_data.ds.size;\n\t}\n\n\tinode->i_mapping->a_ops = &befs_aops;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &befs_dir_inode_operations;\n\t\tinode->i_fop = &befs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (befs_ino->i_flags & BEFS_LONG_SYMLINK)\n\t\t\tinode->i_op = &befs_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &befs_fast_symlink_inode_operations;\n\t} else {\n\t\tbefs_error(sb, \"Inode %lu is not a regular file, \"\n\t\t\t   \"directory or symlink. THAT IS WRONG! BeFS has no \"\n\t\t\t   \"on disk special files\", inode->i_ino);\n\t\tgoto unacquire_bh;\n\t}\n\n\tbrelse(bh);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tunlock_new_inode(inode);\n\treturn inode;\n\n      unacquire_bh:\n\tbrelse(bh);\n\n      unacquire_none:\n\tiget_failed(inode);\n\tbefs_debug(sb, \"<--- %s - Bad inode\", __func__);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODATA"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_warning",
          "args": [
            "sb",
            "\"<--- %s Error\"",
            "__func__"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_btree_find",
          "args": [
            "sb",
            "ds",
            "dentry->d_name.name",
            "&offset"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "befs_btree_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/btree.c",
          "lines": "249-318",
          "snippet": "int\nbefs_btree_find(struct super_block *sb, befs_data_stream * ds,\n\t\tconst char *key, befs_off_t * value)\n{\n\tstruct befs_btree_node *this_node = NULL;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off;\n\tint res;\n\n\tbefs_debug(sb, \"---> %s Key: %s\", __func__, key);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_find() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node),\n\t\t\t\t\t\tGFP_NOFS);\n\tif (!this_node) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tthis_node->bh = NULL;\n\n\t/* read in root node */\n\tnode_off = bt_super.root_node_ptr;\n\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t   \"node at %llu\", node_off);\n\t\tgoto error_alloc;\n\t}\n\n\twhile (!befs_leafnode(this_node)) {\n\t\tres = befs_find_key(sb, this_node, key, &node_off);\n\t\tif (res == BEFS_BT_NOT_FOUND)\n\t\t\tnode_off = this_node->head.overflow;\n\t\t/* if no match, go to overflow node */\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t\t   \"node at %llu\", node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t/* at the correct leaf node now */\n\n\tres = befs_find_key(sb, this_node, key, value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tif (res != BEFS_BT_MATCH) {\n\t\tbefs_debug(sb, \"<--- %s Key %s not found\", __func__, key);\n\t\t*value = 0;\n\t\treturn BEFS_BT_NOT_FOUND;\n\t}\n\tbefs_debug(sb, \"<--- %s Found key %s, value %llu\", __func__,\n\t\t   key, *value);\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n      error:\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}",
          "includes": [
            "#include \"datastream.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int befs_btree_seekleaf(struct super_block *sb, befs_data_stream * ds,\n\t\t\t       befs_btree_super * bt_super,\n\t\t\t       struct befs_btree_node *this_node,\n\t\t\t       befs_off_t * node_off);",
            "static int befs_bt_read_node(struct super_block *sb, befs_data_stream * ds,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     befs_off_t node_off);",
            "static int befs_leafnode(struct befs_btree_node *node);",
            "static fs16 *befs_bt_keylen_index(struct befs_btree_node *node);",
            "static fs64 *befs_bt_valarray(struct befs_btree_node *node);",
            "static char *befs_bt_keydata(struct befs_btree_node *node);",
            "static int befs_find_key(struct super_block *sb,\n\t\t\t struct befs_btree_node *node,\n\t\t\t const char *findkey, befs_off_t * value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"datastream.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int befs_btree_seekleaf(struct super_block *sb, befs_data_stream * ds,\n\t\t\t       befs_btree_super * bt_super,\n\t\t\t       struct befs_btree_node *this_node,\n\t\t\t       befs_off_t * node_off);\nstatic int befs_bt_read_node(struct super_block *sb, befs_data_stream * ds,\n\t\t\t     struct befs_btree_node *node,\n\t\t\t     befs_off_t node_off);\nstatic int befs_leafnode(struct befs_btree_node *node);\nstatic fs16 *befs_bt_keylen_index(struct befs_btree_node *node);\nstatic fs64 *befs_bt_valarray(struct befs_btree_node *node);\nstatic char *befs_bt_keydata(struct befs_btree_node *node);\nstatic int befs_find_key(struct super_block *sb,\n\t\t\t struct befs_btree_node *node,\n\t\t\t const char *findkey, befs_off_t * value);\n\nint\nbefs_btree_find(struct super_block *sb, befs_data_stream * ds,\n\t\tconst char *key, befs_off_t * value)\n{\n\tstruct befs_btree_node *this_node = NULL;\n\tbefs_btree_super bt_super;\n\tbefs_off_t node_off;\n\tint res;\n\n\tbefs_debug(sb, \"---> %s Key: %s\", __func__, key);\n\n\tif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_btree_find() failed to read index superblock\");\n\t\tgoto error;\n\t}\n\n\tthis_node = kmalloc(sizeof(struct befs_btree_node),\n\t\t\t\t\t\tGFP_NOFS);\n\tif (!this_node) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to allocate %zu \"\n\t\t\t   \"bytes of memory\", sizeof(struct befs_btree_node));\n\t\tgoto error;\n\t}\n\n\tthis_node->bh = NULL;\n\n\t/* read in root node */\n\tnode_off = bt_super.root_node_ptr;\n\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t   \"node at %llu\", node_off);\n\t\tgoto error_alloc;\n\t}\n\n\twhile (!befs_leafnode(this_node)) {\n\t\tres = befs_find_key(sb, this_node, key, &node_off);\n\t\tif (res == BEFS_BT_NOT_FOUND)\n\t\t\tnode_off = this_node->head.overflow;\n\t\t/* if no match, go to overflow node */\n\t\tif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\n\t\t\tbefs_error(sb, \"befs_btree_find() failed to read \"\n\t\t\t\t   \"node at %llu\", node_off);\n\t\t\tgoto error_alloc;\n\t\t}\n\t}\n\n\t/* at the correct leaf node now */\n\n\tres = befs_find_key(sb, this_node, key, value);\n\n\tbrelse(this_node->bh);\n\tkfree(this_node);\n\n\tif (res != BEFS_BT_MATCH) {\n\t\tbefs_debug(sb, \"<--- %s Key %s not found\", __func__, key);\n\t\t*value = 0;\n\t\treturn BEFS_BT_NOT_FOUND;\n\t}\n\tbefs_debug(sb, \"<--- %s Found key %s, value %llu\", __func__,\n\t\t   key, *value);\n\treturn BEFS_OK;\n\n      error_alloc:\n\tkfree(this_node);\n      error:\n\t*value = 0;\n\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\treturn BEFS_ERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utfname"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "befs_nls2utf",
          "args": [
            "sb",
            "name",
            "strlen(name)",
            "&utfname",
            "&utfnamelen"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "befs_nls2utf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
          "lines": "598-653",
          "snippet": "static int\nbefs_nls2utf(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\twchar_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* There're nls characters that will translate to 3-chars-wide UTF-8\n\t * characters, a additional byte is needed to save the final \\0\n\t * in special cases */\n\tint maxlen = (3 * in_len) + 1;\n\n\tbefs_debug(sb, \"---> %s\\n\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded.\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\n\n\t\t/* convert from nls to unicode */\n\t\tunilen = nls->char2uni(&in[i], in_len - i, &uni);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from unicode to UTF-8 */\n\t\tutflen = utf32_to_utf8(uni, &result[o], 3);\n\t\tif (utflen <= 0)\n\t\t\tgoto conv_err;\n\t}\n\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn i;\n\n      conv_err:\n\tbefs_error(sb, \"Name using charecter set %s contains a charecter that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"super.h\"",
            "#include \"datastream.h\"",
            "#include \"inode.h\"",
            "#include \"btree.h\"",
            "#include \"befs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *befs_iget(struct super_block *, unsigned long);",
            "static struct inode *befs_alloc_inode(struct super_block *sb);",
            "static int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
            "static int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);",
            "static void befs_put_super(struct super_block *);",
            "static int befs_remount(struct super_block *, int *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic int befs_utf2nls(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic int befs_nls2utf(struct super_block *sb, const char *in, int in_len,\n\t\t\tchar **out, int *out_len);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_nls2utf(struct super_block *sb, const char *in,\n\t     int in_len, char **out, int *out_len)\n{\n\tstruct nls_table *nls = BEFS_SB(sb)->nls;\n\tint i, o;\n\twchar_t uni;\n\tint unilen, utflen;\n\tchar *result;\n\t/* There're nls characters that will translate to 3-chars-wide UTF-8\n\t * characters, a additional byte is needed to save the final \\0\n\t * in special cases */\n\tint maxlen = (3 * in_len) + 1;\n\n\tbefs_debug(sb, \"---> %s\\n\", __func__);\n\n\tif (!nls) {\n\t\tbefs_error(sb, \"%s called with no NLS table loaded.\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*out = result = kmalloc(maxlen, GFP_NOFS);\n\tif (!*out) {\n\t\tbefs_error(sb, \"%s cannot allocate memory\", __func__);\n\t\t*out_len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = o = 0; i < in_len; i += unilen, o += utflen) {\n\n\t\t/* convert from nls to unicode */\n\t\tunilen = nls->char2uni(&in[i], in_len - i, &uni);\n\t\tif (unilen < 0)\n\t\t\tgoto conv_err;\n\n\t\t/* convert from unicode to UTF-8 */\n\t\tutflen = utf32_to_utf8(uni, &result[o], 3);\n\t\tif (utflen <= 0)\n\t\t\tgoto conv_err;\n\t}\n\n\tresult[o] = '\\0';\n\t*out_len = o;\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn i;\n\n      conv_err:\n\tbefs_error(sb, \"Name using charecter set %s contains a charecter that \"\n\t\t   \"cannot be converted to unicode.\", nls->charset);\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\tkfree(result);\n\treturn -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "dir"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic struct dentry *befs_lookup(struct inode *, struct dentry *, unsigned int);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic struct dentry *\nbefs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = dir->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(dir)->i_data.ds;\n\tbefs_off_t offset;\n\tint ret;\n\tint utfnamelen;\n\tchar *utfname;\n\tconst char *name = dentry->d_name.name;\n\n\tbefs_debug(sb, \"---> %s name %pd inode %ld\", __func__,\n\t\t   dentry, dir->i_ino);\n\n\t/* Convert to UTF-8 */\n\tif (BEFS_SB(sb)->nls) {\n\t\tret =\n\t\t    befs_nls2utf(sb, name, strlen(name), &utfname, &utfnamelen);\n\t\tif (ret < 0) {\n\t\t\tbefs_debug(sb, \"<--- %s ERROR\", __func__);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t\tret = befs_btree_find(sb, ds, utfname, &offset);\n\t\tkfree(utfname);\n\n\t} else {\n\t\tret = befs_btree_find(sb, ds, dentry->d_name.name, &offset);\n\t}\n\n\tif (ret == BEFS_BT_NOT_FOUND) {\n\t\tbefs_debug(sb, \"<--- %s %pd not found\", __func__, dentry);\n\t\treturn ERR_PTR(-ENOENT);\n\n\t} else if (ret != BEFS_OK || offset == 0) {\n\t\tbefs_warning(sb, \"<--- %s Error\", __func__);\n\t\treturn ERR_PTR(-ENODATA);\n\t}\n\n\tinode = befs_iget(dir->i_sb, (ino_t) offset);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\td_add(dentry, inode);\n\n\tbefs_debug(sb, \"<--- %s\", __func__);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "befs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "124-161",
    "snippet": "static int\nbefs_get_block(struct inode *inode, sector_t block,\n\t       struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_block_run run = BAD_IADDR;\n\tint res = 0;\n\tulong disk_off;\n\n\tbefs_debug(sb, \"---> befs_get_block() for inode %lu, block %ld\",\n\t\t   (unsigned long)inode->i_ino, (long)block);\n\tif (create) {\n\t\tbefs_error(sb, \"befs_get_block() was asked to write to \"\n\t\t\t   \"block %ld in inode %lu\", (long)block,\n\t\t\t   (unsigned long)inode->i_ino);\n\t\treturn -EPERM;\n\t}\n\n\tres = befs_fblock2brun(sb, ds, block, &run);\n\tif (res != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"<--- %s for inode %lu, block %ld ERROR\",\n\t\t\t   __func__, (unsigned long)inode->i_ino,\n\t\t\t   (long)block);\n\t\treturn -EFBIG;\n\t}\n\n\tdisk_off = (ulong) iaddr2blockno(sb, &run);\n\n\tmap_bh(bh_result, inode->i_sb, disk_off);\n\n\tbefs_debug(sb, \"<--- %s for inode %lu, block %ld, disk address %lu\",\n\t\t  __func__, (unsigned long)inode->i_ino, (long)block,\n\t\t  (unsigned long)disk_off);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);",
      "static sector_t befs_bmap(struct address_space *mapping, sector_t block);",
      "static struct inode *befs_iget(struct super_block *, unsigned long);",
      "static struct inode *befs_alloc_inode(struct super_block *sb);",
      "static void befs_destroy_inode(struct inode *inode);",
      "static void befs_put_super(struct super_block *);",
      "static int befs_remount(struct super_block *, int *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_debug",
          "args": [
            "sb",
            "\"<--- %s for inode %lu, block %ld, disk address %lu\"",
            "__func__",
            "(unsigned long)inode->i_ino",
            "(long)block",
            "(unsigned long)disk_off"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "disk_off"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iaddr2blockno",
          "args": [
            "sb",
            "&run"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "iaddr2blockno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "120-125",
          "snippet": "static inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_blocknr_t\niaddr2blockno(struct super_block *sb, befs_inode_addr * iaddr)\n{\n\treturn ((iaddr->allocation_group << BEFS_SB(sb)->ag_shift) +\n\t\tiaddr->start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"<--- %s for inode %lu, block %ld ERROR\"",
            "__func__",
            "(unsigned long)inode->i_ino",
            "(long)block"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "befs_fblock2brun",
          "args": [
            "sb",
            "ds",
            "block",
            "&run"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "befs_fblock2brun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/datastream.c",
          "lines": "89-113",
          "snippet": "int\nbefs_fblock2brun(struct super_block *sb, befs_data_stream * data,\n\t\t befs_blocknr_t fblock, befs_block_run * run)\n{\n\tint err;\n\tbefs_off_t pos = fblock << BEFS_SB(sb)->block_shift;\n\n\tif (pos < data->max_direct_range) {\n\t\terr = befs_find_brun_direct(sb, data, fblock, run);\n\n\t} else if (pos < data->max_indirect_range) {\n\t\terr = befs_find_brun_indirect(sb, data, fblock, run);\n\n\t} else if (pos < data->max_double_indirect_range) {\n\t\terr = befs_find_brun_dblindirect(sb, data, fblock, run);\n\n\t} else {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_fblock2brun() was asked to find block %lu, \"\n\t\t\t   \"which is not mapped by the datastream\\n\",\n\t\t\t   (unsigned long)fblock);\n\t\terr = BEFS_ERR;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"io.h\"",
            "#include \"datastream.h\"",
            "#include \"befs.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int befs_find_brun_direct(struct super_block *sb,\n\t\t\t\t befs_data_stream * data,\n\t\t\t\t befs_blocknr_t blockno, befs_block_run * run);",
            "static int befs_find_brun_indirect(struct super_block *sb,\n\t\t\t\t   befs_data_stream * data,\n\t\t\t\t   befs_blocknr_t blockno,\n\t\t\t\t   befs_block_run * run);",
            "static int befs_find_brun_dblindirect(struct super_block *sb,\n\t\t\t\t      befs_data_stream * data,\n\t\t\t\t      befs_blocknr_t blockno,\n\t\t\t\t      befs_block_run * run);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"io.h\"\n#include \"datastream.h\"\n#include \"befs.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic int befs_find_brun_direct(struct super_block *sb,\n\t\t\t\t befs_data_stream * data,\n\t\t\t\t befs_blocknr_t blockno, befs_block_run * run);\nstatic int befs_find_brun_indirect(struct super_block *sb,\n\t\t\t\t   befs_data_stream * data,\n\t\t\t\t   befs_blocknr_t blockno,\n\t\t\t\t   befs_block_run * run);\nstatic int befs_find_brun_dblindirect(struct super_block *sb,\n\t\t\t\t      befs_data_stream * data,\n\t\t\t\t      befs_blocknr_t blockno,\n\t\t\t\t      befs_block_run * run);\n\nint\nbefs_fblock2brun(struct super_block *sb, befs_data_stream * data,\n\t\t befs_blocknr_t fblock, befs_block_run * run)\n{\n\tint err;\n\tbefs_off_t pos = fblock << BEFS_SB(sb)->block_shift;\n\n\tif (pos < data->max_direct_range) {\n\t\terr = befs_find_brun_direct(sb, data, fblock, run);\n\n\t} else if (pos < data->max_indirect_range) {\n\t\terr = befs_find_brun_indirect(sb, data, fblock, run);\n\n\t} else if (pos < data->max_double_indirect_range) {\n\t\terr = befs_find_brun_dblindirect(sb, data, fblock, run);\n\n\t} else {\n\t\tbefs_error(sb,\n\t\t\t   \"befs_fblock2brun() was asked to find block %lu, \"\n\t\t\t   \"which is not mapped by the datastream\\n\",\n\t\t\t   (unsigned long)fblock);\n\t\terr = BEFS_ERR;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_I",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "114-118",
          "snippet": "static inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_inode_info *\nBEFS_I(const struct inode *inode)\n{\n\treturn list_entry(inode, struct befs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int befs_get_block(struct inode *, sector_t, struct buffer_head *, int);\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\nstatic struct inode *befs_iget(struct super_block *, unsigned long);\nstatic struct inode *befs_alloc_inode(struct super_block *sb);\nstatic void befs_destroy_inode(struct inode *inode);\nstatic void befs_put_super(struct super_block *);\nstatic int befs_remount(struct super_block *, int *, char *);\n\nstatic int\nbefs_get_block(struct inode *inode, sector_t block,\n\t       struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tbefs_data_stream *ds = &BEFS_I(inode)->i_data.ds;\n\tbefs_block_run run = BAD_IADDR;\n\tint res = 0;\n\tulong disk_off;\n\n\tbefs_debug(sb, \"---> befs_get_block() for inode %lu, block %ld\",\n\t\t   (unsigned long)inode->i_ino, (long)block);\n\tif (create) {\n\t\tbefs_error(sb, \"befs_get_block() was asked to write to \"\n\t\t\t   \"block %ld in inode %lu\", (long)block,\n\t\t\t   (unsigned long)inode->i_ino);\n\t\treturn -EPERM;\n\t}\n\n\tres = befs_fblock2brun(sb, ds, block, &run);\n\tif (res != BEFS_OK) {\n\t\tbefs_error(sb,\n\t\t\t   \"<--- %s for inode %lu, block %ld ERROR\",\n\t\t\t   __func__, (unsigned long)inode->i_ino,\n\t\t\t   (long)block);\n\t\treturn -EFBIG;\n\t}\n\n\tdisk_off = (ulong) iaddr2blockno(sb, &run);\n\n\tmap_bh(bh_result, inode->i_sb, disk_off);\n\n\tbefs_debug(sb, \"<--- %s for inode %lu, block %ld, disk address %lu\",\n\t\t  __func__, (unsigned long)inode->i_ino, (long)block,\n\t\t  (unsigned long)disk_off);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "befs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "107-111",
    "snippet": "static sector_t\nbefs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, befs_get_block);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sector_t befs_bmap(struct address_space *mapping, sector_t block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "befs_get_block"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic sector_t befs_bmap(struct address_space *mapping, sector_t block);\n\nstatic sector_t\nbefs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, befs_get_block);\n}"
  },
  {
    "function_name": "befs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/linuxvfs.c",
    "lines": "101-105",
    "snippet": "static int\nbefs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, befs_get_block);\n}",
    "includes": [
      "#include \"io.h\"",
      "#include \"super.h\"",
      "#include \"datastream.h\"",
      "#include \"inode.h\"",
      "#include \"btree.h\"",
      "#include \"befs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int befs_readpage(struct file *file, struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "befs_get_block"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"io.h\"\n#include \"super.h\"\n#include \"datastream.h\"\n#include \"inode.h\"\n#include \"btree.h\"\n#include \"befs.h\"\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int befs_readpage(struct file *file, struct page *page);\n\nstatic int\nbefs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, befs_get_block);\n}"
  }
]