[
  {
    "function_name": "exit_bfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "491-495",
    "snippet": "static void __exit exit_bfs_fs(void)\n{\n\tunregister_filesystem(&bfs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type bfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bfs\",\n\t.mount\t\t= bfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "279-287",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *bfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&bfs_fs_type"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct file_system_type bfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bfs\",\n\t.mount\t\t= bfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_bfs_fs(void)\n{\n\tunregister_filesystem(&bfs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_bfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "476-489",
    "snippet": "static int __init init_bfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&bfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type bfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bfs\",\n\t.mount\t\t= bfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "279-287",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *bfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&bfs_fs_type"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "267-277",
          "snippet": "static int __init init_inodecache(void)\n{\n\tbfs_inode_cachep = kmem_cache_create(\"bfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct bfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (bfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *bfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tbfs_inode_cachep = kmem_cache_create(\"bfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct bfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (bfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct file_system_type bfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bfs\",\n\t.mount\t\t= bfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_bfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&bfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "bfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "461-465",
    "snippet": "static struct dentry *bfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, bfs_fill_super);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "bfs_fill_super"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct dentry *bfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, bfs_fill_super);\n}"
  },
  {
    "function_name": "bfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "319-459",
    "snippet": "static int bfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh, *sbh;\n\tstruct bfs_super_block *bfs_sb;\n\tstruct inode *inode;\n\tunsigned i, imap_len;\n\tstruct bfs_sb_info *info;\n\tint ret = -EINVAL;\n\tunsigned long i_sblock, i_eblock, i_eoff, s_size;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmutex_init(&info->bfs_lock);\n\ts->s_fs_info = info;\n\n\tsb_set_blocksize(s, BFS_BSIZE);\n\n\tsbh = sb_bread(s, 0);\n\tif (!sbh)\n\t\tgoto out;\n\tbfs_sb = (struct bfs_super_block *)sbh->b_data;\n\tif (le32_to_cpu(bfs_sb->s_magic) != BFS_MAGIC) {\n\t\tif (!silent)\n\t\t\tprintf(\"No BFS filesystem on %s (magic=%08x)\\n\", \n\t\t\t\ts->s_id,  le32_to_cpu(bfs_sb->s_magic));\n\t\tgoto out1;\n\t}\n\tif (BFS_UNCLEAN(bfs_sb, s) && !silent)\n\t\tprintf(\"%s is unclean, continuing\\n\", s->s_id);\n\n\ts->s_magic = BFS_MAGIC;\n\n\tif (le32_to_cpu(bfs_sb->s_start) > le32_to_cpu(bfs_sb->s_end)) {\n\t\tprintf(\"Superblock is corrupted\\n\");\n\t\tgoto out1;\n\t}\n\n\tinfo->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) /\n\t\t\t\t\tsizeof(struct bfs_inode)\n\t\t\t\t\t+ BFS_ROOT_INO - 1;\n\timap_len = (info->si_lasti / 8) + 1;\n\tinfo->si_imap = kzalloc(imap_len, GFP_KERNEL);\n\tif (!info->si_imap)\n\t\tgoto out1;\n\tfor (i = 0; i < BFS_ROOT_INO; i++)\n\t\tset_bit(i, info->si_imap);\n\n\ts->s_op = &bfs_sops;\n\tinode = bfs_iget(s, BFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out2;\n\t}\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tinfo->si_blocks = (le32_to_cpu(bfs_sb->s_end) + 1) >> BFS_BSIZE_BITS;\n\tinfo->si_freeb = (le32_to_cpu(bfs_sb->s_end) + 1\n\t\t\t- le32_to_cpu(bfs_sb->s_start)) >> BFS_BSIZE_BITS;\n\tinfo->si_freei = 0;\n\tinfo->si_lf_eblk = 0;\n\n\t/* can we read the last block? */\n\tbh = sb_bread(s, info->si_blocks - 1);\n\tif (!bh) {\n\t\tprintf(\"Last block not available: %lu\\n\", info->si_blocks - 1);\n\t\tret = -EIO;\n\t\tgoto out3;\n\t}\n\tbrelse(bh);\n\n\tbh = NULL;\n\tfor (i = BFS_ROOT_INO; i <= info->si_lasti; i++) {\n\t\tstruct bfs_inode *di;\n\t\tint block = (i - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\t\tint off = (i - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\t\tunsigned long eblock;\n\n\t\tif (!off) {\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread(s, block);\n\t\t}\n\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\t\t/* test if filesystem is not corrupted */\n\n\t\ti_eoff = le32_to_cpu(di->i_eoffset);\n\t\ti_sblock = le32_to_cpu(di->i_sblock);\n\t\ti_eblock = le32_to_cpu(di->i_eblock);\n\t\ts_size = le32_to_cpu(bfs_sb->s_end);\n\n\t\tif (i_sblock > info->si_blocks ||\n\t\t\ti_eblock > info->si_blocks ||\n\t\t\ti_sblock > i_eblock ||\n\t\t\ti_eoff > s_size ||\n\t\t\ti_sblock * BFS_BSIZE > i_eoff) {\n\n\t\t\tprintf(\"Inode 0x%08x corrupted\\n\", i);\n\n\t\t\tbrelse(bh);\n\t\t\tret = -EIO;\n\t\t\tgoto out3;\n\t\t}\n\n\t\tif (!di->i_ino) {\n\t\t\tinfo->si_freei++;\n\t\t\tcontinue;\n\t\t}\n\t\tset_bit(i, info->si_imap);\n\t\tinfo->si_freeb -= BFS_FILEBLOCKS(di);\n\n\t\teblock =  le32_to_cpu(di->i_eblock);\n\t\tif (eblock > info->si_lf_eblk)\n\t\t\tinfo->si_lf_eblk = eblock;\n\t}\n\tbrelse(bh);\n\tbrelse(sbh);\n\tbfs_dump_imap(\"read_super\", s);\n\treturn 0;\n\nout3:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout2:\n\tkfree(info->si_imap);\nout1:\n\tbrelse(sbh);\nout:\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations bfs_sops = {\n\t.alloc_inode\t= bfs_alloc_inode,\n\t.destroy_inode\t= bfs_destroy_inode,\n\t.write_inode\t= bfs_write_inode,\n\t.evict_inode\t= bfs_evict_inode,\n\t.put_super\t= bfs_put_super,\n\t.statfs\t\t= bfs_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->si_imap"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "s->s_root"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_dump_imap",
          "args": [
            "\"read_super\"",
            "s"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_dump_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "298-317",
          "snippet": "void bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nvoid bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_eblock"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_FILEBLOCKS",
          "args": [
            "di"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "i",
            "info->si_imap"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Inode 0x%08x corrupted\\n\"",
            "i"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "block"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "info->si_blocks - 1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_iget",
          "args": [
            "s",
            "BFS_ROOT_INO"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "33-96",
          "snippet": "struct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstruct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "imap_len",
            "GFP_KERNEL"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Superblock is corrupted\\n\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_UNCLEAN",
          "args": [
            "bfs_sb",
            "s"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "BFS_BSIZE"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*info)",
            "GFP_KERNEL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic const struct super_operations bfs_sops = {\n\t.alloc_inode\t= bfs_alloc_inode,\n\t.destroy_inode\t= bfs_destroy_inode,\n\t.write_inode\t= bfs_write_inode,\n\t.evict_inode\t= bfs_evict_inode,\n\t.put_super\t= bfs_put_super,\n\t.statfs\t\t= bfs_statfs,\n};\n\nstatic int bfs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh, *sbh;\n\tstruct bfs_super_block *bfs_sb;\n\tstruct inode *inode;\n\tunsigned i, imap_len;\n\tstruct bfs_sb_info *info;\n\tint ret = -EINVAL;\n\tunsigned long i_sblock, i_eblock, i_eoff, s_size;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmutex_init(&info->bfs_lock);\n\ts->s_fs_info = info;\n\n\tsb_set_blocksize(s, BFS_BSIZE);\n\n\tsbh = sb_bread(s, 0);\n\tif (!sbh)\n\t\tgoto out;\n\tbfs_sb = (struct bfs_super_block *)sbh->b_data;\n\tif (le32_to_cpu(bfs_sb->s_magic) != BFS_MAGIC) {\n\t\tif (!silent)\n\t\t\tprintf(\"No BFS filesystem on %s (magic=%08x)\\n\", \n\t\t\t\ts->s_id,  le32_to_cpu(bfs_sb->s_magic));\n\t\tgoto out1;\n\t}\n\tif (BFS_UNCLEAN(bfs_sb, s) && !silent)\n\t\tprintf(\"%s is unclean, continuing\\n\", s->s_id);\n\n\ts->s_magic = BFS_MAGIC;\n\n\tif (le32_to_cpu(bfs_sb->s_start) > le32_to_cpu(bfs_sb->s_end)) {\n\t\tprintf(\"Superblock is corrupted\\n\");\n\t\tgoto out1;\n\t}\n\n\tinfo->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) /\n\t\t\t\t\tsizeof(struct bfs_inode)\n\t\t\t\t\t+ BFS_ROOT_INO - 1;\n\timap_len = (info->si_lasti / 8) + 1;\n\tinfo->si_imap = kzalloc(imap_len, GFP_KERNEL);\n\tif (!info->si_imap)\n\t\tgoto out1;\n\tfor (i = 0; i < BFS_ROOT_INO; i++)\n\t\tset_bit(i, info->si_imap);\n\n\ts->s_op = &bfs_sops;\n\tinode = bfs_iget(s, BFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out2;\n\t}\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tinfo->si_blocks = (le32_to_cpu(bfs_sb->s_end) + 1) >> BFS_BSIZE_BITS;\n\tinfo->si_freeb = (le32_to_cpu(bfs_sb->s_end) + 1\n\t\t\t- le32_to_cpu(bfs_sb->s_start)) >> BFS_BSIZE_BITS;\n\tinfo->si_freei = 0;\n\tinfo->si_lf_eblk = 0;\n\n\t/* can we read the last block? */\n\tbh = sb_bread(s, info->si_blocks - 1);\n\tif (!bh) {\n\t\tprintf(\"Last block not available: %lu\\n\", info->si_blocks - 1);\n\t\tret = -EIO;\n\t\tgoto out3;\n\t}\n\tbrelse(bh);\n\n\tbh = NULL;\n\tfor (i = BFS_ROOT_INO; i <= info->si_lasti; i++) {\n\t\tstruct bfs_inode *di;\n\t\tint block = (i - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\t\tint off = (i - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\t\tunsigned long eblock;\n\n\t\tif (!off) {\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread(s, block);\n\t\t}\n\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\t\t/* test if filesystem is not corrupted */\n\n\t\ti_eoff = le32_to_cpu(di->i_eoffset);\n\t\ti_sblock = le32_to_cpu(di->i_sblock);\n\t\ti_eblock = le32_to_cpu(di->i_eblock);\n\t\ts_size = le32_to_cpu(bfs_sb->s_end);\n\n\t\tif (i_sblock > info->si_blocks ||\n\t\t\ti_eblock > info->si_blocks ||\n\t\t\ti_sblock > i_eblock ||\n\t\t\ti_eoff > s_size ||\n\t\t\ti_sblock * BFS_BSIZE > i_eoff) {\n\n\t\t\tprintf(\"Inode 0x%08x corrupted\\n\", i);\n\n\t\t\tbrelse(bh);\n\t\t\tret = -EIO;\n\t\t\tgoto out3;\n\t\t}\n\n\t\tif (!di->i_ino) {\n\t\t\tinfo->si_freei++;\n\t\t\tcontinue;\n\t\t}\n\t\tset_bit(i, info->si_imap);\n\t\tinfo->si_freeb -= BFS_FILEBLOCKS(di);\n\n\t\teblock =  le32_to_cpu(di->i_eblock);\n\t\tif (eblock > info->si_lf_eblk)\n\t\t\tinfo->si_lf_eblk = eblock;\n\t}\n\tbrelse(bh);\n\tbrelse(sbh);\n\tbfs_dump_imap(\"read_super\", s);\n\treturn 0;\n\nout3:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nout2:\n\tkfree(info->si_imap);\nout1:\n\tbrelse(sbh);\nout:\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "bfs_dump_imap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "298-317",
    "snippet": "void bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)tmpbuf"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"BFS-fs: %s: lasti=%08lx <%s>\\n\"",
            "prefix",
            "BFS_SB(s)->si_lasti",
            "tmpbuf"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "s"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmpbuf",
            "\"0\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmpbuf",
            "\"1\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "BFS_SB(s)->si_imap"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nvoid bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "279-287",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *bfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "bfs_inode_cachep"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(bfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "267-277",
    "snippet": "static int __init init_inodecache(void)\n{\n\tbfs_inode_cachep = kmem_cache_create(\"bfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct bfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (bfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *bfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"bfs_inode_cache\"",
            "sizeof(struct bfs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tbfs_inode_cachep = kmem_cache_create(\"bfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct bfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (bfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "260-265",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct bfs_inode_info *bi = foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&bi->vfs_inode"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct bfs_inode_info *bi = foo;\n\n\tinode_init_once(&bi->vfs_inode);\n}"
  },
  {
    "function_name": "bfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "255-258",
    "snippet": "static void bfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bfs_i_callback);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "bfs_i_callback"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic void bfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bfs_i_callback);\n}"
  },
  {
    "function_name": "bfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "249-253",
    "snippet": "static void bfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(bfs_inode_cachep, BFS_I(inode));\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *bfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "bfs_inode_cachep",
            "BFS_I(inode)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic void bfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(bfs_inode_cachep, BFS_I(inode));\n}"
  },
  {
    "function_name": "bfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "240-247",
    "snippet": "static struct inode *bfs_alloc_inode(struct super_block *sb)\n{\n\tstruct bfs_inode_info *bi;\n\tbi = kmem_cache_alloc(bfs_inode_cachep, GFP_KERNEL);\n\tif (!bi)\n\t\treturn NULL;\n\treturn &bi->vfs_inode;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *bfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "bfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *bfs_inode_cachep;\n\nstatic struct inode *bfs_alloc_inode(struct super_block *sb)\n{\n\tstruct bfs_inode_info *bi;\n\tbi = kmem_cache_alloc(bfs_inode_cachep, GFP_KERNEL);\n\tif (!bi)\n\t\treturn NULL;\n\treturn &bi->vfs_inode;\n}"
  },
  {
    "function_name": "bfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "221-236",
    "snippet": "static int bfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\tbuf->f_type = BFS_MAGIC;\n\tbuf->f_bsize = s->s_blocksize;\n\tbuf->f_blocks = info->si_blocks;\n\tbuf->f_bfree = buf->f_bavail = info->si_freeb;\n\tbuf->f_files = info->si_lasti + 1 - BFS_ROOT_INO;\n\tbuf->f_ffree = info->si_freei;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = BFS_NAMELEN;\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "s->s_bdev->bd_dev"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "s"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic int bfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\tbuf->f_type = BFS_MAGIC;\n\tbuf->f_bsize = s->s_blocksize;\n\tbuf->f_blocks = info->si_blocks;\n\tbuf->f_bfree = buf->f_bavail = info->si_freeb;\n\tbuf->f_files = info->si_lasti + 1 - BFS_ROOT_INO;\n\tbuf->f_ffree = info->si_freei;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = BFS_NAMELEN;\n\treturn 0;\n}"
  },
  {
    "function_name": "bfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "208-219",
    "snippet": "static void bfs_put_super(struct super_block *s)\n{\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\n\tif (!info)\n\t\treturn;\n\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info->si_imap);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->si_imap"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "s"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic void bfs_put_super(struct super_block *s)\n{\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\n\tif (!info)\n\t\treturn;\n\n\tmutex_destroy(&info->bfs_lock);\n\tkfree(info->si_imap);\n\tkfree(info);\n\ts->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "bfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "162-206",
    "snippet": "static void bfs_evict_inode(struct inode *inode)\n{\n\tunsigned long ino = inode->i_ino;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tstruct super_block *s = inode->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tstruct bfs_inode_info *bi = BFS_I(inode);\n\n\tdprintf(\"ino=%08lx\\n\", ino);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tdi = find_inode(s, inode->i_ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn;\n\n\tmutex_lock(&info->bfs_lock);\n\t/* clear on-disk inode */\n\tmemset(di, 0, sizeof(struct bfs_inode));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n        if (bi->i_dsk_ino) {\n\t\tif (bi->i_sblock)\n\t\t\tinfo->si_freeb += bi->i_eblock + 1 - bi->i_sblock;\n\t\tinfo->si_freei++;\n\t\tclear_bit(ino, info->si_imap);\n\t\tbfs_dump_imap(\"delete_inode\", s);\n        }\n\n\t/*\n\t * If this was the last file, make the previous block\n\t * \"last block of the last file\" even if there is no\n\t * real file there, saves us 1 gap.\n\t */\n\tif (info->si_lf_eblk == bi->i_eblock)\n\t\tinfo->si_lf_eblk = bi->i_sblock - 1;\n\tmutex_unlock(&info->bfs_lock);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_dump_imap",
          "args": [
            "\"delete_inode\"",
            "s"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_dump_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "298-317",
          "snippet": "void bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nvoid bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "ino",
            "info->si_imap"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "di",
            "0",
            "sizeof(struct bfs_inode)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "s",
            "inode->i_ino",
            "&bh"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "98-114",
          "snippet": "static struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"ino=%08lx\\n\"",
            "ino"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "s"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic void bfs_evict_inode(struct inode *inode)\n{\n\tunsigned long ino = inode->i_ino;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tstruct super_block *s = inode->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tstruct bfs_inode_info *bi = BFS_I(inode);\n\n\tdprintf(\"ino=%08lx\\n\", ino);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tdi = find_inode(s, inode->i_ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn;\n\n\tmutex_lock(&info->bfs_lock);\n\t/* clear on-disk inode */\n\tmemset(di, 0, sizeof(struct bfs_inode));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n        if (bi->i_dsk_ino) {\n\t\tif (bi->i_sblock)\n\t\t\tinfo->si_freeb += bi->i_eblock + 1 - bi->i_sblock;\n\t\tinfo->si_freei++;\n\t\tclear_bit(ino, info->si_imap);\n\t\tbfs_dump_imap(\"delete_inode\", s);\n        }\n\n\t/*\n\t * If this was the last file, make the previous block\n\t * \"last block of the last file\" even if there is no\n\t * real file there, saves us 1 gap.\n\t */\n\tif (info->si_lf_eblk == bi->i_eblock)\n\t\tinfo->si_lf_eblk = bi->i_sblock - 1;\n\tmutex_unlock(&info->bfs_lock);\n}"
  },
  {
    "function_name": "bfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "116-160",
    "snippet": "static int bfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tunsigned int ino = (u16)inode->i_ino;\n        unsigned long i_sblock;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n        dprintf(\"ino=%08x\\n\", ino);\n\n\tdi = find_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn PTR_ERR(di);\n\n\tmutex_lock(&info->bfs_lock);\n\n\tif (ino == BFS_ROOT_INO)\n\t\tdi->i_vtype = cpu_to_le32(BFS_VDIR);\n\telse\n\t\tdi->i_vtype = cpu_to_le32(BFS_VREG);\n\n\tdi->i_ino = cpu_to_le16(ino);\n\tdi->i_mode = cpu_to_le32(inode->i_mode);\n\tdi->i_uid = cpu_to_le32(i_uid_read(inode));\n\tdi->i_gid = cpu_to_le32(i_gid_read(inode));\n\tdi->i_nlink = cpu_to_le32(inode->i_nlink);\n\tdi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tdi->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\tdi->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n        i_sblock = BFS_I(inode)->i_sblock;\n\tdi->i_sblock = cpu_to_le32(i_sblock);\n\tdi->i_eblock = cpu_to_le32(BFS_I(inode)->i_eblock);\n\tdi->i_eoffset = cpu_to_le32(i_sblock * BFS_BSIZE + inode->i_size - 1);\n\n\tmark_buffer_dirty(bh);\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_sblock * BFS_BSIZE + inode->i_size - 1"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BFS_I(inode)->i_eblock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_sblock"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_nlink"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mode"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ino"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BFS_VREG"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BFS_VDIR"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "inode->i_sb",
            "ino",
            "&bh"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "98-114",
          "snippet": "static struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"ino=%08x\\n\"",
            "ino"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic int bfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tunsigned int ino = (u16)inode->i_ino;\n        unsigned long i_sblock;\n\tstruct bfs_inode *di;\n\tstruct buffer_head *bh;\n\tint err = 0;\n\n        dprintf(\"ino=%08x\\n\", ino);\n\n\tdi = find_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(di))\n\t\treturn PTR_ERR(di);\n\n\tmutex_lock(&info->bfs_lock);\n\n\tif (ino == BFS_ROOT_INO)\n\t\tdi->i_vtype = cpu_to_le32(BFS_VDIR);\n\telse\n\t\tdi->i_vtype = cpu_to_le32(BFS_VREG);\n\n\tdi->i_ino = cpu_to_le16(ino);\n\tdi->i_mode = cpu_to_le32(inode->i_mode);\n\tdi->i_uid = cpu_to_le32(i_uid_read(inode));\n\tdi->i_gid = cpu_to_le32(i_gid_read(inode));\n\tdi->i_nlink = cpu_to_le32(inode->i_nlink);\n\tdi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\n\tdi->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\n\tdi->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\n        i_sblock = BFS_I(inode)->i_sblock;\n\tdi->i_sblock = cpu_to_le32(i_sblock);\n\tdi->i_eblock = cpu_to_le32(BFS_I(inode)->i_eblock);\n\tdi->i_eoffset = cpu_to_le32(i_sblock * BFS_BSIZE + inode->i_size - 1);\n\n\tmark_buffer_dirty(bh);\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "find_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "98-114",
    "snippet": "static struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unable to read inode %s:%08x\\n\"",
            "sb->s_id",
            "ino"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "1 + ino / BFS_INODES_PER_BLOCK"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "sb"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic struct bfs_inode *find_inode(struct super_block *sb, u16 ino, struct buffer_head **p)\n{\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tino -= BFS_ROOT_INO;\n\n\t*p = sb_bread(sb, 1 + ino / BFS_INODES_PER_BLOCK);\n\tif (!*p) {\n\t\tprintf(\"Unable to read inode %s:%08x\\n\", sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn (struct bfs_inode *)(*p)->b_data +  ino % BFS_INODES_PER_BLOCK;\n}"
  },
  {
    "function_name": "bfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
    "lines": "33-96",
    "snippet": "struct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_ctime"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_FILEBLOCKS",
          "args": [
            "di"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_FILESIZE",
          "args": [
            "di"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le32_to_cpu(di->i_nlink)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(di->i_gid)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(di->i_uid)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_ino"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "HUGETLBFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "60-63",
          "snippet": "static inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic inline struct hugetlbfs_inode_info *HUGETLBFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct hugetlbfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unable to read inode %s:%08lx\\n\"",
            "inode->i_sb->s_id",
            "ino"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstruct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
  }
]