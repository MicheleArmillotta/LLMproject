[
  {
    "function_name": "fat_sync_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "269-282",
    "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bhs[i]"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bhs[i]"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "bhs[i]",
            "WRITE"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fat_time_unix2fat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "231-266",
    "snippet": "void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SECS_PER_MIN\t60"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(127 << 9) | (12 << 5) | 31"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(23 << 11) | (59 << 5) | 29"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(0 << 9) | (1 << 5) | 1"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_to_tm",
          "args": [
            "ts->tv_sec",
            "(sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN",
            "&tm"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define SECS_PER_MIN\t60\n\nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}"
  },
  {
    "function_name": "fat_time_fat2unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "193-228",
    "snippet": "void fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 __time, __le16 __date, u8 time_cs)\n{\n\tu16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);\n\ttime_t second, day, leap_day, month, year;\n\n\tyear  = date >> 9;\n\tmonth = max(1, (date >> 5) & 0xf);\n\tday   = max(1, date & 0x1f) - 1;\n\n\tleap_day = (year + 3) / 4;\n\tif (year > YEAR_2100)\t\t/* 2100 isn't leap year */\n\t\tleap_day--;\n\tif (IS_LEAP_YEAR(year) && month > 2)\n\t\tleap_day++;\n\n\tsecond =  (time & 0x1f) << 1;\n\tsecond += ((time >> 5) & 0x3f) * SECS_PER_MIN;\n\tsecond += (time >> 11) * SECS_PER_HOUR;\n\tsecond += (year * 365 + leap_day\n\t\t   + days_in_year[month] + day\n\t\t   + DAYS_DELTA) * SECS_PER_DAY;\n\n\tif (!sbi->options.tz_set)\n\t\tsecond += sys_tz.tz_minuteswest * SECS_PER_MIN;\n\telse\n\t\tsecond -= sbi->options.time_offset * SECS_PER_MIN;\n\n\tif (time_cs) {\n\t\tts->tv_sec = second + (time_cs / 100);\n\t\tts->tv_nsec = (time_cs % 100) * 10000000;\n\t} else {\n\t\tts->tv_sec = second;\n\t\tts->tv_nsec = 0;\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define YEAR_2100\t120",
      "#define DAYS_DELTA\t(365 * 10 + 2)",
      "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
      "#define SECS_PER_HOUR\t(60 * 60)",
      "#define SECS_PER_MIN\t60"
    ],
    "globals_used": [
      "static time_t days_in_year[] = {\n\t/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */\n\t0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_LEAP_YEAR",
          "args": [
            "year"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "1",
            "date & 0x1f"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "__date"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define YEAR_2100\t120\n#define DAYS_DELTA\t(365 * 10 + 2)\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n#define SECS_PER_MIN\t60\n\nstatic time_t days_in_year[] = {\n\t/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */\n\t0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,\n};\n\nvoid fat_time_fat2unix(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 __time, __le16 __date, u8 time_cs)\n{\n\tu16 time = le16_to_cpu(__time), date = le16_to_cpu(__date);\n\ttime_t second, day, leap_day, month, year;\n\n\tyear  = date >> 9;\n\tmonth = max(1, (date >> 5) & 0xf);\n\tday   = max(1, date & 0x1f) - 1;\n\n\tleap_day = (year + 3) / 4;\n\tif (year > YEAR_2100)\t\t/* 2100 isn't leap year */\n\t\tleap_day--;\n\tif (IS_LEAP_YEAR(year) && month > 2)\n\t\tleap_day++;\n\n\tsecond =  (time & 0x1f) << 1;\n\tsecond += ((time >> 5) & 0x3f) * SECS_PER_MIN;\n\tsecond += (time >> 11) * SECS_PER_HOUR;\n\tsecond += (year * 365 + leap_day\n\t\t   + days_in_year[month] + day\n\t\t   + DAYS_DELTA) * SECS_PER_DAY;\n\n\tif (!sbi->options.tz_set)\n\t\tsecond += sys_tz.tz_minuteswest * SECS_PER_MIN;\n\telse\n\t\tsecond -= sbi->options.time_offset * SECS_PER_MIN;\n\n\tif (time_cs) {\n\t\tts->tv_sec = second + (time_cs / 100);\n\t\tts->tv_nsec = (time_cs % 100) * 10000000;\n\t} else {\n\t\tts->tv_sec = second;\n\t\tts->tv_nsec = 0;\n\t}\n}"
  },
  {
    "function_name": "fat_chain_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "103-165",
    "snippet": "int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_cache_inval_inode",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "205-210",
          "snippet": "void fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"clusters badly computed (%d != %llu)\"",
            "new_fclus",
            "(llu)(inode->i_blocks >> (sbi->cluster_bits - 9))"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "inode->i_blocks >> (sbi->cluster_bits - 9)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "&fatent"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_write",
          "args": [
            "inode",
            "&fatent",
            "new_dclus",
            "wait"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "409-423",
          "snippet": "int fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_needs_sync",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "inode_needs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1751-1758",
          "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_read",
          "args": [
            "inode",
            "&fatent",
            "last"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "639-650",
          "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_cluster",
          "args": [
            "inode",
            "FAT_ENT_EOF",
            "&fclus",
            "&dclus"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "226-285",
          "snippet": "int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint ret, new_fclus, last;\n\n\t/*\n\t * We must locate the last cluster of the file to add this new\n\t * one (new_dclus) to the end of the link list (the FAT).\n\t */\n\tlast = new_fclus = 0;\n\tif (MSDOS_I(inode)->i_start) {\n\t\tint fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, FAT_ENT_EOF, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_fclus = fclus + 1;\n\t\tlast = dclus;\n\t}\n\n\t/* add new one to the last of the cluster chain */\n\tif (last) {\n\t\tstruct fat_entry fatent;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, last);\n\t\tif (ret >= 0) {\n\t\t\tint wait = inode_needs_sync(inode);\n\t\t\tret = fat_ent_write(inode, &fatent, new_dclus, wait);\n\t\t\tfatent_brelse(&fatent);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * FIXME:Although we can add this cache, fat_cache_add() is\n\t\t * assuming to be called after linear search with fat_cache_id.\n\t\t */\n//\t\tfat_cache_add(inode, new_fclus, new_dclus);\n\t} else {\n\t\tMSDOS_I(inode)->i_start = new_dclus;\n\t\tMSDOS_I(inode)->i_logstart = new_dclus;\n\t\t/*\n\t\t * Since generic_write_sync() synchronizes regular files later,\n\t\t * we sync here only directories.\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode)) {\n\t\t\tret = fat_sync_inode(inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tmark_inode_dirty(inode);\n\t}\n\tif (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {\n\t\tfat_fs_error(sb, \"clusters badly computed (%d != %llu)\",\n\t\t\t     new_fclus,\n\t\t\t     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));\n\t\tfat_cache_inval_inode(inode);\n\t}\n\tinode->i_blocks += nr_cluster << (sbi->cluster_bits - 9);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_clusters_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "64-97",
    "snippet": "int fat_clusters_flush(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct fat_boot_fsinfo *fsinfo;\n\n\tif (sbi->fat_bits != 32)\n\t\treturn 0;\n\n\tbh = sb_bread(sb, sbi->fsinfo_sector);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"bread failed in fat_clusters_flush\");\n\t\treturn -EIO;\n\t}\n\n\tfsinfo = (struct fat_boot_fsinfo *)bh->b_data;\n\t/* Sanity check */\n\tif (!IS_FSINFO(fsinfo)) {\n\t\tfat_msg(sb, KERN_ERR, \"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t       sbi->fsinfo_sector);\n\t} else {\n\t\tif (sbi->free_clusters != -1)\n\t\t\tfsinfo->free_clusters = cpu_to_le32(sbi->free_clusters);\n\t\tif (sbi->prev_free != -1)\n\t\t\tfsinfo->next_cluster = cpu_to_le32(sbi->prev_free);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->prev_free"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->free_clusters"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\"",
            "le32_to_cpu(fsinfo->signature1)",
            "le32_to_cpu(fsinfo->signature2)",
            "sbi->fsinfo_sector"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fsinfo->signature2"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FSINFO",
          "args": [
            "fsinfo"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "sbi->fsinfo_sector"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_clusters_flush(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct fat_boot_fsinfo *fsinfo;\n\n\tif (sbi->fat_bits != 32)\n\t\treturn 0;\n\n\tbh = sb_bread(sb, sbi->fsinfo_sector);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"bread failed in fat_clusters_flush\");\n\t\treturn -EIO;\n\t}\n\n\tfsinfo = (struct fat_boot_fsinfo *)bh->b_data;\n\t/* Sanity check */\n\tif (!IS_FSINFO(fsinfo)) {\n\t\tfat_msg(sb, KERN_ERR, \"Invalid FSINFO signature: \"\n\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t       sbi->fsinfo_sector);\n\t} else {\n\t\tif (sbi->free_clusters != -1)\n\t\t\tfsinfo->free_clusters = cpu_to_le32(sbi->free_clusters);\n\t\tif (sbi->prev_free != -1)\n\t\t\tfsinfo->next_cluster = cpu_to_le32(sbi->prev_free);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "50-60",
    "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sFAT-fs (%s): %pV\\n\"",
            "level",
            "sb->s_id",
            "&vaf"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "__fat_fs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
    "lines": "23-43",
    "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/time.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Filesystem has been set read-only\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"FAT-fs (%s): fs panic from previous error\\n\"",
            "sb->s_id"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
  }
]