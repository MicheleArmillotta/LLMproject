[
  {
    "function_name": "ceph_fscache_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "396-402",
    "snippet": "void ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n\tci->fscache = NULL;\n\t/* The first load is verifed cookie open time */\n\tci->i_fscache_gen = 1;\n\tINIT_WORK(&ci->i_revalidate_work, ceph_revalidate_work);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ci->i_revalidate_work",
            "ceph_revalidate_work"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n\tci->fscache = NULL;\n\t/* The first load is verifed cookie open time */\n\tci->i_fscache_gen = 1;\n\tINIT_WORK(&ci->i_revalidate_work, ceph_revalidate_work);\n}"
  },
  {
    "function_name": "ceph_queue_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "377-394",
    "snippet": "void ceph_queue_revalidate(struct inode *inode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (fsc->revalidate_wq == NULL || ci->fscache == NULL)\n\t\treturn;\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->revalidate_wq,\n\t\t       &ci->i_revalidate_work)) {\n\t\tdout(\"ceph_queue_revalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_revalidate %p failed\\n)\", inode);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_revalidate %p failed\\n)\"",
            "inode"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_revalidate %p\\n\"",
            "inode"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ceph_sb_to_client(inode->i_sb)->revalidate_wq",
            "&ci->i_revalidate_work"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_queue_revalidate(struct inode *inode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (fsc->revalidate_wq == NULL || ci->fscache == NULL)\n\t\treturn;\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->revalidate_wq,\n\t\t       &ci->i_revalidate_work)) {\n\t\tdout(\"ceph_queue_revalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_revalidate %p failed\\n)\", inode);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "ceph_revalidate_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "344-375",
    "snippet": "static void ceph_revalidate_work(struct work_struct *work)\n{\n\tint issued;\n\tu32 orig_gen;\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_revalidate_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\torig_gen = ci->i_rdcache_gen;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (!(issued & CEPH_CAP_FILE_CACHE)) {\n\t\tdout(\"revalidate_work lost cache before validation %p\\n\",\n\t\t     inode);\n\t\tgoto out;\n\t}\n\n\tif (!fscache_check_consistency(ci->fscache))\n\t\tfscache_invalidate(ci->fscache);\n\n\tspin_lock(&ci->i_ceph_lock);\n\t/* Update the new valid generation (backwards sanity check too) */\n\tif (orig_gen > ci->i_fscache_gen) {\n\t\tci->i_fscache_gen = orig_gen;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\nout:\n\tiput(&ci->vfs_inode);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_invalidate",
          "args": [
            "ci->fscache"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_check_consistency",
          "args": [
            "ci->fscache"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_check_consistency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "653-721",
          "snippet": "int __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nint __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"revalidate_work lost cache before validation %p\\n\"",
            "inode"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structceph_inode_info",
            "i_revalidate_work"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic void ceph_revalidate_work(struct work_struct *work)\n{\n\tint issued;\n\tu32 orig_gen;\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_revalidate_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\torig_gen = ci->i_rdcache_gen;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (!(issued & CEPH_CAP_FILE_CACHE)) {\n\t\tdout(\"revalidate_work lost cache before validation %p\\n\",\n\t\t     inode);\n\t\tgoto out;\n\t}\n\n\tif (!fscache_check_consistency(ci->fscache))\n\t\tfscache_invalidate(ci->fscache);\n\n\tspin_lock(&ci->i_ceph_lock);\n\t/* Update the new valid generation (backwards sanity check too) */\n\tif (orig_gen > ci->i_fscache_gen) {\n\t\tci->i_fscache_gen = orig_gen;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\nout:\n\tiput(&ci->vfs_inode);\n}"
  },
  {
    "function_name": "ceph_fscache_unregister_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "335-342",
    "snippet": "void ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "fsc->fscache",
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "fsc->revalidate_wq"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n\tif (fsc->revalidate_wq)\n\t\tdestroy_workqueue(fsc->revalidate_wq);\n\n\tfscache_relinquish_cookie(fsc->fscache, 0);\n\tfsc->fscache = NULL;\n}"
  },
  {
    "function_name": "ceph_invalidate_fscache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "324-333",
    "snippet": "void ceph_invalidate_fscache_page(struct inode* inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tfscache_wait_on_page_write(ci->fscache, page);\n\tfscache_uncache_page(ci->fscache, page);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "ci->fscache",
            "page"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "120-123",
          "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_on_page_write",
          "args": [
            "ci->fscache",
            "page"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "408-414",
          "snippet": "void __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_invalidate_fscache_page(struct inode* inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tfscache_wait_on_page_write(ci->fscache, page);\n\tfscache_uncache_page(ci->fscache, page);\n}"
  },
  {
    "function_name": "ceph_readpage_to_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "308-322",
    "snippet": "void ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "ci->fscache",
            "page"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "120-123",
          "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_write_page",
          "args": [
            "ci->fscache",
            "page",
            "GFP_KERNEL"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "922-1052",
          "snippet": "int __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_valid",
          "args": [
            "ci"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "cache_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "241-245",
          "snippet": "static inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}"
  },
  {
    "function_name": "ceph_readpages_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "279-306",
    "snippet": "int ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(ci->fscache, mapping, pages, nr_pages,\n\t\t\t\t\t  ceph_vfs_readpage_complete_unlock,\n\t\t\t\t\t  NULL, mapping_gfp_mask(mapping));\n\n\tswitch (ret) {\n\t\tcase 0: /* All pages found */\n\t\t\tdout(\"all-page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Some pages were not found, and can't be */\n\t\tcase -ENODATA: /* some pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%s: unknown error ret = %i\\n\"",
            "__func__",
            "ret"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page/inode not in cache\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"all-page read submitted\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_pages",
          "args": [
            "ci->fscache",
            "mapping",
            "pages",
            "nr_pages",
            "ceph_vfs_readpage_complete_unlock",
            "NULL",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "532-642",
          "snippet": "int __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_valid",
          "args": [
            "ci"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "cache_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "241-245",
          "snippet": "static inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nint ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(ci->fscache, mapping, pages, nr_pages,\n\t\t\t\t\t  ceph_vfs_readpage_complete_unlock,\n\t\t\t\t\t  NULL, mapping_gfp_mask(mapping));\n\n\tswitch (ret) {\n\t\tcase 0: /* All pages found */\n\t\t\tdout(\"all-page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Some pages were not found, and can't be */\n\t\tcase -ENODATA: /* some pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}"
  },
  {
    "function_name": "ceph_readpage_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "253-277",
    "snippet": "int ceph_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(ci->fscache, page,\n\t\t\t\t\t ceph_vfs_readpage_complete, NULL,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\t\tcase 0: /* Page found */\n\t\t\tdout(\"page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Pages were not found, and can't be */\n\t\tcase -ENODATA: /* Pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%s: unknown error ret = %i\\n\"",
            "__func__",
            "ret"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page/inode not in cache\\n\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page read submitted\\n\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_page",
          "args": [
            "ci->fscache",
            "page",
            "ceph_vfs_readpage_complete",
            "NULL",
            "GFP_KERNEL"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "399-511",
          "snippet": "int __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_valid",
          "args": [
            "ci"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "cache_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "241-245",
          "snippet": "static inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nint ceph_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(ci->fscache, page,\n\t\t\t\t\t ceph_vfs_readpage_complete, NULL,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\t\tcase 0: /* Page found */\n\t\t\tdout(\"page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Pages were not found, and can't be */\n\t\tcase -ENODATA: /* Pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}"
  },
  {
    "function_name": "cache_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "241-245",
    "snippet": "static inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_caps_issued",
          "args": [
            "ci"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_issued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "531-538",
          "snippet": "static inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic inline int cache_valid(struct ceph_inode_info *ci)\n{\n\treturn ((ceph_caps_issued(ci) & CEPH_CAP_FILE_CACHE) &&\n\t\t(ci->i_fscache_gen == ci->i_rdcache_gen));\n}"
  },
  {
    "function_name": "ceph_vfs_readpage_complete_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "233-239",
    "snippet": "static void ceph_vfs_readpage_complete_unlock(struct page *page, void *data, int error)\n{\n\tif (!error)\n\t\tSetPageUptodate(page);\n\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic void ceph_vfs_readpage_complete_unlock(struct page *page, void *data, int error)\n{\n\tif (!error)\n\t\tSetPageUptodate(page);\n\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "ceph_vfs_readpage_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "227-231",
    "snippet": "static void ceph_vfs_readpage_complete(struct page *page, void *data, int error)\n{\n\tif (!error)\n\t\tSetPageUptodate(page);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic void ceph_vfs_readpage_complete(struct page *page, void *data, int error)\n{\n\tif (!error)\n\t\tSetPageUptodate(page);\n}"
  },
  {
    "function_name": "ceph_fscache_unregister_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "214-225",
    "snippet": "void ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n\tstruct fscache_cookie* cookie;\n\n\tif ((cookie = ci->fscache) == NULL)\n\t\treturn;\n\n\tci->fscache = NULL;\n\n\tfscache_uncache_all_inode_pages(cookie, &ci->vfs_inode);\n\tfscache_relinquish_cookie(cookie, 0);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "cookie",
            "0"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_uncache_all_inode_pages",
          "args": [
            "cookie",
            "&ci->vfs_inode"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_all_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1161-1194",
          "snippet": "void __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n\tstruct fscache_cookie* cookie;\n\n\tif ((cookie = ci->fscache) == NULL)\n\t\treturn;\n\n\tci->fscache = NULL;\n\n\tfscache_uncache_all_inode_pages(cookie, &ci->vfs_inode);\n\tfscache_relinquish_cookie(cookie, 0);\n}"
  },
  {
    "function_name": "ceph_fscache_register_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "186-212",
    "snippet": "void ceph_fscache_register_inode_cookie(struct ceph_fs_client* fsc,\n\t\t\t\t\tstruct ceph_inode_info* ci)\n{\n\tstruct inode* inode = &ci->vfs_inode;\n\n\t/* No caching for filesystem */\n\tif (fsc->fscache == NULL)\n\t\treturn;\n\n\t/* Only cache for regular files that are read only */\n\tif ((ci->vfs_inode.i_mode & S_IFREG) == 0)\n\t\treturn;\n\n\t/* Avoid multiple racing open requests */\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ci->fscache)\n\t\tgoto done;\n\n\tci->fscache = fscache_acquire_cookie(fsc->fscache,\n\t\t\t\t\t     &ceph_fscache_inode_object_def,\n\t\t\t\t\t     ci, true);\n\tfscache_check_consistency(ci->fscache);\ndone:\n\tmutex_unlock(&inode->i_mutex);\n\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fscache_cookie_def ceph_fscache_inode_object_def = {\n\t.name\t\t= \"CEPH.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= ceph_fscache_inode_get_key,\n\t.get_attr\t= ceph_fscache_inode_get_attr,\n\t.get_aux\t= ceph_fscache_inode_get_aux,\n\t.check_aux\t= ceph_fscache_inode_check_aux,\n\t.now_uncached\t= ceph_fscache_inode_now_uncached,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_check_consistency",
          "args": [
            "ci->fscache"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_check_consistency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "653-721",
          "snippet": "int __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nint __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "fsc->fscache",
            "&ceph_fscache_inode_object_def",
            "ci",
            "true"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic const struct fscache_cookie_def ceph_fscache_inode_object_def = {\n\t.name\t\t= \"CEPH.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= ceph_fscache_inode_get_key,\n\t.get_attr\t= ceph_fscache_inode_get_attr,\n\t.get_aux\t= ceph_fscache_inode_get_aux,\n\t.check_aux\t= ceph_fscache_inode_check_aux,\n\t.now_uncached\t= ceph_fscache_inode_now_uncached,\n};\n\nvoid ceph_fscache_register_inode_cookie(struct ceph_fs_client* fsc,\n\t\t\t\t\tstruct ceph_inode_info* ci)\n{\n\tstruct inode* inode = &ci->vfs_inode;\n\n\t/* No caching for filesystem */\n\tif (fsc->fscache == NULL)\n\t\treturn;\n\n\t/* Only cache for regular files that are read only */\n\tif ((ci->vfs_inode.i_mode & S_IFREG) == 0)\n\t\treturn;\n\n\t/* Avoid multiple racing open requests */\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ci->fscache)\n\t\tgoto done;\n\n\tci->fscache = fscache_acquire_cookie(fsc->fscache,\n\t\t\t\t\t     &ceph_fscache_inode_object_def,\n\t\t\t\t\t     ci, true);\n\tfscache_check_consistency(ci->fscache);\ndone:\n\tmutex_unlock(&inode->i_mutex);\n\n}"
  },
  {
    "function_name": "ceph_fscache_inode_now_uncached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "146-174",
    "snippet": "static void ceph_fscache_inode_now_uncached(void* cookie_netfs_data)\n{\n\tstruct ceph_inode_info* ci = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tdout(\"ceph inode 0x%p now uncached\", ci);\n\n\twhile (1) {\n\t\tnr_pages = pagevec_lookup(&pvec, ci->vfs_inode.i_mapping, first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageFsCache",
          "args": [
            "pvec.pages[loop]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "ci->vfs_inode.i_mapping",
            "first",
            "PAGEVEC_SIZE - pagevec_count(&pvec)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph inode 0x%p now uncached\"",
            "ci"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic void ceph_fscache_inode_now_uncached(void* cookie_netfs_data)\n{\n\tstruct ceph_inode_info* ci = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tdout(\"ceph inode 0x%p now uncached\", ci);\n\n\twhile (1) {\n\t\tnr_pages = pagevec_lookup(&pvec, ci->vfs_inode.i_mapping, first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "ceph_fscache_inode_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "125-144",
    "snippet": "static enum fscache_checkaux ceph_fscache_inode_check_aux(\n\tvoid *cookie_netfs_data, const void *data, uint16_t dlen)\n{\n\tstruct ceph_aux_inode aux;\n\tstruct ceph_inode_info* ci = cookie_netfs_data;\n\tstruct inode* inode = &ci->vfs_inode;\n\n\tif (dlen != sizeof(aux))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&aux, 0, sizeof(aux));\n\taux.mtime = inode->i_mtime;\n\taux.size = inode->i_size;\n\n\tif (memcmp(data, &aux, sizeof(aux)) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tdout(\"ceph inode 0x%p cached okay\", ci);\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph inode 0x%p cached okay\"",
            "ci"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data",
            "&aux",
            "sizeof(aux)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&aux",
            "0",
            "sizeof(aux)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic enum fscache_checkaux ceph_fscache_inode_check_aux(\n\tvoid *cookie_netfs_data, const void *data, uint16_t dlen)\n{\n\tstruct ceph_aux_inode aux;\n\tstruct ceph_inode_info* ci = cookie_netfs_data;\n\tstruct inode* inode = &ci->vfs_inode;\n\n\tif (dlen != sizeof(aux))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&aux, 0, sizeof(aux));\n\taux.mtime = inode->i_mtime;\n\taux.size = inode->i_size;\n\n\tif (memcmp(data, &aux, sizeof(aux)) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tdout(\"ceph inode 0x%p cached okay\", ci);\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "ceph_fscache_inode_get_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "116-123",
    "snippet": "static void ceph_fscache_inode_get_attr(const void *cookie_netfs_data,\n\t\t\t\t\tuint64_t *size)\n{\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tconst struct inode* inode = &ci->vfs_inode;\n\n\t*size = inode->i_size;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic void ceph_fscache_inode_get_attr(const void *cookie_netfs_data,\n\t\t\t\t\tuint64_t *size)\n{\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tconst struct inode* inode = &ci->vfs_inode;\n\n\t*size = inode->i_size;\n}"
  },
  {
    "function_name": "ceph_fscache_inode_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "100-114",
    "snippet": "static uint16_t ceph_fscache_inode_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t bufmax)\n{\n\tstruct ceph_aux_inode aux;\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tconst struct inode* inode = &ci->vfs_inode;\n\n\tmemset(&aux, 0, sizeof(aux));\n\taux.mtime = inode->i_mtime;\n\taux.size = inode->i_size;\n\n\tmemcpy(buffer, &aux, sizeof(aux));\n\n\treturn sizeof(aux);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&aux",
            "sizeof(aux)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&aux",
            "0",
            "sizeof(aux)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic uint16_t ceph_fscache_inode_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t bufmax)\n{\n\tstruct ceph_aux_inode aux;\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tconst struct inode* inode = &ci->vfs_inode;\n\n\tmemset(&aux, 0, sizeof(aux));\n\taux.mtime = inode->i_mtime;\n\taux.size = inode->i_size;\n\n\tmemcpy(buffer, &aux, sizeof(aux));\n\n\treturn sizeof(aux);\n}"
  },
  {
    "function_name": "ceph_fscache_inode_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "85-98",
    "snippet": "static uint16_t ceph_fscache_inode_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tuint16_t klen;\n\n\t/* use ceph virtual inode (id + snaphot) */\n\tklen = sizeof(ci->i_vino);\n\tif (klen > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, &ci->i_vino, klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&ci->i_vino",
            "klen"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic uint16_t ceph_fscache_inode_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct ceph_inode_info* ci = cookie_netfs_data;\n\tuint16_t klen;\n\n\t/* use ceph virtual inode (id + snaphot) */\n\tklen = sizeof(ci->i_vino);\n\tif (klen > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, &ci->i_vino, klen);\n\treturn klen;\n}"
  },
  {
    "function_name": "ceph_fscache_register_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "67-83",
    "snippet": "int ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\tfsc->fscache = fscache_acquire_cookie(ceph_cache_netfs.primary_index,\n\t\t\t\t\t      &ceph_fscache_fsid_object_def,\n\t\t\t\t\t      fsc, true);\n\n\tif (fsc->fscache == NULL) {\n\t\tpr_err(\"Unable to resgister fsid: %p fscache cookie\", fsc);\n\t\treturn 0;\n\t}\n\n\tfsc->revalidate_wq = alloc_workqueue(\"ceph-revalidate\", 0, 1);\n\tif (fsc->revalidate_wq == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};",
      "static const struct fscache_cookie_def ceph_fscache_fsid_object_def = {\n\t.name\t\t= \"CEPH.fsid\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= ceph_fscache_session_get_key,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"ceph-revalidate\"",
            "0",
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to resgister fsid: %p fscache cookie\"",
            "fsc"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "ceph_cache_netfs.primary_index",
            "&ceph_fscache_fsid_object_def",
            "fsc",
            "true"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\nstatic const struct fscache_cookie_def ceph_fscache_fsid_object_def = {\n\t.name\t\t= \"CEPH.fsid\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= ceph_fscache_session_get_key,\n};\n\nint ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\tfsc->fscache = fscache_acquire_cookie(ceph_cache_netfs.primary_index,\n\t\t\t\t\t      &ceph_fscache_fsid_object_def,\n\t\t\t\t\t      fsc, true);\n\n\tif (fsc->fscache == NULL) {\n\t\tpr_err(\"Unable to resgister fsid: %p fscache cookie\", fsc);\n\t\treturn 0;\n\t}\n\n\tfsc->revalidate_wq = alloc_workqueue(\"ceph-revalidate\", 0, 1);\n\tif (fsc->revalidate_wq == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_fscache_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "62-65",
    "snippet": "void ceph_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&ceph_cache_netfs);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_unregister_netfs",
          "args": [
            "&ceph_cache_netfs"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_unregister_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "88-103",
          "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\n\nvoid ceph_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&ceph_cache_netfs);\n}"
  },
  {
    "function_name": "ceph_fscache_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "57-60",
    "snippet": "int ceph_fscache_register(void)\n{\n\treturn fscache_register_netfs(&ceph_cache_netfs);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_register_netfs",
          "args": [
            "&ceph_cache_netfs"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_register_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "22-81",
          "snippet": "int __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fscache_netfs_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_netfs_list);\n\nint __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstruct fscache_netfs ceph_cache_netfs = {\n\t.name\t\t= \"ceph\",\n\t.version\t= 0,\n};\n\nint ceph_fscache_register(void)\n{\n\treturn fscache_register_netfs(&ceph_cache_netfs);\n}"
  },
  {
    "function_name": "ceph_fscache_session_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
    "lines": "37-49",
    "snippet": "static uint16_t ceph_fscache_session_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t     void *buffer, uint16_t maxbuf)\n{\n\tconst struct ceph_fs_client* fsc = cookie_netfs_data;\n\tuint16_t klen;\n\n\tklen = sizeof(fsc->client->fsid);\n\tif (klen > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, &fsc->client->fsid, klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"super.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&fsc->client->fsid",
            "klen"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic uint16_t ceph_fscache_session_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t     void *buffer, uint16_t maxbuf)\n{\n\tconst struct ceph_fs_client* fsc = cookie_netfs_data;\n\tuint16_t klen;\n\n\tklen = sizeof(fsc->client->fsid);\n\tif (klen > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, &fsc->client->fsid, klen);\n\treturn klen;\n}"
  }
]