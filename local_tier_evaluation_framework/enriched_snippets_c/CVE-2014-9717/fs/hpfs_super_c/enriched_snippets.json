[
  {
    "function_name": "exit_hpfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "745-749",
    "snippet": "static void __exit exit_hpfs_fs(void)\n{\n\tunregister_filesystem(&hpfs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hpfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hpfs\",\n\t.mount\t\t= hpfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "241-249",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * hpfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&hpfs_fs_type"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct file_system_type hpfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hpfs\",\n\t.mount\t\t= hpfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_hpfs_fs(void)\n{\n\tunregister_filesystem(&hpfs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_hpfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "730-743",
    "snippet": "static int __init init_hpfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&hpfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type hpfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hpfs\",\n\t.mount\t\t= hpfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "241-249",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * hpfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&hpfs_fs_type"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "229-239",
          "snippet": "static int init_inodecache(void)\n{\n\thpfs_inode_cachep = kmem_cache_create(\"hpfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct hpfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (hpfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * hpfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\thpfs_inode_cachep = kmem_cache_create(\"hpfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct hpfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (hpfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct file_system_type hpfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hpfs\",\n\t.mount\t\t= hpfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_hpfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&hpfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "715-719",
    "snippet": "static struct dentry *hpfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hpfs_fill_super);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "hpfs_fill_super"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct dentry *hpfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hpfs_fill_super);\n}"
  },
  {
    "function_name": "hpfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "487-713",
    "snippet": "static int hpfs_fill_super(struct super_block *s, void *options, int silent)\n{\n\tstruct buffer_head *bh0, *bh1, *bh2;\n\tstruct hpfs_boot_block *bootblock;\n\tstruct hpfs_super_block *superblock;\n\tstruct hpfs_spare_block *spareblock;\n\tstruct hpfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\n\tdnode_secno root_dno;\n\tstruct hpfs_dirent *de = NULL;\n\tstruct quad_buffer_head qbh;\n\n\tint o;\n\n\tsave_mount_options(s, options);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi) {\n\t\treturn -ENOMEM;\n\t}\n\ts->s_fs_info = sbi;\n\n\tmutex_init(&sbi->hpfs_mutex);\n\thpfs_lock(s);\n\n\tuid = current_uid();\n\tgid = current_gid();\n\tumask = current_umask();\n\tlowercase = 0;\n\teas = 2;\n\tchk = 1;\n\terrs = 1;\n\tchkdsk = 1;\n\ttimeshift = 0;\n\n\tif (!(o = parse_opts(options, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto bail0;\n\t}\n\tif (o==2) {\n\t\thpfs_help();\n\t\tgoto bail0;\n\t}\n\n\t/*sbi->sb_mounting = 1;*/\n\tsb_set_blocksize(s, 512);\n\tsbi->sb_fs_size = -1;\n\tif (!(bootblock = hpfs_map_sector(s, 0, &bh0, 0))) goto bail1;\n\tif (!(superblock = hpfs_map_sector(s, 16, &bh1, 1))) goto bail2;\n\tif (!(spareblock = hpfs_map_sector(s, 17, &bh2, 0))) goto bail3;\n\n\t/* Check magics */\n\tif (/*le16_to_cpu(bootblock->magic) != BB_MAGIC\n\t    ||*/ le32_to_cpu(superblock->magic) != SB_MAGIC\n\t    || le32_to_cpu(spareblock->magic) != SP_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"Bad magic ... probably not HPFS\\n\");\n\t\tgoto bail4;\n\t}\n\n\t/* Check version */\n\tif (!(s->s_flags & MS_RDONLY) &&\n\t      superblock->funcversion != 2 && superblock->funcversion != 3) {\n\t\tpr_err(\"Bad version %d,%d. Mount readonly to go around\\n\",\n\t\t\t(int)superblock->version, (int)superblock->funcversion);\n\t\tpr_err(\"please try recent version of HPFS driver at http://artax.karlin.mff.cuni.cz/~mikulas/vyplody/hpfs/index-e.cgi and if it still can't understand this format, contact author - mikulas@artax.karlin.mff.cuni.cz\\n\");\n\t\tgoto bail4;\n\t}\n\n\ts->s_flags |= MS_NOATIME;\n\n\t/* Fill superblock stuff */\n\ts->s_magic = HPFS_SUPER_MAGIC;\n\ts->s_op = &hpfs_sops;\n\ts->s_d_op = &hpfs_dentry_operations;\n\n\tsbi->sb_root = le32_to_cpu(superblock->root);\n\tsbi->sb_fs_size = le32_to_cpu(superblock->n_sectors);\n\tsbi->sb_bitmaps = le32_to_cpu(superblock->bitmaps);\n\tsbi->sb_dirband_start = le32_to_cpu(superblock->dir_band_start);\n\tsbi->sb_dirband_size = le32_to_cpu(superblock->n_dir_band);\n\tsbi->sb_dmap = le32_to_cpu(superblock->dir_band_bitmap);\n\tsbi->sb_uid = uid;\n\tsbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_n_free = -1;\n\tsbi->sb_n_free_dnodes = -1;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas;\n\tsbi->sb_chk = chk;\n\tsbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs;\n\tsbi->sb_timeshift = timeshift;\n\tsbi->sb_was_error = 0;\n\tsbi->sb_cp_table = NULL;\n\tsbi->sb_c_bitmap = -1;\n\tsbi->sb_max_fwd_alloc = 0xffffff;\n\n\tif (sbi->sb_fs_size >= 0x80000000) {\n\t\thpfs_error(s, \"invalid size in superblock: %08x\",\n\t\t\t(unsigned)sbi->sb_fs_size);\n\t\tgoto bail4;\n\t}\n\n\t/* Load bitmap directory */\n\tif (!(sbi->sb_bmp_dir = hpfs_load_bitmap_directory(s, le32_to_cpu(superblock->bitmaps))))\n\t\tgoto bail4;\n\t\n\t/* Check for general fs errors*/\n\tif (spareblock->dirty && !spareblock->old_wrote) {\n\t\tif (errs == 2) {\n\t\t\tpr_err(\"Improperly stopped, not mounted\\n\");\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"improperly stopped\");\n\t}\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tspareblock->dirty = 1;\n\t\tspareblock->old_wrote = 0;\n\t\tmark_buffer_dirty(bh2);\n\t}\n\n\tif (spareblock->hotfixes_used || spareblock->n_spares_used) {\n\t\tif (errs >= 2) {\n\t\t\tpr_err(\"Hotfixes not supported here, try chkdsk\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"hotfixes not supported here, try chkdsk\");\n\t\tif (errs == 0)\n\t\t\tpr_err(\"Proceeding, but your filesystem will be probably corrupted by this driver...\\n\");\n\t\telse\n\t\t\tpr_err(\"This driver may read bad files or crash when operating on disk with hotfixes.\\n\");\n\t}\n\tif (le32_to_cpu(spareblock->n_dnode_spares) != le32_to_cpu(spareblock->n_dnode_spares_free)) {\n\t\tif (errs >= 2) {\n\t\t\tpr_err(\"Spare dnodes used, try chkdsk\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"warning: spare dnodes used, try chkdsk\");\n\t\tif (errs == 0)\n\t\t\tpr_err(\"Proceeding, but your filesystem could be corrupted if you delete files or directories\\n\");\n\t}\n\tif (chk) {\n\t\tunsigned a;\n\t\tif (le32_to_cpu(superblock->dir_band_end) - le32_to_cpu(superblock->dir_band_start) + 1 != le32_to_cpu(superblock->n_dir_band) ||\n\t\t    le32_to_cpu(superblock->dir_band_end) < le32_to_cpu(superblock->dir_band_start) || le32_to_cpu(superblock->n_dir_band) > 0x4000) {\n\t\t\thpfs_error(s, \"dir band size mismatch: dir_band_start==%08x, dir_band_end==%08x, n_dir_band==%08x\",\n\t\t\t\tle32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->dir_band_end), le32_to_cpu(superblock->n_dir_band));\n\t\t\tgoto bail4;\n\t\t}\n\t\ta = sbi->sb_dirband_size;\n\t\tsbi->sb_dirband_size = 0;\n\t\tif (hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->n_dir_band), \"dir_band\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_bitmap), 4, \"dir_band_bitmap\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->bitmaps), 4, \"bitmaps\")) {\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\tsbi->sb_dirband_size = a;\n\t} else\n\t\tpr_err(\"You really don't want any checks? You are crazy...\\n\");\n\n\t/* Load code page table */\n\tif (le32_to_cpu(spareblock->n_code_pages))\n\t\tif (!(sbi->sb_cp_table = hpfs_load_code_page(s, le32_to_cpu(spareblock->code_page_dir))))\n\t\t\tpr_err(\"code page support is disabled\\n\");\n\n\tbrelse(bh2);\n\tbrelse(bh1);\n\tbrelse(bh0);\n\n\troot = iget_locked(s, sbi->sb_root);\n\tif (!root)\n\t\tgoto bail0;\n\thpfs_init_inode(root);\n\thpfs_read_inode(root);\n\tunlock_new_inode(root);\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto bail0;\n\n\t/*\n\t * find the root directory's . pointer & finish filling in the inode\n\t */\n\n\troot_dno = hpfs_fnode_dno(s, sbi->sb_root);\n\tif (root_dno)\n\t\tde = map_dirent(root, root_dno, \"\\001\\001\", 2, NULL, &qbh);\n\tif (!de)\n\t\thpfs_error(s, \"unable to find root dir\");\n\telse {\n\t\troot->i_atime.tv_sec = local_to_gmt(s, le32_to_cpu(de->read_date));\n\t\troot->i_atime.tv_nsec = 0;\n\t\troot->i_mtime.tv_sec = local_to_gmt(s, le32_to_cpu(de->write_date));\n\t\troot->i_mtime.tv_nsec = 0;\n\t\troot->i_ctime.tv_sec = local_to_gmt(s, le32_to_cpu(de->creation_date));\n\t\troot->i_ctime.tv_nsec = 0;\n\t\thpfs_i(root)->i_ea_size = le32_to_cpu(de->ea_size);\n\t\thpfs_i(root)->i_parent_dir = root->i_ino;\n\t\tif (root->i_size == -1)\n\t\t\troot->i_size = 2048;\n\t\tif (root->i_blocks == -1)\n\t\t\troot->i_blocks = 5;\n\t\thpfs_brelse4(&qbh);\n\t}\n\thpfs_unlock(s);\n\treturn 0;\n\nbail4:\tbrelse(bh2);\nbail3:\tbrelse(bh1);\nbail2:\tbrelse(bh0);\nbail1:\nbail0:\n\thpfs_unlock(s);\n\tfree_sbi(sbi);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations hpfs_sops =\n{\n\t.alloc_inode\t= hpfs_alloc_inode,\n\t.destroy_inode\t= hpfs_destroy_inode,\n\t.evict_inode\t= hpfs_evict_inode,\n\t.put_super\t= hpfs_put_super,\n\t.statfs\t\t= hpfs_statfs,\n\t.remount_fs\t= hpfs_remount_fs,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sbi",
          "args": [
            "sbi"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "lazy_free_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "115-118",
          "snippet": "static void lazy_free_sbi(struct rcu_head *rcu)\n{\n\tfree_sbi(container_of(rcu, struct hpfs_sb_info, rcu));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void lazy_free_sbi(struct rcu_head *rcu)\n{\n\tfree_sbi(container_of(rcu, struct hpfs_sb_info, rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "s"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh0"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "root"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "211-215",
          "snippet": "static void hpfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * hpfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic void hpfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->ea_size"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "s",
            "le32_to_cpu(de->creation_date)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"unable to find root dir\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "root",
            "root_dno",
            "\"\\001\\001\"",
            "2",
            "NULL",
            "&qbh"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_fnode_dno",
          "args": [
            "s",
            "sbi->sb_root"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_fnode_dno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "295-308",
          "snippet": "dnode_secno hpfs_fnode_dno(struct super_block *s, ino_t ino)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tdnode_secno dno;\n\n\tfnode = hpfs_map_fnode(s, ino, &bh);\n\tif (!fnode)\n\t\treturn 0;\n\n\tdno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\tbrelse(bh);\n\treturn dno;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_fnode_dno(struct super_block *s, ino_t ino)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tdnode_secno dno;\n\n\tfnode = hpfs_map_fnode(s, ino, &bh);\n\tif (!fnode)\n\t\treturn 0;\n\n\tdno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\tbrelse(bh);\n\treturn dno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "root"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_read_inode",
          "args": [
            "root"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "43-142",
          "snippet": "void hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "root"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "s",
            "sbi->sb_root"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"code page support is disabled\\n\""
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_load_code_page",
          "args": [
            "s",
            "le32_to_cpu(spareblock->code_page_dir)"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_load_code_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "56-109",
          "snippet": "unsigned char *hpfs_load_code_page(struct super_block *s, secno cps)\n{\n\tstruct buffer_head *bh;\n\tsecno cpds;\n\tunsigned cpi;\n\tunsigned char *ptr;\n\tunsigned char *cp_table;\n\tint i;\n\tstruct code_page_data *cpd;\n\tstruct code_page_directory *cp = hpfs_map_sector(s, cps, &bh, 0);\n\tif (!cp) return NULL;\n\tif (le32_to_cpu(cp->magic) != CP_DIR_MAGIC) {\n\t\tpr_err(\"Code page directory magic doesn't match (magic = %08x)\\n\",\n\t\t\tle32_to_cpu(cp->magic));\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tif (!le32_to_cpu(cp->n_code_pages)) {\n\t\tpr_err(\"n_code_pages == 0\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tcpds = le32_to_cpu(cp->array[0].code_page_data);\n\tcpi = le16_to_cpu(cp->array[0].index);\n\tbrelse(bh);\n\n\tif (cpi >= 3) {\n\t\tpr_err(\"Code page index out of array\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif (!(cpd = hpfs_map_sector(s, cpds, &bh, 0))) return NULL;\n\tif (le16_to_cpu(cpd->offs[cpi]) > 0x178) {\n\t\tpr_err(\"Code page index out of sector\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tptr = (unsigned char *)cpd + le16_to_cpu(cpd->offs[cpi]) + 6;\n\tif (!(cp_table = kmalloc(256, GFP_KERNEL))) {\n\t\tpr_err(\"out of memory for code page table\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tmemcpy(cp_table, ptr, 128);\n\tbrelse(bh);\n\n\t/* Try to build lowercasing table from uppercasing one */\n\n\tfor (i=128; i<256; i++) cp_table[i]=i;\n\tfor (i=128; i<256; i++) if (cp_table[i-128]!=i && cp_table[i-128]>=128)\n\t\tcp_table[cp_table[i-128]] = i;\n\t\n\treturn cp_table;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nunsigned char *hpfs_load_code_page(struct super_block *s, secno cps)\n{\n\tstruct buffer_head *bh;\n\tsecno cpds;\n\tunsigned cpi;\n\tunsigned char *ptr;\n\tunsigned char *cp_table;\n\tint i;\n\tstruct code_page_data *cpd;\n\tstruct code_page_directory *cp = hpfs_map_sector(s, cps, &bh, 0);\n\tif (!cp) return NULL;\n\tif (le32_to_cpu(cp->magic) != CP_DIR_MAGIC) {\n\t\tpr_err(\"Code page directory magic doesn't match (magic = %08x)\\n\",\n\t\t\tle32_to_cpu(cp->magic));\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tif (!le32_to_cpu(cp->n_code_pages)) {\n\t\tpr_err(\"n_code_pages == 0\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tcpds = le32_to_cpu(cp->array[0].code_page_data);\n\tcpi = le16_to_cpu(cp->array[0].index);\n\tbrelse(bh);\n\n\tif (cpi >= 3) {\n\t\tpr_err(\"Code page index out of array\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif (!(cpd = hpfs_map_sector(s, cpds, &bh, 0))) return NULL;\n\tif (le16_to_cpu(cpd->offs[cpi]) > 0x178) {\n\t\tpr_err(\"Code page index out of sector\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tptr = (unsigned char *)cpd + le16_to_cpu(cpd->offs[cpi]) + 6;\n\tif (!(cp_table = kmalloc(256, GFP_KERNEL))) {\n\t\tpr_err(\"out of memory for code page table\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tmemcpy(cp_table, ptr, 128);\n\tbrelse(bh);\n\n\t/* Try to build lowercasing table from uppercasing one */\n\n\tfor (i=128; i<256; i++) cp_table[i]=i;\n\tfor (i=128; i<256; i++) if (cp_table[i-128]!=i && cp_table[i-128]>=128)\n\t\tcp_table[cp_table[i-128]] = i;\n\t\n\treturn cp_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"You really don't want any checks? You are crazy...\\n\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "s",
            "0"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "21-34",
          "snippet": "static void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "le32_to_cpu(superblock->bitmaps)",
            "4",
            "\"bitmaps\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Proceeding, but your filesystem could be corrupted if you delete files or directories\\n\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Spare dnodes used, try chkdsk\\n\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"This driver may read bad files or crash when operating on disk with hotfixes.\\n\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Proceeding, but your filesystem will be probably corrupted by this driver...\\n\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Hotfixes not supported here, try chkdsk\\n\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh2"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Improperly stopped, not mounted\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_load_bitmap_directory",
          "args": [
            "s",
            "le32_to_cpu(superblock->bitmaps)"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_load_bitmap_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "111-131",
          "snippet": "__le32 *hpfs_load_bitmap_directory(struct super_block *s, secno bmp)\n{\n\tstruct buffer_head *bh;\n\tint n = (hpfs_sb(s)->sb_fs_size + 0x200000 - 1) >> 21;\n\tint i;\n\t__le32 *b;\n\tif (!(b = kmalloc(n * 512, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for bitmap directory\\n\");\n\t\treturn NULL;\n\t}\t\n\tfor (i=0;i<n;i++) {\n\t\t__le32 *d = hpfs_map_sector(s, bmp+i, &bh, n - i - 1);\n\t\tif (!d) {\n\t\t\tkfree(b);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy((char *)b + 512 * i, d, 512);\n\t\tbrelse(bh);\n\t}\n\treturn b;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_load_bitmap_directory(struct super_block *s, secno bmp)\n{\n\tstruct buffer_head *bh;\n\tint n = (hpfs_sb(s)->sb_fs_size + 0x200000 - 1) >> 21;\n\tint i;\n\t__le32 *b;\n\tif (!(b = kmalloc(n * 512, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for bitmap directory\\n\");\n\t\treturn NULL;\n\t}\t\n\tfor (i=0;i<n;i++) {\n\t\t__le32 *d = hpfs_map_sector(s, bmp+i, &bh, n - i - 1);\n\t\tif (!d) {\n\t\t\tkfree(b);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy((char *)b + 512 * i, d, 512);\n\t\tbrelse(bh);\n\t}\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"please try recent version of HPFS driver at http://artax.karlin.mff.cuni.cz/~mikulas/vyplody/hpfs/index-e.cgi and if it still can't understand this format, contact author - mikulas@artax.karlin.mff.cuni.cz\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bad version %d,%d. Mount readonly to go around\\n\"",
            "(int)superblock->version",
            "(int)superblock->funcversion"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bad magic ... probably not HPFS\\n\""
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "17",
            "&bh2",
            "0"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "512"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_help",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "392-416",
          "snippet": "static inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad mount options.\\n\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_opts",
          "args": [
            "options",
            "&uid",
            "&gid",
            "&umask",
            "&lowercase",
            "&eas",
            "&chk",
            "&errs",
            "&chkdsk",
            "&timeshift"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "parse_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "289-390",
          "snippet": "static int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "s"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->hpfs_mutex"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "s",
            "options"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic const struct super_operations hpfs_sops =\n{\n\t.alloc_inode\t= hpfs_alloc_inode,\n\t.destroy_inode\t= hpfs_destroy_inode,\n\t.evict_inode\t= hpfs_evict_inode,\n\t.put_super\t= hpfs_put_super,\n\t.statfs\t\t= hpfs_statfs,\n\t.remount_fs\t= hpfs_remount_fs,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int hpfs_fill_super(struct super_block *s, void *options, int silent)\n{\n\tstruct buffer_head *bh0, *bh1, *bh2;\n\tstruct hpfs_boot_block *bootblock;\n\tstruct hpfs_super_block *superblock;\n\tstruct hpfs_spare_block *spareblock;\n\tstruct hpfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\n\tdnode_secno root_dno;\n\tstruct hpfs_dirent *de = NULL;\n\tstruct quad_buffer_head qbh;\n\n\tint o;\n\n\tsave_mount_options(s, options);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi) {\n\t\treturn -ENOMEM;\n\t}\n\ts->s_fs_info = sbi;\n\n\tmutex_init(&sbi->hpfs_mutex);\n\thpfs_lock(s);\n\n\tuid = current_uid();\n\tgid = current_gid();\n\tumask = current_umask();\n\tlowercase = 0;\n\teas = 2;\n\tchk = 1;\n\terrs = 1;\n\tchkdsk = 1;\n\ttimeshift = 0;\n\n\tif (!(o = parse_opts(options, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto bail0;\n\t}\n\tif (o==2) {\n\t\thpfs_help();\n\t\tgoto bail0;\n\t}\n\n\t/*sbi->sb_mounting = 1;*/\n\tsb_set_blocksize(s, 512);\n\tsbi->sb_fs_size = -1;\n\tif (!(bootblock = hpfs_map_sector(s, 0, &bh0, 0))) goto bail1;\n\tif (!(superblock = hpfs_map_sector(s, 16, &bh1, 1))) goto bail2;\n\tif (!(spareblock = hpfs_map_sector(s, 17, &bh2, 0))) goto bail3;\n\n\t/* Check magics */\n\tif (/*le16_to_cpu(bootblock->magic) != BB_MAGIC\n\t    ||*/ le32_to_cpu(superblock->magic) != SB_MAGIC\n\t    || le32_to_cpu(spareblock->magic) != SP_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"Bad magic ... probably not HPFS\\n\");\n\t\tgoto bail4;\n\t}\n\n\t/* Check version */\n\tif (!(s->s_flags & MS_RDONLY) &&\n\t      superblock->funcversion != 2 && superblock->funcversion != 3) {\n\t\tpr_err(\"Bad version %d,%d. Mount readonly to go around\\n\",\n\t\t\t(int)superblock->version, (int)superblock->funcversion);\n\t\tpr_err(\"please try recent version of HPFS driver at http://artax.karlin.mff.cuni.cz/~mikulas/vyplody/hpfs/index-e.cgi and if it still can't understand this format, contact author - mikulas@artax.karlin.mff.cuni.cz\\n\");\n\t\tgoto bail4;\n\t}\n\n\ts->s_flags |= MS_NOATIME;\n\n\t/* Fill superblock stuff */\n\ts->s_magic = HPFS_SUPER_MAGIC;\n\ts->s_op = &hpfs_sops;\n\ts->s_d_op = &hpfs_dentry_operations;\n\n\tsbi->sb_root = le32_to_cpu(superblock->root);\n\tsbi->sb_fs_size = le32_to_cpu(superblock->n_sectors);\n\tsbi->sb_bitmaps = le32_to_cpu(superblock->bitmaps);\n\tsbi->sb_dirband_start = le32_to_cpu(superblock->dir_band_start);\n\tsbi->sb_dirband_size = le32_to_cpu(superblock->n_dir_band);\n\tsbi->sb_dmap = le32_to_cpu(superblock->dir_band_bitmap);\n\tsbi->sb_uid = uid;\n\tsbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_n_free = -1;\n\tsbi->sb_n_free_dnodes = -1;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas;\n\tsbi->sb_chk = chk;\n\tsbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs;\n\tsbi->sb_timeshift = timeshift;\n\tsbi->sb_was_error = 0;\n\tsbi->sb_cp_table = NULL;\n\tsbi->sb_c_bitmap = -1;\n\tsbi->sb_max_fwd_alloc = 0xffffff;\n\n\tif (sbi->sb_fs_size >= 0x80000000) {\n\t\thpfs_error(s, \"invalid size in superblock: %08x\",\n\t\t\t(unsigned)sbi->sb_fs_size);\n\t\tgoto bail4;\n\t}\n\n\t/* Load bitmap directory */\n\tif (!(sbi->sb_bmp_dir = hpfs_load_bitmap_directory(s, le32_to_cpu(superblock->bitmaps))))\n\t\tgoto bail4;\n\t\n\t/* Check for general fs errors*/\n\tif (spareblock->dirty && !spareblock->old_wrote) {\n\t\tif (errs == 2) {\n\t\t\tpr_err(\"Improperly stopped, not mounted\\n\");\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"improperly stopped\");\n\t}\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tspareblock->dirty = 1;\n\t\tspareblock->old_wrote = 0;\n\t\tmark_buffer_dirty(bh2);\n\t}\n\n\tif (spareblock->hotfixes_used || spareblock->n_spares_used) {\n\t\tif (errs >= 2) {\n\t\t\tpr_err(\"Hotfixes not supported here, try chkdsk\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"hotfixes not supported here, try chkdsk\");\n\t\tif (errs == 0)\n\t\t\tpr_err(\"Proceeding, but your filesystem will be probably corrupted by this driver...\\n\");\n\t\telse\n\t\t\tpr_err(\"This driver may read bad files or crash when operating on disk with hotfixes.\\n\");\n\t}\n\tif (le32_to_cpu(spareblock->n_dnode_spares) != le32_to_cpu(spareblock->n_dnode_spares_free)) {\n\t\tif (errs >= 2) {\n\t\t\tpr_err(\"Spare dnodes used, try chkdsk\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"warning: spare dnodes used, try chkdsk\");\n\t\tif (errs == 0)\n\t\t\tpr_err(\"Proceeding, but your filesystem could be corrupted if you delete files or directories\\n\");\n\t}\n\tif (chk) {\n\t\tunsigned a;\n\t\tif (le32_to_cpu(superblock->dir_band_end) - le32_to_cpu(superblock->dir_band_start) + 1 != le32_to_cpu(superblock->n_dir_band) ||\n\t\t    le32_to_cpu(superblock->dir_band_end) < le32_to_cpu(superblock->dir_band_start) || le32_to_cpu(superblock->n_dir_band) > 0x4000) {\n\t\t\thpfs_error(s, \"dir band size mismatch: dir_band_start==%08x, dir_band_end==%08x, n_dir_band==%08x\",\n\t\t\t\tle32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->dir_band_end), le32_to_cpu(superblock->n_dir_band));\n\t\t\tgoto bail4;\n\t\t}\n\t\ta = sbi->sb_dirband_size;\n\t\tsbi->sb_dirband_size = 0;\n\t\tif (hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->n_dir_band), \"dir_band\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_bitmap), 4, \"dir_band_bitmap\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->bitmaps), 4, \"bitmaps\")) {\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\tsbi->sb_dirband_size = a;\n\t} else\n\t\tpr_err(\"You really don't want any checks? You are crazy...\\n\");\n\n\t/* Load code page table */\n\tif (le32_to_cpu(spareblock->n_code_pages))\n\t\tif (!(sbi->sb_cp_table = hpfs_load_code_page(s, le32_to_cpu(spareblock->code_page_dir))))\n\t\t\tpr_err(\"code page support is disabled\\n\");\n\n\tbrelse(bh2);\n\tbrelse(bh1);\n\tbrelse(bh0);\n\n\troot = iget_locked(s, sbi->sb_root);\n\tif (!root)\n\t\tgoto bail0;\n\thpfs_init_inode(root);\n\thpfs_read_inode(root);\n\tunlock_new_inode(root);\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto bail0;\n\n\t/*\n\t * find the root directory's . pointer & finish filling in the inode\n\t */\n\n\troot_dno = hpfs_fnode_dno(s, sbi->sb_root);\n\tif (root_dno)\n\t\tde = map_dirent(root, root_dno, \"\\001\\001\", 2, NULL, &qbh);\n\tif (!de)\n\t\thpfs_error(s, \"unable to find root dir\");\n\telse {\n\t\troot->i_atime.tv_sec = local_to_gmt(s, le32_to_cpu(de->read_date));\n\t\troot->i_atime.tv_nsec = 0;\n\t\troot->i_mtime.tv_sec = local_to_gmt(s, le32_to_cpu(de->write_date));\n\t\troot->i_mtime.tv_nsec = 0;\n\t\troot->i_ctime.tv_sec = local_to_gmt(s, le32_to_cpu(de->creation_date));\n\t\troot->i_ctime.tv_nsec = 0;\n\t\thpfs_i(root)->i_ea_size = le32_to_cpu(de->ea_size);\n\t\thpfs_i(root)->i_parent_dir = root->i_ino;\n\t\tif (root->i_size == -1)\n\t\t\troot->i_size = 2048;\n\t\tif (root->i_blocks == -1)\n\t\t\troot->i_blocks = 5;\n\t\thpfs_brelse4(&qbh);\n\t}\n\thpfs_unlock(s);\n\treturn 0;\n\nbail4:\tbrelse(bh2);\nbail3:\tbrelse(bh1);\nbail2:\tbrelse(bh0);\nbail1:\nbail0:\n\thpfs_unlock(s);\n\tfree_sbi(sbi);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "hpfs_remount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "418-472",
    "snippet": "static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\tint o;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tchar *new_opts = kstrdup(data, GFP_KERNEL);\n\t\n\tsync_filesystem(s);\n\n\t*flags |= MS_NOATIME;\n\t\n\thpfs_lock(s);\n\tuid = sbi->sb_uid; gid = sbi->sb_gid;\n\tumask = 0777 & ~sbi->sb_mode;\n\tlowercase = sbi->sb_lowercase;\n\teas = sbi->sb_eas; chk = sbi->sb_chk; chkdsk = sbi->sb_chkdsk;\n\terrs = sbi->sb_err; timeshift = sbi->sb_timeshift;\n\n\tif (!(o = parse_opts(data, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto out_err;\n\t}\n\tif (o == 2) {\n\t\thpfs_help();\n\t\tgoto out_err;\n\t}\n\tif (timeshift != sbi->sb_timeshift) {\n\t\tpr_err(\"timeshift can't be changed using remount.\\n\");\n\t\tgoto out_err;\n\t}\n\n\tunmark_dirty(s);\n\n\tsbi->sb_uid = uid; sbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas; sbi->sb_chk = chk; sbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs; sbi->sb_timeshift = timeshift;\n\n\tif (!(*flags & MS_RDONLY)) mark_dirty(s, 1);\n\n\treplace_mount_options(s, new_opts);\n\n\thpfs_unlock(s);\n\treturn 0;\n\nout_err:\n\thpfs_unlock(s);\n\tkfree(new_opts);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_opts"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "s"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_mount_options",
          "args": [
            "s",
            "new_opts"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1196-1204",
          "snippet": "void replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "s",
            "1"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "21-34",
          "snippet": "static void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmark_dirty",
          "args": [
            "s"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "unmark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "39-52",
          "snippet": "static void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"timeshift can't be changed using remount.\\n\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_help",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "392-416",
          "snippet": "static inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad mount options.\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_opts",
          "args": [
            "data",
            "&uid",
            "&gid",
            "&umask",
            "&lowercase",
            "&eas",
            "&chk",
            "&errs",
            "&chkdsk",
            "&timeshift"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "parse_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "289-390",
          "snippet": "static int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "s"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "s"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data",
            "GFP_KERNEL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_remount_fs(struct super_block *s, int *flags, char *data)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\tint o;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tchar *new_opts = kstrdup(data, GFP_KERNEL);\n\t\n\tsync_filesystem(s);\n\n\t*flags |= MS_NOATIME;\n\t\n\thpfs_lock(s);\n\tuid = sbi->sb_uid; gid = sbi->sb_gid;\n\tumask = 0777 & ~sbi->sb_mode;\n\tlowercase = sbi->sb_lowercase;\n\teas = sbi->sb_eas; chk = sbi->sb_chk; chkdsk = sbi->sb_chkdsk;\n\terrs = sbi->sb_err; timeshift = sbi->sb_timeshift;\n\n\tif (!(o = parse_opts(data, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto out_err;\n\t}\n\tif (o == 2) {\n\t\thpfs_help();\n\t\tgoto out_err;\n\t}\n\tif (timeshift != sbi->sb_timeshift) {\n\t\tpr_err(\"timeshift can't be changed using remount.\\n\");\n\t\tgoto out_err;\n\t}\n\n\tunmark_dirty(s);\n\n\tsbi->sb_uid = uid; sbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas; sbi->sb_chk = chk; sbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs; sbi->sb_timeshift = timeshift;\n\n\tif (!(*flags & MS_RDONLY)) mark_dirty(s, 1);\n\n\treplace_mount_options(s, new_opts);\n\n\thpfs_unlock(s);\n\treturn 0;\n\nout_err:\n\thpfs_unlock(s);\n\tkfree(new_opts);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "hpfs_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "392-416",
    "snippet": "static inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}"
  },
  {
    "function_name": "parse_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "289-390",
    "snippet": "static int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "rhs",
            "&rhs",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "*gid"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "*uid"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&opts",
            "\",\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t/*pr_info(\"Parsing opts: '%s'\\n\",opts);*/\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "241-249",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * hpfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hpfs_inode_cachep"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "229-239",
    "snippet": "static int init_inodecache(void)\n{\n\thpfs_inode_cachep = kmem_cache_create(\"hpfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct hpfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (hpfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * hpfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"hpfs_inode_cache\"",
            "sizeof(struct hpfs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\thpfs_inode_cachep = kmem_cache_create(\"hpfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct hpfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (hpfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "222-227",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct hpfs_inode_info *ei = (struct hpfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void init_once(void *foo)\n{\n\tstruct hpfs_inode_info *ei = (struct hpfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "hpfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "217-220",
    "snippet": "static void hpfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hpfs_i_callback);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "hpfs_i_callback"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hpfs_i_callback);\n}"
  },
  {
    "function_name": "hpfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "211-215",
    "snippet": "static void hpfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * hpfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "hpfs_inode_cachep",
            "hpfs_i(inode)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "211-215",
          "snippet": "static void hpfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic void hpfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}"
  },
  {
    "function_name": "hpfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "201-209",
    "snippet": "static struct inode *hpfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hpfs_inode_info *ei;\n\tei = (struct hpfs_inode_info *)kmem_cache_alloc(hpfs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->vfs_inode.i_version = 1;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * hpfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "hpfs_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic struct inode *hpfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hpfs_inode_info *ei;\n\tei = (struct hpfs_inode_info *)kmem_cache_alloc(hpfs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->vfs_inode.i_version = 1;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "hpfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "172-197",
    "snippet": "static int hpfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\thpfs_lock(s);\n\n\tif (sbi->sb_n_free == (unsigned)-1)\n\t\tsbi->sb_n_free = count_bitmaps(s);\n\n\tbuf->f_type = s->s_magic;\n\tbuf->f_bsize = 512;\n\tbuf->f_blocks = sbi->sb_fs_size;\n\tbuf->f_bfree = sbi->sb_n_free;\n\tbuf->f_bavail = sbi->sb_n_free;\n\tbuf->f_files = sbi->sb_dirband_size / 4;\n\tbuf->f_ffree = hpfs_get_free_dnodes(s);\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = 254;\n\n\thpfs_unlock(s);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "s"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_get_free_dnodes",
          "args": [
            "s"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_free_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "160-170",
          "snippet": "unsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nunsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_bitmaps",
          "args": [
            "s"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "count_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "142-158",
          "snippet": "static unsigned count_bitmaps(struct super_block *s)\n{\n\tunsigned n, count, n_bands;\n\tn_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tcount = 0;\n\tfor (n = 0; n < COUNT_RD_AHEAD; n++) {\n\t\thpfs_prefetch_bitmap(s, n);\n\t}\n\tfor (n = 0; n < n_bands; n++) {\n\t\tunsigned c;\n\t\thpfs_prefetch_bitmap(s, n + COUNT_RD_AHEAD);\n\t\tc = hpfs_count_one_bitmap(s, le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n]));\n\t\tif (c != (unsigned)-1)\n\t\t\tcount += c;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic unsigned count_bitmaps(struct super_block *s)\n{\n\tunsigned n, count, n_bands;\n\tn_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tcount = 0;\n\tfor (n = 0; n < COUNT_RD_AHEAD; n++) {\n\t\thpfs_prefetch_bitmap(s, n);\n\t}\n\tfor (n = 0; n < n_bands; n++) {\n\t\tunsigned c;\n\t\thpfs_prefetch_bitmap(s, n + COUNT_RD_AHEAD);\n\t\tc = hpfs_count_one_bitmap(s, le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n]));\n\t\tif (c != (unsigned)-1)\n\t\t\tcount += c;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "s"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "s->s_bdev->bd_dev"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\thpfs_lock(s);\n\n\tif (sbi->sb_n_free == (unsigned)-1)\n\t\tsbi->sb_n_free = count_bitmaps(s);\n\n\tbuf->f_type = s->s_magic;\n\tbuf->f_bsize = 512;\n\tbuf->f_blocks = sbi->sb_fs_size;\n\tbuf->f_bfree = sbi->sb_n_free;\n\tbuf->f_bavail = sbi->sb_n_free;\n\tbuf->f_files = sbi->sb_dirband_size / 4;\n\tbuf->f_ffree = hpfs_get_free_dnodes(s);\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = 254;\n\n\thpfs_unlock(s);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hpfs_get_free_dnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "160-170",
    "snippet": "unsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_count_one_bitmap",
          "args": [
            "s",
            "sbi->sb_dmap"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_count_one_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "128-140",
          "snippet": "static unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nunsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}"
  },
  {
    "function_name": "count_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "142-158",
    "snippet": "static unsigned count_bitmaps(struct super_block *s)\n{\n\tunsigned n, count, n_bands;\n\tn_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tcount = 0;\n\tfor (n = 0; n < COUNT_RD_AHEAD; n++) {\n\t\thpfs_prefetch_bitmap(s, n);\n\t}\n\tfor (n = 0; n < n_bands; n++) {\n\t\tunsigned c;\n\t\thpfs_prefetch_bitmap(s, n + COUNT_RD_AHEAD);\n\t\tc = hpfs_count_one_bitmap(s, le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n]));\n\t\tif (c != (unsigned)-1)\n\t\t\tcount += c;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_count_one_bitmap",
          "args": [
            "s",
            "le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n])"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_count_one_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "128-140",
          "snippet": "static unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "hpfs_sb(s)->sb_bmp_dir[n]"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_prefetch_bitmap",
          "args": [
            "s",
            "n + COUNT_RD_AHEAD"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_prefetch_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "36-48",
          "snippet": "void hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic unsigned count_bitmaps(struct super_block *s)\n{\n\tunsigned n, count, n_bands;\n\tn_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tcount = 0;\n\tfor (n = 0; n < COUNT_RD_AHEAD; n++) {\n\t\thpfs_prefetch_bitmap(s, n);\n\t}\n\tfor (n = 0; n < n_bands; n++) {\n\t\tunsigned c;\n\t\thpfs_prefetch_bitmap(s, n + COUNT_RD_AHEAD);\n\t\tc = hpfs_count_one_bitmap(s, le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n]));\n\t\tif (c != (unsigned)-1)\n\t\t\tcount += c;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "hpfs_count_one_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "128-140",
    "snippet": "static unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "bits",
            "2048 * BITS_PER_BYTE"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_4sectors",
          "args": [
            "s",
            "secno",
            "&qbh",
            "0"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_4sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "86-136",
          "snippet": "void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}"
  },
  {
    "function_name": "hpfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "120-126",
    "snippet": "static void hpfs_put_super(struct super_block *s)\n{\n\thpfs_lock(s);\n\tunmark_dirty(s);\n\thpfs_unlock(s);\n\tcall_rcu(&hpfs_sb(s)->rcu, lazy_free_sbi);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&hpfs_sb(s)->rcu",
            "lazy_free_sbi"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "s"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmark_dirty",
          "args": [
            "s"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "unmark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "39-52",
          "snippet": "static void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "s"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_put_super(struct super_block *s)\n{\n\thpfs_lock(s);\n\tunmark_dirty(s);\n\thpfs_unlock(s);\n\tcall_rcu(&hpfs_sb(s)->rcu, lazy_free_sbi);\n}"
  },
  {
    "function_name": "lazy_free_sbi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "115-118",
    "snippet": "static void lazy_free_sbi(struct rcu_head *rcu)\n{\n\tfree_sbi(container_of(rcu, struct hpfs_sb_info, rcu));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void lazy_free_sbi(struct rcu_head *rcu)\n{\n\tfree_sbi(container_of(rcu, struct hpfs_sb_info, rcu));\n}"
  },
  {
    "function_name": "free_sbi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "108-113",
    "snippet": "static void free_sbi(struct hpfs_sb_info *sbi)\n{\n\tkfree(sbi->sb_cp_table);\n\tkfree(sbi->sb_bmp_dir);\n\tkfree(sbi);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->sb_bmp_dir"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->sb_cp_table"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void free_sbi(struct hpfs_sb_info *sbi)\n{\n\tkfree(sbi->sb_cp_table);\n\tkfree(sbi->sb_bmp_dir);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "hpfs_stop_cycles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "96-106",
    "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"cycle detected on key %08x in %s\"",
            "key",
            "msg"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
  },
  {
    "function_name": "hpfs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "57-86",
    "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char err_buf[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_kernfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "141-156",
          "snippet": "void pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);",
            "static char kernfs_pr_cont_buf[PATH_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\nstatic char kernfs_pr_cont_buf[PATH_MAX];\n\nvoid pr_cont_kernfs_path(struct kernfs_node *kn)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\n\tp = kernfs_path_locked(kn, kernfs_pr_cont_buf,\n\t\t\t       sizeof(kernfs_pr_cont_buf));\n\tif (p)\n\t\tpr_cont(\"%s\", p);\n\telse\n\t\tpr_cont(\"<name too long>\");\n\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "s",
            "0"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "21-34",
          "snippet": "static void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"HPFS panic\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"filesystem error: %s\"",
            "err_buf"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "err_buf",
            "sizeof(err_buf)",
            "fmt",
            "args"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
  },
  {
    "function_name": "unmark_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "39-52",
    "snippet": "static void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "17",
            "&bh",
            "0"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "s->s_bdev"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (s->s_flags & MS_RDONLY) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}"
  },
  {
    "function_name": "mark_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
    "lines": "21-34",
    "snippet": "static void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "17",
            "&bh",
            "0"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !(s->s_flags & MS_RDONLY))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}"
  }
]