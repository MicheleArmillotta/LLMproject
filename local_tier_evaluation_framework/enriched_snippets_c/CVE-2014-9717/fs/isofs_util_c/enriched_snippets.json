[
  {
    "function_name": "iso_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/util.c",
    "lines": "18-70",
    "snippet": "int iso_date(char * p, int flag)\n{\n\tint year, month, day, hour, minute, second, tz;\n\tint crtime;\n\n\tyear = p[0];\n\tmonth = p[1];\n\tday = p[2];\n\thour = p[3];\n\tminute = p[4];\n\tsecond = p[5];\n\tif (flag == 0) tz = p[6]; /* High sierra has no time zone */\n\telse tz = 0;\n\t\n\tif (year < 0) {\n\t\tcrtime = 0;\n\t} else {\n\t\tcrtime = mktime64(year+1900, month, day, hour, minute, second);\n\n\t\t/* sign extend */\n\t\tif (tz & 0x80)\n\t\t\ttz |= (-1 << 8);\n\t\t\n\t\t/* \n\t\t * The timezone offset is unreliable on some disks,\n\t\t * so we make a sanity check.  In no case is it ever\n\t\t * more than 13 hours from GMT, which is 52*15min.\n\t\t * The time is always stored in localtime with the\n\t\t * timezone offset being what get added to GMT to\n\t\t * get to localtime.  Thus we need to subtract the offset\n\t\t * to get to true GMT, which is what we store the time\n\t\t * as internally.  On the local system, the user may set\n\t\t * their timezone any way they wish, of course, so GMT\n\t\t * gets converted back to localtime on the receiving\n\t\t * system.\n\t\t *\n\t\t * NOTE: mkisofs in versions prior to mkisofs-1.10 had\n\t\t * the sign wrong on the timezone offset.  This has now\n\t\t * been corrected there too, but if you are getting screwy\n\t\t * results this may be the explanation.  If enough people\n\t\t * complain, a user configuration option could be added\n\t\t * to add the timezone offset in with the wrong sign\n\t\t * for 'compatibility' with older discs, but I cannot see how\n\t\t * it will matter that much.\n\t\t *\n\t\t * Thanks to kuhlmav@elec.canterbury.ac.nz (Volker Kuhlmann)\n\t\t * for pointing out the sign error.\n\t\t */\n\t\tif (-52 <= tz && tz <= 52)\n\t\t\tcrtime -= tz * 15 * 60;\n\t}\n\treturn crtime;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mktime64",
          "args": [
            "year+1900",
            "month",
            "day",
            "hour",
            "minute",
            "second"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/time.h>\n\nint iso_date(char * p, int flag)\n{\n\tint year, month, day, hour, minute, second, tz;\n\tint crtime;\n\n\tyear = p[0];\n\tmonth = p[1];\n\tday = p[2];\n\thour = p[3];\n\tminute = p[4];\n\tsecond = p[5];\n\tif (flag == 0) tz = p[6]; /* High sierra has no time zone */\n\telse tz = 0;\n\t\n\tif (year < 0) {\n\t\tcrtime = 0;\n\t} else {\n\t\tcrtime = mktime64(year+1900, month, day, hour, minute, second);\n\n\t\t/* sign extend */\n\t\tif (tz & 0x80)\n\t\t\ttz |= (-1 << 8);\n\t\t\n\t\t/* \n\t\t * The timezone offset is unreliable on some disks,\n\t\t * so we make a sanity check.  In no case is it ever\n\t\t * more than 13 hours from GMT, which is 52*15min.\n\t\t * The time is always stored in localtime with the\n\t\t * timezone offset being what get added to GMT to\n\t\t * get to localtime.  Thus we need to subtract the offset\n\t\t * to get to true GMT, which is what we store the time\n\t\t * as internally.  On the local system, the user may set\n\t\t * their timezone any way they wish, of course, so GMT\n\t\t * gets converted back to localtime on the receiving\n\t\t * system.\n\t\t *\n\t\t * NOTE: mkisofs in versions prior to mkisofs-1.10 had\n\t\t * the sign wrong on the timezone offset.  This has now\n\t\t * been corrected there too, but if you are getting screwy\n\t\t * results this may be the explanation.  If enough people\n\t\t * complain, a user configuration option could be added\n\t\t * to add the timezone offset in with the wrong sign\n\t\t * for 'compatibility' with older discs, but I cannot see how\n\t\t * it will matter that much.\n\t\t *\n\t\t * Thanks to kuhlmav@elec.canterbury.ac.nz (Volker Kuhlmann)\n\t\t * for pointing out the sign error.\n\t\t */\n\t\tif (-52 <= tz && tz <= 52)\n\t\t\tcrtime -= tz * 15 * 60;\n\t}\n\treturn crtime;\n}"
  }
]