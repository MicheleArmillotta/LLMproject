[
  {
    "function_name": "ufs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "263-336",
    "snippet": "static int ufs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *dir_page = NULL;\n\tstruct ufs_dir_entry * dir_de = NULL;\n\tstruct page *old_page;\n\tstruct ufs_dir_entry *old_de;\n\tint err = -ENOENT;\n\n\told_de = ufs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ufs_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ufs_dir_entry *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ufs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = ufs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tufs_set_link(new_dir, new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ufs_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n \t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\n\tufs_delete_entry(old_dir, old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tufs_set_link(old_inode, dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "old_page"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "old_page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dir_page"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dir_page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "old_dir"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_link",
          "args": [
            "old_inode",
            "dir_de",
            "dir_page",
            "new_dir"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "89-108",
          "snippet": "void ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,\n\t\t  struct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = fs16_to_cpu(dir->i_sb, de->d_reclen);\n\tint err;\n\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\n\tde->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);\n\tufs_set_de_type(dir->i_sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, len);\n\tufs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,\n\t\t  struct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = fs16_to_cpu(dir->i_sb, de->d_reclen);\n\tint err;\n\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\n\tde->d_ino = cpu_to_fs32(dir->i_sb, inode->i_ino);\n\tufs_set_de_type(dir->i_sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, len);\n\tufs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_inode"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_delete_entry",
          "args": [
            "old_dir",
            "old_de",
            "old_page"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "511-557",
          "snippet": "int ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "new_dir"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "312-412",
          "snippet": "int ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_find_entry",
          "args": [
            "new_dir",
            "&new_dentry->d_name",
            "&new_page"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "251-307",
          "snippet": "struct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "607-655",
          "snippet": "int ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_dotdot",
          "args": [
            "old_inode",
            "&dir_page"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "230-241",
          "snippet": "struct ufs_dir_entry *ufs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = ufs_get_page(dir, 0);\n\tstruct ufs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ufs_next_entry(dir->i_sb,\n\t\t\t\t    (struct ufs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = ufs_get_page(dir, 0);\n\tstruct ufs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ufs_next_entry(dir->i_sb,\n\t\t\t\t    (struct ufs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *dir_page = NULL;\n\tstruct ufs_dir_entry * dir_de = NULL;\n\tstruct page *old_page;\n\tstruct ufs_dir_entry *old_de;\n\tint err = -ENOENT;\n\n\told_de = ufs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ufs_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ufs_dir_entry *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ufs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = ufs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tufs_set_link(new_dir, new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ufs_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n \t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\n\tufs_delete_entry(old_dir, old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tufs_set_link(old_inode, dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "245-261",
    "snippet": "static int ufs_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err= -ENOTEMPTY;\n\n\tlock_ufs(dir->i_sb);\n\tif (ufs_empty_dir (inode)) {\n\t\terr = ufs_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\tunlock_ufs(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
          "lines": "223-243",
          "snippet": "static int ufs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\tde = ufs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ufs_delete_entry(dir, de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\tde = ufs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ufs_delete_entry(dir, de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_empty_dir",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "607-655",
          "snippet": "int ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = ufs_dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct ufs_dir_entry *de;\n\t\tpage = ufs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += ufs_last_byte(inode, i) - UFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry: \"\n\t\t\t\t\t\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->d_ino) {\n\t\t\t\tu16 namelen=ufs_get_de_namlen(sb, de);\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->d_name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (namelen < 2) {\n\t\t\t\t\tif (inode->i_ino !=\n\t\t\t\t\t    fs32_to_cpu(sb, de->d_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->d_name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ufs_next_entry(sb, de);\n\t\t}\n\t\tufs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tufs_put_page(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err= -ENOTEMPTY;\n\n\tlock_ufs(dir->i_sb);\n\tif (ufs_empty_dir (inode)) {\n\t\terr = ufs_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\tunlock_ufs(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "223-243",
    "snippet": "static int ufs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\tde = ufs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ufs_delete_entry(dir, de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_delete_entry",
          "args": [
            "dir",
            "de",
            "page"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "511-557",
          "snippet": "int ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_delete_entry(struct inode *inode, struct ufs_dir_entry *dir,\n\t\t     struct page * page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);\n\tunsigned to = ((char*)dir - kaddr) + fs16_to_cpu(sb, dir->d_reclen);\n\tloff_t pos;\n\tstruct ufs_dir_entry *pde = NULL;\n\tstruct ufs_dir_entry *de = (struct ufs_dir_entry *) (kaddr + from);\n\tint err;\n\n\tUFSD(\"ENTER\\n\");\n\n\tUFSD(\"ino %u, reclen %u, namlen %u, name %s\\n\",\n\t      fs32_to_cpu(sb, de->d_ino),\n\t      fs16_to_cpu(sb, de->d_reclen),\n\t      ufs_get_de_namlen(sb, de), de->d_name);\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->d_reclen == 0) {\n\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t  \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ufs_next_entry(sb, de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ufs_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->d_reclen = cpu_to_fs16(sb, to - from);\n\tdir->d_ino = 0;\n\terr = ufs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tufs_put_page(page);\n\tUFSD(\"EXIT\\n\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&page"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "251-307",
          "snippet": "struct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct ufs_dir_entry *ufs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t     struct page **res_page)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ufs_inode_info *ui = UFS_I(dir);\n\tstruct ufs_dir_entry *de;\n\n\tUFSD(\"ENTER, dir_ino %lu, name %s, namlen %u\\n\", dir->i_ino, name, namelen);\n\n\tif (npages == 0 || namelen > UFS_MAXNAMLEN)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ui->i_dir_start_lookup;\n\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ufs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct ufs_dir_entry *) kaddr;\n\t\t\tkaddr += ufs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->d_reclen == 0) {\n\t\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\t\tufs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ufs_next_entry(sb, de);\n\t\t\t}\n\t\t\tufs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tui->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\tde = ufs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ufs_delete_entry(dir, de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "182-221",
    "snippet": "static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode = ufs_new_inode(dir, S_IFDIR|mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ufs_dir_inode_operations;\n\tinode->i_fop = &ufs_dir_operations;\n\tinode->i_mapping->a_ops = &ufs_aops;\n\n\tinode_inc_link_count(inode);\n\n\tlock_ufs(dir->i_sb);\n\tinode_inc_link_count(dir);\n\n\terr = ufs_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ufs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\tunlock_ufs(dir->i_sb);\n\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput (inode);\n\tinode_dec_link_count(dir);\n\tunlock_ufs(dir->i_sb);\n\tgoto out;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations ufs_dir_inode_operations = {\n\t.create\t\t= ufs_create,\n\t.lookup\t\t= ufs_lookup,\n\t.link\t\t= ufs_link,\n\t.unlink\t\t= ufs_unlink,\n\t.symlink\t= ufs_symlink,\n\t.mkdir\t\t= ufs_mkdir,\n\t.rmdir\t\t= ufs_rmdir,\n\t.mknod\t\t= ufs_mknod,\n\t.rename\t\t= ufs_rename,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "312-412",
          "snippet": "int ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_make_empty",
          "args": [
            "inode",
            "dir"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_make_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "559-602",
          "snippet": "int ufs_make_empty(struct inode * inode, struct inode *dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tstruct ufs_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ufs_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkmap(page);\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct ufs_dir_entry *) base;\n\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\tufs_set_de_namlen(sb, de, 1);\n\tde->d_reclen = cpu_to_fs16(sb, UFS_DIR_REC_LEN(1));\n\tstrcpy (de->d_name, \".\");\n\tde = (struct ufs_dir_entry *)\n\t\t((char *)de + fs16_to_cpu(sb, de->d_reclen));\n\tde->d_ino = cpu_to_fs32(sb, dir->i_ino);\n\tufs_set_de_type(sb, de, dir->i_mode);\n\tde->d_reclen = cpu_to_fs16(sb, chunk_size - UFS_DIR_REC_LEN(1));\n\tufs_set_de_namlen(sb, de, 2);\n\tstrcpy (de->d_name, \"..\");\n\tkunmap(page);\n\n\terr = ufs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_make_empty(struct inode * inode, struct inode *dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tstruct ufs_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ufs_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkmap(page);\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct ufs_dir_entry *) base;\n\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\tufs_set_de_namlen(sb, de, 1);\n\tde->d_reclen = cpu_to_fs16(sb, UFS_DIR_REC_LEN(1));\n\tstrcpy (de->d_name, \".\");\n\tde = (struct ufs_dir_entry *)\n\t\t((char *)de + fs16_to_cpu(sb, de->d_reclen));\n\tde->d_ino = cpu_to_fs32(sb, dir->i_ino);\n\tufs_set_de_type(sb, de, dir->i_mode);\n\tde->d_reclen = cpu_to_fs16(sb, chunk_size - UFS_DIR_REC_LEN(1));\n\tufs_set_de_namlen(sb, de, 2);\n\tstrcpy (de->d_name, \"..\");\n\tkunmap(page);\n\n\terr = ufs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "dir"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_new_inode",
          "args": [
            "dir",
            "S_IFDIR|mode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "171-353",
          "snippet": "struct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nconst struct inode_operations ufs_dir_inode_operations = {\n\t.create\t\t= ufs_create,\n\t.lookup\t\t= ufs_lookup,\n\t.link\t\t= ufs_link,\n\t.unlink\t\t= ufs_unlink,\n\t.symlink\t= ufs_symlink,\n\t.mkdir\t\t= ufs_mkdir,\n\t.rmdir\t\t= ufs_rmdir,\n\t.mknod\t\t= ufs_mknod,\n\t.rename\t\t= ufs_rename,\n};\n\nstatic int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode = ufs_new_inode(dir, S_IFDIR|mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ufs_dir_inode_operations;\n\tinode->i_fop = &ufs_dir_operations;\n\tinode->i_mapping->a_ops = &ufs_aops;\n\n\tinode_inc_link_count(inode);\n\n\tlock_ufs(dir->i_sb);\n\tinode_inc_link_count(dir);\n\n\terr = ufs_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ufs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\tunlock_ufs(dir->i_sb);\n\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput (inode);\n\tinode_dec_link_count(dir);\n\tunlock_ufs(dir->i_sb);\n\tgoto out;\n}"
  },
  {
    "function_name": "ufs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "165-180",
    "snippet": "static int ufs_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tlock_ufs(dir->i_sb);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terror = ufs_add_nondir(dentry, inode);\n\tunlock_ufs(dir->i_sb);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
          "lines": "37-49",
          "snippet": "static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tlock_ufs(dir->i_sb);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terror = ufs_add_nondir(dentry, inode);\n\tunlock_ufs(dir->i_sb);\n\treturn error;\n}"
  },
  {
    "function_name": "ufs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "120-163",
    "snippet": "static int ufs_symlink (struct inode * dir, struct dentry * dentry,\n\tconst char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err = -ENAMETOOLONG;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\tgoto out_notlocked;\n\n\tinode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_notlocked;\n\n\tlock_ufs(dir->i_sb);\n\tif (l > UFS_SB(sb)->s_uspi->s_maxsymlinklen) {\n\t\t/* slow symlink */\n\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t/* fast symlink */\n\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\tmemcpy(UFS_I(inode)->i_u1.i_symlink, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\terr = ufs_add_nondir(dentry, inode);\nout:\n\tunlock_ufs(dir->i_sb);\nout_notlocked:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tgoto out;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
          "lines": "37-49",
          "snippet": "static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "UFS_I(inode)->i_u1.i_symlink",
            "symname",
            "l"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "l"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_new_inode",
          "args": [
            "dir",
            "S_IFLNK | S_IRWXUGO"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "171-353",
          "snippet": "struct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_symlink (struct inode * dir, struct dentry * dentry,\n\tconst char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err = -ENAMETOOLONG;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\tgoto out_notlocked;\n\n\tinode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_notlocked;\n\n\tlock_ufs(dir->i_sb);\n\tif (l > UFS_SB(sb)->s_uspi->s_maxsymlinklen) {\n\t\t/* slow symlink */\n\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t/* fast symlink */\n\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\tmemcpy(UFS_I(inode)->i_u1.i_symlink, symname, l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\terr = ufs_add_nondir(dentry, inode);\nout:\n\tunlock_ufs(dir->i_sb);\nout_notlocked:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "ufs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "99-118",
    "snippet": "static int ufs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = ufs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, mode, rdev);\n\t\tufs_set_inode_dev(inode->i_sb, UFS_I(inode), rdev);\n\t\tmark_inode_dirty(inode);\n\t\tlock_ufs(dir->i_sb);\n\t\terr = ufs_add_nondir(dentry, inode);\n\t\tunlock_ufs(dir->i_sb);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
          "lines": "37-49",
          "snippet": "static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_inode_dev",
          "args": [
            "inode->i_sb",
            "UFS_I(inode)",
            "rdev"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_inode_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "207-229",
          "snippet": "void\nufs_set_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi, dev_t dev)\n{\n\t__u32 fs32;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tfs32 = sysv_encode_dev(dev);\n\t\tif ((fs32 & 0xffff8000) == 0) {\n\t\t\tfs32 = old_encode_dev(dev);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfs32 = old_encode_dev(dev);\n\t\tbreak;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufsi->i_u1.i_data[1] = cpu_to_fs32(sb, fs32);\n\telse\n\t\tufsi->i_u1.i_data[0] = cpu_to_fs32(sb, fs32);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid\nufs_set_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi, dev_t dev)\n{\n\t__u32 fs32;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tfs32 = sysv_encode_dev(dev);\n\t\tif ((fs32 & 0xffff8000) == 0) {\n\t\t\tfs32 = old_encode_dev(dev);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfs32 = old_encode_dev(dev);\n\t\tbreak;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufsi->i_u1.i_data[1] = cpu_to_fs32(sb, fs32);\n\telse\n\t\tufsi->i_u1.i_data[0] = cpu_to_fs32(sb, fs32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "rdev"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "171-353",
          "snippet": "struct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = ufs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, mode, rdev);\n\t\tufs_set_inode_dev(inode->i_sb, UFS_I(inode), rdev);\n\t\tmark_inode_dirty(inode);\n\t\tlock_ufs(dir->i_sb);\n\t\terr = ufs_add_nondir(dentry, inode);\n\t\tunlock_ufs(dir->i_sb);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "75-97",
    "snippet": "static int ufs_create (struct inode * dir, struct dentry * dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"BEGIN\\n\");\n\n\tinode = ufs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\tmark_inode_dirty(inode);\n\t\tlock_ufs(dir->i_sb);\n\t\terr = ufs_add_nondir(dentry, inode);\n\t\tunlock_ufs(dir->i_sb);\n\t}\n\tUFSD(\"END: err=%d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"END: err=%d\\n\"",
            "err"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
          "lines": "37-49",
          "snippet": "static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "171-353",
          "snippet": "struct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"BEGIN\\n\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int ufs_create (struct inode * dir, struct dentry * dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"BEGIN\\n\");\n\n\tinode = ufs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\tmark_inode_dirty(inode);\n\t\tlock_ufs(dir->i_sb);\n\t\terr = ufs_add_nondir(dentry, inode);\n\t\tunlock_ufs(dir->i_sb);\n\t}\n\tUFSD(\"END: err=%d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "51-65",
    "snippet": "static struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\t\n\tif (dentry->d_name.len > UFS_MAXNAMLEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tlock_ufs(dir->i_sb);\n\tino = ufs_inode_by_name(dir, &dentry->d_name);\n\tif (ino)\n\t\tinode = ufs_iget(dir->i_sb, ino);\n\tunlock_ufs(dir->i_sb);\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "dir->i_sb"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "682-743",
          "snippet": "struct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inode_by_name",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "73-85",
          "snippet": "ino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct dentry *ufs_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\t\n\tif (dentry->d_name.len > UFS_MAXNAMLEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tlock_ufs(dir->i_sb);\n\tino = ufs_inode_by_name(dir, &dentry->d_name);\n\tif (ino)\n\t\tinode = ufs_iget(dir->i_sb, ino);\n\tunlock_ufs(dir->i_sb);\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "ufs_add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/namei.c",
    "lines": "37-49",
    "snippet": "static inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "312-412",
          "snippet": "int ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ufs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned reclen = UFS_DIR_REC_LEN(namelen);\n\tconst unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct ufs_dir_entry *de;\n\tunsigned long npages = ufs_dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tUFSD(\"ENTER, name %s, namelen %u\\n\", name, namelen);\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ufs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ufs_last_byte(dir, n);\n\t\tde = (struct ufs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->d_reclen = cpu_to_fs16(sb, chunk_size);\n\t\t\t\tde->d_ino = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->d_reclen == 0) {\n\t\t\t\tufs_error(dir->i_sb, __func__,\n\t\t\t\t\t  \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ufs_match(sb, namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = UFS_DIR_REC_LEN(ufs_get_de_namlen(sb, de));\n\t\t\trec_len = fs16_to_cpu(sb, de->d_reclen);\n\t\t\tif (!de->d_ino && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct ufs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tufs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\terr = ufs_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->d_ino) {\n\t\tstruct ufs_dir_entry *de1 =\n\t\t\t(struct ufs_dir_entry *) ((char *) de + name_len);\n\t\tde1->d_reclen = cpu_to_fs16(sb, rec_len - name_len);\n\t\tde->d_reclen = cpu_to_fs16(sb, name_len);\n\n\t\tde = de1;\n\t}\n\n\tufs_set_de_namlen(sb, de, namelen);\n\tmemcpy(de->d_name, name, namelen + 1);\n\tde->d_ino = cpu_to_fs32(sb, inode->i_ino);\n\tufs_set_de_type(sb, de, inode->i_mode);\n\n\terr = ufs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\tufs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int ufs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ufs_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  }
]