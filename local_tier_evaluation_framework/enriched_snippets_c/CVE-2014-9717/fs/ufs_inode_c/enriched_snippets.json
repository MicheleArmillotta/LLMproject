[
  {
    "function_name": "ufs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "881-907",
    "snippet": "void ufs_evict_inode(struct inode * inode)\n{\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\twant_delete = 1;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (want_delete) {\n\t\tloff_t old_i_size;\n\t\t/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/\n\t\tlock_ufs(inode->i_sb);\n\t\tmark_inode_dirty(inode);\n\t\tufs_update_inode(inode, IS_SYNC(inode));\n\t\told_i_size = inode->i_size;\n\t\tinode->i_size = 0;\n\t\tif (inode->i_blocks && ufs_truncate(inode, old_i_size))\n\t\t\tufs_warning(inode->i_sb, __func__, \"ufs_truncate failed\\n\");\n\t\tunlock_ufs(inode->i_sb);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (want_delete)\n\t\tufs_free_inode(inode);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_free_inode",
          "args": [
            "inode"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "56-120",
          "snippet": "void ufs_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tint is_directory;\n\tunsigned ino, cg, bit;\n\t\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tino = inode->i_ino;\n\n\tlock_ufs(sb);\n\n\tif (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {\n\t\tufs_warning(sb, \"ufs_free_inode\", \"reserved inode or nonexistent inode %u\\n\", ino);\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\t\n\tcg = ufs_inotocg (ino);\n\tbit = ufs_inotocgoff (ino);\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg))\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad cg magic number\");\n\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tufs_error(sb, \"ufs_free_inode\", \"bit already cleared for inode %u\", ino);\n\telse {\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\t\tif (ino < ucpi->c_irotor)\n\t\t\tucpi->c_irotor = ino;\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nifree, 1);\n\t\tuspi->cs_total.cs_nifree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cg).cs_nifree, 1);\n\n\t\tif (is_directory) {\n\t\t\tfs32_sub(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\t\tuspi->cs_total.cs_ndir--;\n\t\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cg).cs_ndir, 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\t\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ufs_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tint is_directory;\n\tunsigned ino, cg, bit;\n\t\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tino = inode->i_ino;\n\n\tlock_ufs(sb);\n\n\tif (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {\n\t\tufs_warning(sb, \"ufs_free_inode\", \"reserved inode or nonexistent inode %u\\n\", ino);\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\t\n\tcg = ufs_inotocg (ino);\n\tbit = ufs_inotocgoff (ino);\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg))\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad cg magic number\");\n\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tufs_error(sb, \"ufs_free_inode\", \"bit already cleared for inode %u\", ino);\n\telse {\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\t\tif (ino < ucpi->c_irotor)\n\t\t\tucpi->c_irotor = ino;\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nifree, 1);\n\t\tuspi->cs_total.cs_nifree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cg).cs_nifree, 1);\n\n\t\tif (is_directory) {\n\t\t\tfs32_sub(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\t\tuspi->cs_total.cs_ndir--;\n\t\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cg).cs_ndir, 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\t\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "inode->i_sb"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"ufs_truncate failed\\n\""
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_truncate",
          "args": [
            "inode",
            "old_i_size"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/truncate.c",
          "lines": "443-491",
          "snippet": "int ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/sched.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)\n\nint ufs_truncate(struct inode *inode, loff_t old_i_size)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tint retry, err = 0;\n\t\n\tUFSD(\"ENTER: ino %lu, i_size: %llu, old_i_size: %llu\\n\",\n\t     inode->i_ino, (unsigned long long)i_size_read(inode),\n\t     (unsigned long long)old_i_size);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\terr = ufs_alloc_lastblock(inode);\n\n\tif (err) {\n\t\ti_size_write(inode, old_i_size);\n\t\tgoto out;\n\t}\n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\n\n\twhile (1) {\n\t\tretry = ufs_trunc_direct(inode);\n\t\tretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\n\t\t\t\t\t    ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t    UFS_IND_BLOCK));\n\t\tretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\n\t\t\t\t\t     ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t     UFS_DIND_BLOCK));\n\t\tretry |= ufs_trunc_tindirect (inode);\n\t\tif (!retry)\n\t\t\tbreak;\n\t\tif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\n\t\t\tufs_sync_inode (inode);\n\t\tyield();\n\t}\n\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_lastfrag = DIRECT_FRAGMENT;\n\tmark_inode_dirty(inode);\nout:\n\tUFSD(\"EXIT: err %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_update_inode",
          "args": [
            "inode",
            "IS_SYNC(inode)"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "828-865",
          "snippet": "static int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nvoid ufs_evict_inode(struct inode * inode)\n{\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\twant_delete = 1;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (want_delete) {\n\t\tloff_t old_i_size;\n\t\t/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/\n\t\tlock_ufs(inode->i_sb);\n\t\tmark_inode_dirty(inode);\n\t\tufs_update_inode(inode, IS_SYNC(inode));\n\t\told_i_size = inode->i_size;\n\t\tinode->i_size = 0;\n\t\tif (inode->i_blocks && ufs_truncate(inode, old_i_size))\n\t\t\tufs_warning(inode->i_sb, __func__, \"ufs_truncate failed\\n\");\n\t\tunlock_ufs(inode->i_sb);\n\t}\n\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\n\tif (want_delete)\n\t\tufs_free_inode(inode);\n}"
  },
  {
    "function_name": "ufs_sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "876-879",
    "snippet": "int ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_update_inode",
          "args": [
            "inode",
            "1"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "828-865",
          "snippet": "static int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}"
  },
  {
    "function_name": "ufs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "867-874",
    "snippet": "int ufs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\tlock_ufs(inode->i_sb);\n\tret = ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\tunlock_ufs(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "inode->i_sb"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_update_inode",
          "args": [
            "inode",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "828-865",
          "snippet": "static int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\tlock_ufs(inode->i_sb);\n\tret = ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n\tunlock_ufs(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "ufs_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "828-865",
    "snippet": "static int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs1_update_inode",
          "args": [
            "inode",
            "ufs_inode + ufs_inotofsbo(inode->i_ino)"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ufs1_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "745-786",
          "snippet": "static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));\n\tufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));\n\t\t\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atime.tv_usec = 0;\n\tufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctime.tv_usec = 0;\n\tufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtime.tv_usec = 0;\n\tufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {\n\t\tufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);\n\t\tufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t}\n\telse {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n\t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs_inode));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));\n\tufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));\n\t\t\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atime.tv_usec = 0;\n\tufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctime.tv_usec = 0;\n\tufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtime.tv_usec = 0;\n\tufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {\n\t\tufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);\n\t\tufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t}\n\telse {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n\t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs_inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotofsbo",
          "args": [
            "inode->i_ino"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs2_update_inode",
          "args": [
            "inode",
            "ufs2_inode + ufs_inotofsbo(inode->i_ino)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "ufs2_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "788-826",
          "snippet": "static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tUFSD(\"ENTER\\n\");\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));\n\tufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);\n\tufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);\n\tufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);\n\n\tufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n \t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs2_inode));\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tUFSD(\"ENTER\\n\");\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));\n\tufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);\n\tufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);\n\tufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);\n\n\tufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n \t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs2_inode));\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotofsbo",
          "args": [
            "inode->i_ino"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_read_inode\"",
            "\"unable to read inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "ufs_inotofsba(inode->i_ino)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotofsba",
          "args": [
            "inode->i_ino"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_update_inode(struct inode * inode, int do_sync)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tif (inode->i_ino < UFS_ROOTINO ||\n\t    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n\tbh = sb_bread(sb, ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning (sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\tufs2_update_inode(inode,\n\t\t\t\t  ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;\n\n\t\tufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\t\t\n\tmark_buffer_dirty(bh);\n\tif (do_sync)\n\t\tsync_dirty_buffer(bh);\n\tbrelse (bh);\n\t\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs2_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "788-826",
    "snippet": "static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tUFSD(\"ENTER\\n\");\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));\n\tufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);\n\tufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);\n\tufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);\n\n\tufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n \t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs2_inode));\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ufs_inode",
            "0",
            "sizeof(struct ufs2_inode)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ufs_inode->ui_u2.ui_symlink",
            "ufsi->i_u1.i_symlink",
            "sizeof(ufs_inode->ui_u2.ui_symlink)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ufs_inode->ui_u2.ui_addr",
            "ufsi->i_u1.u2_i_data",
            "sizeof(ufs_inode->ui_u2.ui_addr)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "inode->i_generation"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs64",
          "args": [
            "sb",
            "inode->i_blocks"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "34-41",
          "snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs16",
          "args": [
            "sb",
            "inode->i_nlink"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "88-95",
          "snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tUFSD(\"ENTER\\n\");\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));\n\tufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));\n\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);\n\tufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);\n\tufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);\n\n\tufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n \t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs2_inode));\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs1_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "745-786",
    "snippet": "static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));\n\tufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));\n\t\t\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atime.tv_usec = 0;\n\tufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctime.tv_usec = 0;\n\tufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtime.tv_usec = 0;\n\tufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {\n\t\tufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);\n\t\tufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t}\n\telse {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n\t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs_inode));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ufs_inode",
            "0",
            "sizeof(struct ufs_inode)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ufs_inode->ui_u2.ui_symlink",
            "ufsi->i_u1.i_symlink",
            "sizeof(ufs_inode->ui_u2.ui_symlink)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ufs_inode->ui_u2.ui_addr",
            "ufsi->i_u1.i_data",
            "sizeof(ufs_inode->ui_u2.ui_addr)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "ufsi->i_oeftflag"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs64",
          "args": [
            "sb",
            "inode->i_size"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "34-41",
          "snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_inode_gid",
          "args": [
            "sb",
            "ufs_inode",
            "i_gid_read(inode)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_inode_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "239-256",
          "snippet": "static inline void\nufs_set_inode_gid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_gid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_gid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\t/* Fall through */\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_inode_gid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_gid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_gid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\t/* Fall through */\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_sgid =  cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_inode_uid",
          "args": [
            "sb",
            "ufs_inode",
            "i_uid_read(inode)"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_inode_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "205-222",
          "snippet": "static inline void\nufs_set_inode_uid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_uid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_uid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\t/* Fall through */\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_inode_uid(struct super_block *sb, struct ufs_inode *inode, u32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\tinode->ui_u3.ui_44.ui_uid = cpu_to_fs32(sb, value);\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\tcase UFS_UID_EFT:\n\t\tinode->ui_u3.ui_sun.ui_uid = cpu_to_fs32(sb, value);\n\t\tif (value > 0xFFFF)\n\t\t\tvalue = 0xFFFF;\n\t\t/* Fall through */\n\tdefault:\n\t\tinode->ui_u1.oldids.ui_suid = cpu_to_fs16(sb, value);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs16",
          "args": [
            "sb",
            "inode->i_nlink"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "88-95",
          "snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs16\ncpu_to_fs16(struct super_block *sbp, u16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs16)cpu_to_le16(n);\n\telse\n\t\treturn (__force __fs16)cpu_to_be16(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n \tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\n\tufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);\n\tufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);\n\n\tufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));\n\tufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));\n\t\t\n\tufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);\n\tufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);\n\tufs_inode->ui_atime.tv_usec = 0;\n\tufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);\n\tufs_inode->ui_ctime.tv_usec = 0;\n\tufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);\n\tufs_inode->ui_mtime.tv_usec = 0;\n\tufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);\n\tufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);\n\tufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);\n\n\tif ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {\n\t\tufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);\n\t\tufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\t/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */\n\t\tufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];\n\t} else if (inode->i_blocks) {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t}\n\telse {\n\t\tmemcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink));\n\t}\n\n\tif (!inode->i_nlink)\n\t\tmemset (ufs_inode, 0, sizeof(struct ufs_inode));\n}"
  },
  {
    "function_name": "ufs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "682-743",
    "snippet": "struct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_inode_ops",
          "args": [
            "inode"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_inode_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "564-584",
          "snippet": "static void ufs_set_inode_ops(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ufs_dir_inode_operations;\n\t\tinode->i_fop = &ufs_dir_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (!inode->i_blocks)\n\t\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations ufs_aops = {\n\t.readpage = ufs_readpage,\n\t.writepage = ufs_writepage,\n\t.write_begin = ufs_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = ufs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct address_space_operations ufs_aops = {\n\t.readpage = ufs_readpage,\n\t.writepage = ufs_writepage,\n\t.write_begin = ufs_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = ufs_bmap\n};\n\nstatic void ufs_set_inode_ops(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ufs_dir_inode_operations;\n\t\tinode->i_fop = &ufs_dir_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (!inode->i_blocks)\n\t\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs1_read_inode",
          "args": [
            "inode",
            "ufs_inode + ufs_inotofsbo(inode->i_ino)"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ufs1_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "586-631",
          "snippet": "static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\t\n\t/*\n\t * Linux now has 32-bit uid and gid, so we can support EFT.\n\t */\n\ti_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));\n\ti_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\n\t\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\t\n\t/*\n\t * Linux now has 32-bit uid and gid, so we can support EFT.\n\t */\n\ti_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));\n\ti_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\n\t\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotofsbo",
          "args": [
            "inode->i_ino"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs2_read_inode",
          "args": [
            "inode",
            "ufs2_inode + ufs_inotofsbo(inode->i_ino)"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ufs2_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "633-680",
          "snippet": "static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\tUFSD(\"Reading ufs2 inode, ino %lu\\n\", inode->i_ino);\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n        /*\n         * Linux now has 32-bit uid and gid, so we can support EFT.\n         */\n\ti_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));\n\ti_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);\n\tinode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);\n\tinode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);\n\tinode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);\n\tinode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);\n\tinode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);\n\tinode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);\n\tinode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);\n\t/*\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\t*/\n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\tUFSD(\"Reading ufs2 inode, ino %lu\\n\", inode->i_ino);\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n        /*\n         * Linux now has 32-bit uid and gid, so we can support EFT.\n         */\n\ti_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));\n\ti_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);\n\tinode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);\n\tinode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);\n\tinode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);\n\tinode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);\n\tinode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);\n\tinode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);\n\tinode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);\n\t/*\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\t*/\n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotofsbo",
          "args": [
            "inode->i_ino"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_read_inode\"",
            "\"unable to read inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "uspi->s_sbbase + ufs_inotofsba(inode->i_ino)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotofsba",
          "args": [
            "inode->i_ino"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu\\n\"",
            "ino"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "ufs2_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "633-680",
    "snippet": "static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\tUFSD(\"Reading ufs2 inode, ino %lu\\n\", inode->i_ino);\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n        /*\n         * Linux now has 32-bit uid and gid, so we can support EFT.\n         */\n\ti_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));\n\ti_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);\n\tinode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);\n\tinode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);\n\tinode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);\n\tinode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);\n\tinode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);\n\tinode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);\n\tinode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);\n\t/*\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\t*/\n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ufsi->i_u1.i_symlink",
            "ufs2_inode->ui_u2.ui_symlink",
            "sizeof(ufs2_inode->ui_u2.ui_symlink) - 1"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ufsi->i_u1.u2_i_data",
            "&ufs2_inode->ui_u2.ui_addr",
            "sizeof(ufs2_inode->ui_u2.ui_addr)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ufs2_inode->ui_flags"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "ufs2_inode->ui_blocks"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "fs32_to_cpu(sb, ufs2_inode->ui_gid)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "fs32_to_cpu(sb, ufs2_inode->ui_uid)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_read_inode\"",
            "\"inode %lu has zero nlink\\n\"",
            "inode->i_ino"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "fs16_to_cpu(sb, ufs2_inode->ui_nlink)"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "ufs2_inode->ui_nlink"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"Reading ufs2 inode, ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\tUFSD(\"Reading ufs2 inode, ino %lu\\n\", inode->i_ino);\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\n        /*\n         * Linux now has 32-bit uid and gid, so we can support EFT.\n         */\n\ti_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));\n\ti_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);\n\tinode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);\n\tinode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);\n\tinode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);\n\tinode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);\n\tinode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);\n\tinode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);\n\tinode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);\n\t/*\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\t*/\n\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs1_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "586-631",
    "snippet": "static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\t\n\t/*\n\t * Linux now has 32-bit uid and gid, so we can support EFT.\n\t */\n\ti_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));\n\ti_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\n\t\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ufsi->i_u1.i_symlink",
            "ufs_inode->ui_u2.ui_symlink",
            "sizeof(ufs_inode->ui_u2.ui_symlink) - 1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ufsi->i_u1.i_data",
            "&ufs_inode->ui_u2.ui_addr",
            "sizeof(ufs_inode->ui_u2.ui_addr)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ufs_inode->ui_u3.ui_sun.ui_oeftflag"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "ufs_inode->ui_size"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "ufs_get_inode_gid(sb, ufs_inode)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_inode_gid",
          "args": [
            "sb",
            "ufs_inode"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_inode_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "224-237",
          "snippet": "static inline u32\nufs_get_inode_gid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_gid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_suid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_gid);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_sgid);\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u32\nufs_get_inode_gid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_gid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_suid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_gid);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_sgid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "ufs_get_inode_uid(sb, ufs_inode)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_inode_uid",
          "args": [
            "sb",
            "ufs_inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_inode_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "190-203",
          "snippet": "static inline u32\nufs_get_inode_uid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_uid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_suid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_uid);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_suid);\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u32\nufs_get_inode_uid(struct super_block *sb, struct ufs_inode *inode)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_UID_MASK) {\n\tcase UFS_UID_44BSD:\n\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_44.ui_uid);\n\tcase UFS_UID_EFT:\n\t\tif (inode->ui_u1.oldids.ui_suid == 0xFFFF)\n\t\t\treturn fs32_to_cpu(sb, inode->ui_u3.ui_sun.ui_uid);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn fs16_to_cpu(sb, inode->ui_u1.oldids.ui_suid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_read_inode\"",
            "\"inode %lu has zero nlink\\n\"",
            "inode->i_ino"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "fs16_to_cpu(sb, ufs_inode->ui_nlink)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "ufs_inode->ui_nlink"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tumode_t mode;\n\n\t/*\n\t * Copy data to the in-core inode.\n\t */\n\tinode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);\n\tset_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));\n\tif (inode->i_nlink == 0) {\n\t\tufs_error (sb, \"ufs_read_inode\", \"inode %lu has zero nlink\\n\", inode->i_ino);\n\t\treturn -1;\n\t}\n\t\n\t/*\n\t * Linux now has 32-bit uid and gid, so we can support EFT.\n\t */\n\ti_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));\n\ti_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));\n\n\tinode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);\n\tinode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);\n\tufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);\n\tufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);\n\tufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);\n\n\t\n\tif (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {\n\t\tmemcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,\n\t\t       sizeof(ufs_inode->ui_u2.ui_addr));\n\t} else {\n\t\tmemcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,\n\t\t       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);\n\t\tufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_set_inode_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "564-584",
    "snippet": "static void ufs_set_inode_ops(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ufs_dir_inode_operations;\n\t\tinode->i_fop = &ufs_dir_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (!inode->i_blocks)\n\t\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations ufs_aops = {\n\t.readpage = ufs_readpage,\n\t.writepage = ufs_writepage,\n\t.write_begin = ufs_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = ufs_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "ufs_get_inode_dev(inode->i_sb, UFS_I(inode))"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_inode_dev",
          "args": [
            "inode->i_sb",
            "UFS_I(inode)"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_inode_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "180-205",
          "snippet": "dev_t\nufs_get_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi)\n{\n\t__u32 fs32;\n\tdev_t dev;\n\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[1]);\n\telse\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[0]);\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tif ((fs32 & 0xffff0000) == 0 ||\n\t\t    (fs32 & 0xffff0000) == 0xffff0000)\n\t\t\tdev = old_decode_dev(fs32 & 0x7fff);\n\t\telse\n\t\t\tdev = MKDEV(sysv_major(fs32), sysv_minor(fs32));\n\t\tbreak;\n\n\tdefault:\n\t\tdev = old_decode_dev(fs32);\n\t\tbreak;\n\t}\n\treturn dev;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\ndev_t\nufs_get_inode_dev(struct super_block *sb, struct ufs_inode_info *ufsi)\n{\n\t__u32 fs32;\n\tdev_t dev;\n\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[1]);\n\telse\n\t\tfs32 = fs32_to_cpu(sb, ufsi->i_u1.i_data[0]);\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNx86:\n\tcase UFS_ST_SUN:\n\t\tif ((fs32 & 0xffff0000) == 0 ||\n\t\t    (fs32 & 0xffff0000) == 0xffff0000)\n\t\t\tdev = old_decode_dev(fs32 & 0x7fff);\n\t\telse\n\t\t\tdev = MKDEV(sysv_major(fs32), sysv_minor(fs32));\n\t\tbreak;\n\n\tdefault:\n\t\tdev = old_decode_dev(fs32);\n\t\tbreak;\n\t}\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct address_space_operations ufs_aops = {\n\t.readpage = ufs_readpage,\n\t.writepage = ufs_writepage,\n\t.write_begin = ufs_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = ufs_bmap\n};\n\nstatic void ufs_set_inode_ops(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ufs_file_inode_operations;\n\t\tinode->i_fop = &ufs_file_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ufs_dir_inode_operations;\n\t\tinode->i_fop = &ufs_dir_operations;\n\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (!inode->i_blocks)\n\t\t\tinode->i_op = &ufs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &ufs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &ufs_aops;\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));\n}"
  },
  {
    "function_name": "ufs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "551-554",
    "snippet": "static sector_t ufs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,ufs_getfrag_block);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "ufs_getfrag_block"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic sector_t ufs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,ufs_getfrag_block);\n}"
  },
  {
    "function_name": "ufs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "537-549",
    "snippet": "static int ufs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tufs_getfrag_block);\n\tif (unlikely(ret))\n\t\tufs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "529-535",
          "snippet": "static void ufs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "ufs_getfrag_block"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tufs_getfrag_block);\n\tif (unlikely(ret))\n\t\tufs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ufs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "529-535",
    "snippet": "static void ufs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void ufs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
  },
  {
    "function_name": "ufs_prepare_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "524-527",
    "snippet": "int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "ufs_getfrag_block"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, ufs_getfrag_block);\n}"
  },
  {
    "function_name": "ufs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "519-522",
    "snippet": "static int ufs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,ufs_getfrag_block);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "ufs_getfrag_block"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,ufs_getfrag_block);\n}"
  },
  {
    "function_name": "ufs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "514-517",
    "snippet": "static int ufs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,ufs_getfrag_block,wbc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "ufs_getfrag_block",
            "wbc"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page,ufs_getfrag_block,wbc);\n}"
  },
  {
    "function_name": "ufs_getfrag_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "415-512",
    "snippet": "int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi = sbi->s_uspi;\n\tstruct buffer_head * bh;\n\tint ret, err, new;\n\tunsigned long ptr,phys;\n\tu64 phys64 = 0;\n\tbool needs_lock = (sbi->mutex_owner != current);\n\t\n\tif (!create) {\n\t\tphys64 = ufs_frag_map(inode, fragment, needs_lock);\n\t\tUFSD(\"phys64 = %llu\\n\", (unsigned long long)phys64);\n\t\tif (phys64)\n\t\t\tmap_bh(bh_result, sb, phys64);\n\t\treturn 0;\n\t}\n\n        /* This code entered only while writing ....? */\n\n\terr = -EIO;\n\tnew = 0;\n\tret = 0;\n\tbh = NULL;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu\\n\", inode->i_ino, (unsigned long long)fragment);\n\tif (fragment >\n\t    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)\n\t     << uspi->s_fpbshift))\n\t\tgoto abort_too_big;\n\n\terr = 0;\n\tptr = fragment;\n\t  \n\t/*\n\t * ok, these macros clean the logic up a bit and make\n\t * it much more readable:\n\t */\n#define GET_INODE_DATABLOCK(x) \\\n\tufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\\\n\t\t\t  bh_result->b_page)\n#define GET_INODE_PTR(x) \\\n\tufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\\\n\t\t\t  bh_result->b_page)\n#define GET_INDIRECT_DATABLOCK(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, &phys, &new, bh_result->b_page)\n#define GET_INDIRECT_PTR(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, NULL, NULL, NULL)\n\n\tif (ptr < UFS_NDIR_FRAGMENT) {\n\t\tbh = GET_INODE_DATABLOCK(ptr);\n\t\tgoto out;\n\t}\n\tptr -= UFS_NDIR_FRAGMENT;\n\tif (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));\n\t\tgoto get_indirect;\n\t}\n\tptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);\n\tif (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));\n\t\tgoto get_double;\n\t}\n\tptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);\n\tbh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);\nget_double:\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);\nget_indirect:\n\tbh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);\n\n#undef GET_INODE_DATABLOCK\n#undef GET_INODE_PTR\n#undef GET_INDIRECT_DATABLOCK\n#undef GET_INDIRECT_PTR\n\nout:\n\tif (err)\n\t\tgoto abort;\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\nabort:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\n\treturn err;\n\nabort_too_big:\n\tufs_warning(sb, \"ufs_get_block\", \"block > big\");\n\tgoto abort;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_get_block\"",
            "\"block > big\""
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INDIRECT_DATABLOCK",
          "args": [
            "ptr & uspi->s_apbmask"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INDIRECT_PTR",
          "args": [
            "(ptr >> uspi->s_apbshift) & uspi->s_apbmask"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INDIRECT_PTR",
          "args": [
            "(ptr >> uspi->s_2apbshift) & uspi->s_apbmask"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INODE_PTR",
          "args": [
            "UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INODE_PTR",
          "args": [
            "UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INODE_PTR",
          "args": [
            "UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_INODE_DATABLOCK",
          "args": [
            "ptr"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, fragment %llu\\n\"",
            "inode->i_ino",
            "(unsigned long long)fragment"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys64"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"phys64 = %llu\\n\"",
            "(unsigned long long)phys64"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_frag_map",
          "args": [
            "inode",
            "fragment",
            "needs_lock"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_frag_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "83-157",
          "snippet": "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;\n\tint shift = uspi->s_apbshift-uspi->s_fpbshift;\n\tsector_t offsets[4], *p;\n\tint depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);\n\tu64  ret = 0L;\n\t__fs32 block;\n\t__fs64 u2_block = 0L;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\tu64 temp = 0L;\n\n\tUFSD(\": frag = %llu  depth = %d\\n\", (unsigned long long)frag, depth);\n\tUFSD(\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\",\n\t\tuspi->s_fpbshift, uspi->s_apbmask,\n\t\t(unsigned long long)mask);\n\n\tif (depth == 0)\n\t\treturn 0;\n\n\tp = offsets;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tgoto ufs2;\n\n\tblock = ufsi->i_u1.i_data[*p++];\n\tif (!block)\n\t\tgoto out;\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tblock = ((__fs32 *) bh->b_data)[n & mask];\n\t\tbrelse (bh);\n\t\tif (!block)\n\t\t\tgoto out;\n\t}\n\tret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));\n\tgoto out;\nufs2:\n\tu2_block = ufsi->i_u1.u2_i_data[*p++];\n\tif (!u2_block)\n\t\tgoto out;\n\n\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\n\t\ttemp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);\n\t\tbh = sb_bread(sb, temp +(u64) (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tu2_block = ((__fs64 *)bh->b_data)[n & mask];\n\t\tbrelse(bh);\n\t\tif (!u2_block)\n\t\t\tgoto out;\n\t}\n\ttemp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);\n\tret = temp + (u64) (frag & uspi->s_fpbmask);\n\nout:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;\n\tint shift = uspi->s_apbshift-uspi->s_fpbshift;\n\tsector_t offsets[4], *p;\n\tint depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);\n\tu64  ret = 0L;\n\t__fs32 block;\n\t__fs64 u2_block = 0L;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\tu64 temp = 0L;\n\n\tUFSD(\": frag = %llu  depth = %d\\n\", (unsigned long long)frag, depth);\n\tUFSD(\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\",\n\t\tuspi->s_fpbshift, uspi->s_apbmask,\n\t\t(unsigned long long)mask);\n\n\tif (depth == 0)\n\t\treturn 0;\n\n\tp = offsets;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tgoto ufs2;\n\n\tblock = ufsi->i_u1.i_data[*p++];\n\tif (!block)\n\t\tgoto out;\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tblock = ((__fs32 *) bh->b_data)[n & mask];\n\t\tbrelse (bh);\n\t\tif (!block)\n\t\t\tgoto out;\n\t}\n\tret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));\n\tgoto out;\nufs2:\n\tu2_block = ufsi->i_u1.u2_i_data[*p++];\n\tif (!u2_block)\n\t\tgoto out;\n\n\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\n\t\ttemp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);\n\t\tbh = sb_bread(sb, temp +(u64) (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tu2_block = ((__fs64 *)bh->b_data)[n & mask];\n\t\tbrelse(bh);\n\t\tif (!u2_block)\n\t\t\tgoto out;\n\t}\n\ttemp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);\n\tret = temp + (u64) (frag & uspi->s_fpbmask);\n\nout:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);\n\nint ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)\n{\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi = sbi->s_uspi;\n\tstruct buffer_head * bh;\n\tint ret, err, new;\n\tunsigned long ptr,phys;\n\tu64 phys64 = 0;\n\tbool needs_lock = (sbi->mutex_owner != current);\n\t\n\tif (!create) {\n\t\tphys64 = ufs_frag_map(inode, fragment, needs_lock);\n\t\tUFSD(\"phys64 = %llu\\n\", (unsigned long long)phys64);\n\t\tif (phys64)\n\t\t\tmap_bh(bh_result, sb, phys64);\n\t\treturn 0;\n\t}\n\n        /* This code entered only while writing ....? */\n\n\terr = -EIO;\n\tnew = 0;\n\tret = 0;\n\tbh = NULL;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu\\n\", inode->i_ino, (unsigned long long)fragment);\n\tif (fragment >\n\t    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)\n\t     << uspi->s_fpbshift))\n\t\tgoto abort_too_big;\n\n\terr = 0;\n\tptr = fragment;\n\t  \n\t/*\n\t * ok, these macros clean the logic up a bit and make\n\t * it much more readable:\n\t */\n#define GET_INODE_DATABLOCK(x) \\\n\tufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\\\n\t\t\t  bh_result->b_page)\n#define GET_INODE_PTR(x) \\\n\tufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\\\n\t\t\t  bh_result->b_page)\n#define GET_INDIRECT_DATABLOCK(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, &phys, &new, bh_result->b_page)\n#define GET_INDIRECT_PTR(x) \\\n\tufs_inode_getblock(inode, bh, x, fragment,\t\\\n\t\t\t  &err, NULL, NULL, NULL)\n\n\tif (ptr < UFS_NDIR_FRAGMENT) {\n\t\tbh = GET_INODE_DATABLOCK(ptr);\n\t\tgoto out;\n\t}\n\tptr -= UFS_NDIR_FRAGMENT;\n\tif (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));\n\t\tgoto get_indirect;\n\t}\n\tptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);\n\tif (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {\n\t\tbh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));\n\t\tgoto get_double;\n\t}\n\tptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);\n\tbh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);\nget_double:\n\tbh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);\nget_indirect:\n\tbh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);\n\n#undef GET_INODE_DATABLOCK\n#undef GET_INODE_PTR\n#undef GET_INDIRECT_DATABLOCK\n#undef GET_INDIRECT_PTR\n\nout:\n\tif (err)\n\t\tgoto abort;\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, sb, phys);\nabort:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\n\treturn err;\n\nabort_too_big:\n\tufs_warning(sb, \"ufs_get_block\", \"block > big\");\n\tgoto abort;\n}"
  },
  {
    "function_name": "ufs_inode_getblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "329-408",
    "snippet": "static struct buffer_head *\nufs_inode_getblock(struct inode *inode, struct buffer_head *bh,\n\t\t  u64 fragment, sector_t new_fragment, int *err,\n\t\t  long *phys, int *new, struct page *locked_page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * result;\n\tunsigned blockoff;\n\tu64 tmp, goal, block;\n\tvoid *p;\n\n\tblock = ufs_fragstoblks (fragment);\n\tblockoff = ufs_fragnum (fragment);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)new_fragment, !phys);\n\n\tresult = NULL;\n\tif (!bh)\n\t\tgoto out;\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block (READ, 1, &bh);\n\t\twait_on_buffer (bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto out;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tp = (__fs64 *)bh->b_data + block;\n\telse\n\t\tp = (__fs32 *)bh->b_data + block;\nrepeat:\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (tmp) {\n\t\tif (!phys) {\n\t\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t\t\tif (tmp == ufs_data_ptr_to_cpu(sb, p))\n\t\t\t\tgoto out;\n\t\t\tbrelse (result);\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (block && (uspi->fs_magic == UFS2_MAGIC ?\n\t\t      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[block-1])) :\n\t\t      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[block-1]))))\n\t\tgoal = tmp + uspi->s_fpb;\n\telse\n\t\tgoal = bh->b_blocknr + uspi->s_fpb;\n\ttmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,\n\t\t\t\tuspi->s_fpb, err, locked_page);\n\tif (!tmp) {\n\t\tif (ufs_data_ptr_to_cpu(sb, p))\n\t\t\tgoto repeat;\n\t\tgoto out;\n\t}\t\t\n\n\n\tif (!phys) {\n\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t} else {\n\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t*new = 1;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tUFSD(\"result %llu\\n\", (unsigned long long)tmp + blockoff);\nout:\n\tbrelse (bh);\n\tUFSD(\"EXIT\\n\");\n\treturn result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"result %llu\\n\"",
            "(unsigned long long)tmp + blockoff"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "uspi->s_sbbase + tmp + blockoff"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_new_fragments",
          "args": [
            "inode",
            "p",
            "ufs_blknum(new_fragment)",
            "goal",
            "uspi->s_fpb",
            "err",
            "locked_page"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "341-491",
          "snippet": "u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\n\nu64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_blknum",
          "args": [
            "new_fragment"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "((__fs32 *)bh->b_data)[block-1]"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "((__fs64 *)bh->b_data)[block-1]"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "uspi->s_sbbase + tmp + blockoff"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\\n\"",
            "inode->i_ino",
            "(unsigned long long)fragment",
            "(unsigned long long)new_fragment",
            "!phys"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "fragment"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct buffer_head *\nufs_inode_getblock(struct inode *inode, struct buffer_head *bh,\n\t\t  u64 fragment, sector_t new_fragment, int *err,\n\t\t  long *phys, int *new, struct page *locked_page)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * result;\n\tunsigned blockoff;\n\tu64 tmp, goal, block;\n\tvoid *p;\n\n\tblock = ufs_fragstoblks (fragment);\n\tblockoff = ufs_fragnum (fragment);\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)new_fragment, !phys);\n\n\tresult = NULL;\n\tif (!bh)\n\t\tgoto out;\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block (READ, 1, &bh);\n\t\twait_on_buffer (bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto out;\n\t}\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tp = (__fs64 *)bh->b_data + block;\n\telse\n\t\tp = (__fs32 *)bh->b_data + block;\nrepeat:\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\tif (tmp) {\n\t\tif (!phys) {\n\t\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t\t\tif (tmp == ufs_data_ptr_to_cpu(sb, p))\n\t\t\t\tgoto out;\n\t\t\tbrelse (result);\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (block && (uspi->fs_magic == UFS2_MAGIC ?\n\t\t      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[block-1])) :\n\t\t      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[block-1]))))\n\t\tgoal = tmp + uspi->s_fpb;\n\telse\n\t\tgoal = bh->b_blocknr + uspi->s_fpb;\n\ttmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,\n\t\t\t\tuspi->s_fpb, err, locked_page);\n\tif (!tmp) {\n\t\tif (ufs_data_ptr_to_cpu(sb, p))\n\t\t\tgoto repeat;\n\t\tgoto out;\n\t}\t\t\n\n\n\tif (!phys) {\n\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t} else {\n\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t*new = 1;\n\t}\n\n\tmark_buffer_dirty(bh);\n\tif (IS_SYNC(inode))\n\t\tsync_dirty_buffer(bh);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tUFSD(\"result %llu\\n\", (unsigned long long)tmp + blockoff);\nout:\n\tbrelse (bh);\n\tUFSD(\"EXIT\\n\");\n\treturn result;\n}"
  },
  {
    "function_name": "ufs_inode_getfrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "172-314",
    "snippet": "static struct buffer_head *\nufs_inode_getfrag(struct inode *inode, u64 fragment,\n\t\t  sector_t new_fragment, unsigned int required, int *err,\n\t\t  long *phys, int *new, struct page *locked_page)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * result;\n\tunsigned blockoff, lastblockoff;\n\tu64 tmp, goal, lastfrag, block, lastblock;\n\tvoid *p, *p2;\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, \"\n\t     \"metadata %d\\n\", inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)new_fragment, required, !phys);\n\n        /* TODO : to be done for write support\n        if ( (flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n             goto ufs2;\n         */\n\n\tblock = ufs_fragstoblks (fragment);\n\tblockoff = ufs_fragnum (fragment);\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, block);\n\n\tgoal = 0;\n\nrepeat:\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tlastfrag = ufsi->i_lastfrag;\n\tif (tmp && fragment < lastfrag) {\n\t\tif (!phys) {\n\t\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t\t\tif (tmp == ufs_data_ptr_to_cpu(sb, p)) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)tmp + blockoff);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbrelse (result);\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tlastblock = ufs_fragstoblks (lastfrag);\n\tlastblockoff = ufs_fragnum (lastfrag);\n\t/*\n\t * We will extend file into new block beyond last allocated block\n\t */\n\tif (lastblock < block) {\n\t\t/*\n\t\t * We must reallocate last allocated block\n\t\t */\n\t\tif (lastblockoff) {\n\t\t\tp2 = ufs_get_direct_data_ptr(uspi, ufsi, lastblock);\n\t\t\ttmp = ufs_new_fragments(inode, p2, lastfrag,\n\t\t\t\t\t\tufs_data_ptr_to_cpu(sb, p2),\n\t\t\t\t\t\tuspi->s_fpb - lastblockoff,\n\t\t\t\t\t\terr, locked_page);\n\t\t\tif (!tmp) {\n\t\t\t\tif (lastfrag != ufsi->i_lastfrag)\n\t\t\t\t\tgoto repeat;\n\t\t\t\telse\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlastfrag = ufsi->i_lastfrag;\n\t\t\t\n\t\t}\n\t\ttmp = ufs_data_ptr_to_cpu(sb,\n\t\t\t\t\t ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t lastblock));\n\t\tif (tmp)\n\t\t\tgoal = tmp + uspi->s_fpb;\n\t\ttmp = ufs_new_fragments (inode, p, fragment - blockoff, \n\t\t\t\t\t goal, required + blockoff,\n\t\t\t\t\t err,\n\t\t\t\t\t phys != NULL ? locked_page : NULL);\n\t} else if (lastblock == block) {\n\t/*\n\t * We will extend last allocated block\n\t */\n\t\ttmp = ufs_new_fragments(inode, p, fragment -\n\t\t\t\t\t(blockoff - lastblockoff),\n\t\t\t\t\tufs_data_ptr_to_cpu(sb, p),\n\t\t\t\t\trequired +  (blockoff - lastblockoff),\n\t\t\t\t\terr, phys != NULL ? locked_page : NULL);\n\t} else /* (lastblock > block) */ {\n\t/*\n\t * We will allocate new block before last allocated block\n\t */\n\t\tif (block) {\n\t\t\ttmp = ufs_data_ptr_to_cpu(sb,\n\t\t\t\t\t\t ufs_get_direct_data_ptr(uspi, ufsi, block - 1));\n\t\t\tif (tmp)\n\t\t\t\tgoal = tmp + uspi->s_fpb;\n\t\t}\n\t\ttmp = ufs_new_fragments(inode, p, fragment - blockoff,\n\t\t\t\t\tgoal, uspi->s_fpb, err,\n\t\t\t\t\tphys != NULL ? locked_page : NULL);\n\t}\n\tif (!tmp) {\n\t\tif ((!blockoff && ufs_data_ptr_to_cpu(sb, p)) ||\n\t\t    (blockoff && lastfrag != ufsi->i_lastfrag))\n\t\t\tgoto repeat;\n\t\t*err = -ENOSPC;\n\t\treturn NULL;\n\t}\n\n\tif (!phys) {\n\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t} else {\n\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\tresult = NULL;\n\t\t*err = 0;\n\t\t*new = 1;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tufs_sync_inode (inode);\n\tmark_inode_dirty(inode);\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)tmp + blockoff);\n\treturn result;\n\n     /* This part : To be implemented ....\n        Required only for writing, not required for READ-ONLY.\nufs2:\n\n\tu2_block = ufs_fragstoblks(fragment);\n\tu2_blockoff = ufs_fragnum(fragment);\n\tp = ufsi->i_u1.u2_i_data + block;\n\tgoal = 0;\n\nrepeat2:\n\ttmp = fs32_to_cpu(sb, *p);\n\tlastfrag = ufsi->i_lastfrag;\n\n     */\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)tmp + blockoff"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_sync_inode",
          "args": [
            "inode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "876-879",
          "snippet": "int ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint ufs_sync_inode (struct inode *inode)\n{\n\treturn ufs_update_inode (inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "uspi->s_sbbase + tmp + blockoff"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_new_fragments",
          "args": [
            "inode",
            "p",
            "fragment - blockoff",
            "goal",
            "uspi->s_fpb",
            "err",
            "phys != NULL ? locked_page : NULL"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_new_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "341-491",
          "snippet": "u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\n\nu64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_direct_data_ptr",
          "args": [
            "uspi",
            "ufsi",
            "block - 1"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_direct_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "551-559",
          "snippet": "static inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern dev_t ufs_get_inode_dev(struct super_block *, struct ufs_inode_info *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void *ufs_get_direct_data_ptr(struct ufs_sb_private_info *uspi,\n\t\t\t\t\t    struct ufs_inode_info *ufsi,\n\t\t\t\t\t    unsigned blk)\n{\n\tBUG_ON(blk > UFS_TIND_BLOCK);\n\treturn uspi->fs_magic == UFS2_MAGIC ?\n\t\t(void *)&ufsi->i_u1.u2_i_data[blk] :\n\t\t(void *)&ufsi->i_u1.i_data[blk];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "lastfrag"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "lastfrag"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "result"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)tmp + blockoff"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "uspi->s_sbbase + tmp + blockoff"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "fragment"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, \"\n\t     \"metadata %d\\n\"",
            "inode->i_ino",
            "(unsigned long long)fragment",
            "(unsigned long long)new_fragment",
            "required",
            "!phys"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct buffer_head *\nufs_inode_getfrag(struct inode *inode, u64 fragment,\n\t\t  sector_t new_fragment, unsigned int required, int *err,\n\t\t  long *phys, int *new, struct page *locked_page)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * result;\n\tunsigned blockoff, lastblockoff;\n\tu64 tmp, goal, lastfrag, block, lastblock;\n\tvoid *p, *p2;\n\n\tUFSD(\"ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, \"\n\t     \"metadata %d\\n\", inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)new_fragment, required, !phys);\n\n        /* TODO : to be done for write support\n        if ( (flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n             goto ufs2;\n         */\n\n\tblock = ufs_fragstoblks (fragment);\n\tblockoff = ufs_fragnum (fragment);\n\tp = ufs_get_direct_data_ptr(uspi, ufsi, block);\n\n\tgoal = 0;\n\nrepeat:\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tlastfrag = ufsi->i_lastfrag;\n\tif (tmp && fragment < lastfrag) {\n\t\tif (!phys) {\n\t\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t\t\tif (tmp == ufs_data_ptr_to_cpu(sb, p)) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)tmp + blockoff);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbrelse (result);\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tlastblock = ufs_fragstoblks (lastfrag);\n\tlastblockoff = ufs_fragnum (lastfrag);\n\t/*\n\t * We will extend file into new block beyond last allocated block\n\t */\n\tif (lastblock < block) {\n\t\t/*\n\t\t * We must reallocate last allocated block\n\t\t */\n\t\tif (lastblockoff) {\n\t\t\tp2 = ufs_get_direct_data_ptr(uspi, ufsi, lastblock);\n\t\t\ttmp = ufs_new_fragments(inode, p2, lastfrag,\n\t\t\t\t\t\tufs_data_ptr_to_cpu(sb, p2),\n\t\t\t\t\t\tuspi->s_fpb - lastblockoff,\n\t\t\t\t\t\terr, locked_page);\n\t\t\tif (!tmp) {\n\t\t\t\tif (lastfrag != ufsi->i_lastfrag)\n\t\t\t\t\tgoto repeat;\n\t\t\t\telse\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlastfrag = ufsi->i_lastfrag;\n\t\t\t\n\t\t}\n\t\ttmp = ufs_data_ptr_to_cpu(sb,\n\t\t\t\t\t ufs_get_direct_data_ptr(uspi, ufsi,\n\t\t\t\t\t\t\t\t lastblock));\n\t\tif (tmp)\n\t\t\tgoal = tmp + uspi->s_fpb;\n\t\ttmp = ufs_new_fragments (inode, p, fragment - blockoff, \n\t\t\t\t\t goal, required + blockoff,\n\t\t\t\t\t err,\n\t\t\t\t\t phys != NULL ? locked_page : NULL);\n\t} else if (lastblock == block) {\n\t/*\n\t * We will extend last allocated block\n\t */\n\t\ttmp = ufs_new_fragments(inode, p, fragment -\n\t\t\t\t\t(blockoff - lastblockoff),\n\t\t\t\t\tufs_data_ptr_to_cpu(sb, p),\n\t\t\t\t\trequired +  (blockoff - lastblockoff),\n\t\t\t\t\terr, phys != NULL ? locked_page : NULL);\n\t} else /* (lastblock > block) */ {\n\t/*\n\t * We will allocate new block before last allocated block\n\t */\n\t\tif (block) {\n\t\t\ttmp = ufs_data_ptr_to_cpu(sb,\n\t\t\t\t\t\t ufs_get_direct_data_ptr(uspi, ufsi, block - 1));\n\t\t\tif (tmp)\n\t\t\t\tgoal = tmp + uspi->s_fpb;\n\t\t}\n\t\ttmp = ufs_new_fragments(inode, p, fragment - blockoff,\n\t\t\t\t\tgoal, uspi->s_fpb, err,\n\t\t\t\t\tphys != NULL ? locked_page : NULL);\n\t}\n\tif (!tmp) {\n\t\tif ((!blockoff && ufs_data_ptr_to_cpu(sb, p)) ||\n\t\t    (blockoff && lastfrag != ufsi->i_lastfrag))\n\t\t\tgoto repeat;\n\t\t*err = -ENOSPC;\n\t\treturn NULL;\n\t}\n\n\tif (!phys) {\n\t\tresult = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);\n\t} else {\n\t\t*phys = uspi->s_sbbase + tmp + blockoff;\n\t\tresult = NULL;\n\t\t*err = 0;\n\t\t*new = 1;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode))\n\t\tufs_sync_inode (inode);\n\tmark_inode_dirty(inode);\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)tmp + blockoff);\n\treturn result;\n\n     /* This part : To be implemented ....\n        Required only for writing, not required for READ-ONLY.\nufs2:\n\n\tu2_block = ufs_fragstoblks(fragment);\n\tu2_blockoff = ufs_fragnum(fragment);\n\tp = ufsi->i_u1.u2_i_data + block;\n\tgoal = 0;\n\nrepeat2:\n\ttmp = fs32_to_cpu(sb, *p);\n\tlastfrag = ufsi->i_lastfrag;\n\n     */\n}"
  },
  {
    "function_name": "ufs_frag_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "83-157",
    "snippet": "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;\n\tint shift = uspi->s_apbshift-uspi->s_fpbshift;\n\tsector_t offsets[4], *p;\n\tint depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);\n\tu64  ret = 0L;\n\t__fs32 block;\n\t__fs64 u2_block = 0L;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\tu64 temp = 0L;\n\n\tUFSD(\": frag = %llu  depth = %d\\n\", (unsigned long long)frag, depth);\n\tUFSD(\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\",\n\t\tuspi->s_fpbshift, uspi->s_apbmask,\n\t\t(unsigned long long)mask);\n\n\tif (depth == 0)\n\t\treturn 0;\n\n\tp = offsets;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tgoto ufs2;\n\n\tblock = ufsi->i_u1.i_data[*p++];\n\tif (!block)\n\t\tgoto out;\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tblock = ((__fs32 *) bh->b_data)[n & mask];\n\t\tbrelse (bh);\n\t\tif (!block)\n\t\t\tgoto out;\n\t}\n\tret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));\n\tgoto out;\nufs2:\n\tu2_block = ufsi->i_u1.u2_i_data[*p++];\n\tif (!u2_block)\n\t\tgoto out;\n\n\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\n\t\ttemp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);\n\t\tbh = sb_bread(sb, temp +(u64) (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tu2_block = ((__fs64 *)bh->b_data)[n & mask];\n\t\tbrelse(bh);\n\t\tif (!u2_block)\n\t\t\tgoto out;\n\t}\n\ttemp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);\n\tret = temp + (u64) (frag & uspi->s_fpbmask);\n\nout:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "frag & uspi->s_fpbmask"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "u2_block"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "temp +(u64) (n>>shift)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "n>>shift"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "uspi->s_sbbase"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "block"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\"",
            "uspi->s_fpbshift",
            "uspi->s_apbmask",
            "(unsigned long long)mask"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\": frag = %llu  depth = %d\\n\"",
            "(unsigned long long)frag",
            "depth"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_block_to_path",
          "args": [
            "inode",
            "frag >> uspi->s_fpbshift",
            "offsets"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "46-76",
          "snippet": "static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;\n\tint ptrs = uspi->s_apb;\n\tint ptrs_bits = uspi->s_apbshift;\n\tconst long direct_blocks = UFS_NDADDR,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\n\n\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = UFS_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = UFS_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = UFS_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else {\n\t\tufs_warning(inode->i_sb, \"ufs_block_to_path\", \"block > big\");\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;\n\tint ptrs = uspi->s_apb;\n\tint ptrs_bits = uspi->s_apbshift;\n\tconst long direct_blocks = UFS_NDADDR,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\n\n\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = UFS_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = UFS_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = UFS_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else {\n\t\tufs_warning(inode->i_sb, \"ufs_block_to_path\", \"block > big\");\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);\n\nstatic u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)\n{\n\tstruct ufs_inode_info *ufsi = UFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tu64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;\n\tint shift = uspi->s_apbshift-uspi->s_fpbshift;\n\tsector_t offsets[4], *p;\n\tint depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);\n\tu64  ret = 0L;\n\t__fs32 block;\n\t__fs64 u2_block = 0L;\n\tunsigned flags = UFS_SB(sb)->s_flags;\n\tu64 temp = 0L;\n\n\tUFSD(\": frag = %llu  depth = %d\\n\", (unsigned long long)frag, depth);\n\tUFSD(\": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\\n\",\n\t\tuspi->s_fpbshift, uspi->s_apbmask,\n\t\t(unsigned long long)mask);\n\n\tif (depth == 0)\n\t\treturn 0;\n\n\tp = offsets;\n\n\tif (needs_lock)\n\t\tlock_ufs(sb);\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tgoto ufs2;\n\n\tblock = ufsi->i_u1.i_data[*p++];\n\tif (!block)\n\t\tgoto out;\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\t\tbh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tblock = ((__fs32 *) bh->b_data)[n & mask];\n\t\tbrelse (bh);\n\t\tif (!block)\n\t\t\tgoto out;\n\t}\n\tret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));\n\tgoto out;\nufs2:\n\tu2_block = ufsi->i_u1.u2_i_data[*p++];\n\tif (!u2_block)\n\t\tgoto out;\n\n\n\twhile (--depth) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t n = *p++;\n\n\n\t\ttemp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);\n\t\tbh = sb_bread(sb, temp +(u64) (n>>shift));\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tu2_block = ((__fs64 *)bh->b_data)[n & mask];\n\t\tbrelse(bh);\n\t\tif (!u2_block)\n\t\t\tgoto out;\n\t}\n\ttemp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);\n\tret = temp + (u64) (frag & uspi->s_fpbmask);\n\nout:\n\tif (needs_lock)\n\t\tunlock_ufs(sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "ufs_block_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
    "lines": "46-76",
    "snippet": "static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;\n\tint ptrs = uspi->s_apb;\n\tint ptrs_bits = uspi->s_apbshift;\n\tconst long direct_blocks = UFS_NDADDR,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\n\n\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = UFS_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = UFS_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = UFS_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else {\n\t\tufs_warning(inode->i_sb, \"ufs_block_to_path\", \"block > big\");\n\t}\n\treturn n;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "inode->i_sb",
            "\"ufs_block_to_path\"",
            "\"block > big\""
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\"",
            "ptrs",
            "double_blocks"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;\n\tint ptrs = uspi->s_apb;\n\tint ptrs_bits = uspi->s_apbshift;\n\tconst long direct_blocks = UFS_NDADDR,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\n\n\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = UFS_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = UFS_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = UFS_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t} else {\n\t\tufs_warning(inode->i_sb, \"ufs_block_to_path\", \"block > big\");\n\t}\n\treturn n;\n}"
  }
]